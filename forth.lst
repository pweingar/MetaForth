
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass --mw65c02 --intel-hex -o forth.hex --list=forth.lst forth.asm
; Tue Mar 14 16:37:48 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: forth.asm


;******  Processing file: mf_pre_65c02.asm

=$0000					pstack = $0000          ; Location of the "bottom" of the parameter stack
=$1000					USERAREA = $1000        ; Area for user variables
=9					CHAR_TAB = 9

;******  Processing file: sections.asm


;******  Return to file: mf_pre_65c02.asm

>0020					ip      .word ?         ; Instruction pointer
>0022					wp      .word ?         ; Word pointer
>0024					up      .word ?         ; User pointer
>0026					donep   .word ?         ; Pointer to the code to take over when the interpreter quits
>0028					test    .word ?         ; Pointer to the current test name
>002a					tmp     .fill 4
>002e					savex   .byte ?
>002f					counter .byte ?         ; A counter used for some code
>0030					sign    .byte ?         ; A scratch byte to keep track of the sign of a number
.4000					coldstart:
.4000	20 64 40	jsr $4064	        jsr ioinit
.4003	4c 22 40	jmp $4022	        jmp start
.4006					init_user:
>4006	6e 00				        .word $006e     ; Initial PSP (S0)
>4008	ff 00				        .word $00ff     ; Initial RSP (R0)
>400a	0a 00				        .word 10        ; Initial BASE
>400c	00 00				        .word 0         ; Initial STATE
>400e	00 00				        .word 0         ; Initial CONTEXT
>4010	00 00				        .word 0         ; Initial CURRENT
>4012	00 10				        .word $1000     ; Initial DP
>4014	00 00				        .word 0         ; Initial >IN
>4016	00 3f				        .word $3f00     ; Initial TIB
>4018	00 00				        .word 0         ; Initial SOURCE-ID
>401a	00 00				        .word 0         ; Initial BLK
>401c	ff ff				        .word $ffff     ; Initial DPL
>401e	00 00				        .word 0         ; Initial HLD
>4020	00 00				        .word 0         ; Initial HANDLER
.4022					init_user_end:
=0					user_s0 = 0
=2					user_r0 = 2
=4					user_base = 4
=6					user_state = 6
=8					user_context = 8
=10					user_current = 10
=12					user_dp = 12
=14					user_in = 14
=16					user_tib = 16
=18					user_source_id = 18
=20					user_blk = 20
=22					user_dpl = 22
=24					user_hld = 24
=26					user_handler = 26
.4022	a2 6e		ldx #$6e	start   ldx #$6e        ; Initialize the PSP
.4024	a9 43		lda #$43	        lda #<vstart
.4026	85 20		sta $20		        sta ip
.4028	a9 40		lda #$40	        lda #>vstart
.402a	85 21		sta $21		        sta ip+1
.402c	a9 00		lda #$00	        lda #<USERAREA
.402e	85 24		sta $24		        sta up
.4030	a9 10		lda #$10	        lda #>USERAREA
.4032	85 25		sta $25		        sta up+1
.4034	a0 00		ldy #$00	        ldy #0
.4036					init_user_loop:
.4036	b9 06 40	lda $4006,y	        lda init_user,y
.4039	91 24		sta ($24),y	        sta (up),y
.403b	c8		iny		        iny
.403c	c0 1c		cpy #$1c	        cpy #(init_user_end - init_user)
.403e	d0 f6		bne $4036	        bne init_user_loop
.4040	4c 4a 40	jmp $404a	        jmp next
>4043	b4 60				vstart  .word xt_cold
>4045	c1 43				        .word xt_halt
.4047	6c 26 00	jmp ($0026)	done    jmp (donep)     ; Quit the interpreter by going to the code at donep
.404a	a0 01		ldy #$01	next    ldy #1          ; wp := (ip)
.404c	b2 20		lda ($20)	        lda (ip)
.404e	85 22		sta $22		        sta wp
.4050	b1 20		lda ($20),y	        lda (ip),y
.4052	85 23		sta $23		        sta wp+1
.4054	18		clc		        clc             ; ip := ip + 2
.4055	a5 20		lda $20		        lda ip
.4057	69 02		adc #$02	        adc #2
.4059	85 20		sta $20		        sta ip
.405b	a5 21		lda $21		        lda ip+1
.405d	69 00		adc #$00	        adc #0
.405f	85 21		sta $21		        sta ip+1
.4061	6c 22 00	jmp ($0022)	        jmp (wp)        ; jmp (wp)

;******  Processing file: io.asm


;******  Processing file: io_f256.asm

=$0000					MMU_MEM_CTRL = $0000
=$0001					MMU_IO_CTRL = $0001
=$00					MMU_IO_PAGE_0 = $00
=$01					MMU_IO_PAGE_1 = $01
=$02					MMU_IO_PAGE_TEXT = $02
=$03					MMU_IO_PAGE_COLOR = $03
=$d000					VKY_MST_CTRL_0 = $d000
=$01					VKY_MST_TEXT = $01
=$02					VKY_MST_OVLY = $02
=$04					VKY_MST_GRAPHICS = $04
=$08					VKY_MST_BITMAP = $08
=$10					VKY_MST_TILE = $10
=$20					VKY_MST_SPRITE = $20
=$40					VKY_MST_GAMMA = $40
=$d001					VKY_MST_CTRL_1 = $d001
=$01					VKY_MST_RES_400 = $01
=$02					VKY_MST_DBL_X = $02
=$04					VKY_MST_DBL_Y = $04
=$08					VKY_MST_SLEEP = $08
=$10					VKY_MST_OVLY_TRANS = $10
=$d004					VKY_BRD_CTRL = $d004
=$d005					VKY_BRD_BLUE = $d005
=$d006					VKY_BRD_GREEN = $d006
=$d007					VKY_BRD_RED = $d007
=$d008					VKY_BRD_SIZE_X = $d008
=$d009					VKY_BRD_SIZE_Y = $d009
=$d010					VKY_CURS_CTRL = $d010
=$01					VKY_CURS_ENABLE = $01
=$08					VKY_CURS_FLASH_1S = $08
=$0a					VKY_CURS_FLASH_0_5S = $0a
=$0c					VKY_CURS_FLASH_0_25S = $0c
=$0d					VKY_CURS_FLASH_0_125S = $0d
=$d012					VKY_CURS_CHAR = $d012
=$d014					VKY_CURS_X = $d014
=$d016					VKY_CURS_Y = $d016
=$c000					VKY_TEXT_MATRIX = $c000
=$d800					VKY_TEXT_FG_LUT = $d800
=$d840					VKY_TEXT_BG_LUT = $d840
=$c000					VKY_TEXT_FONT = $c000
=$d66c					INT_MASK_0 = $D66C
=$d660					INT_PEND_0 = $D660
=$d66d					INT_MASK_1 = $D66D
=$d661					INT_PEND_1 = $D661
=$04					INT_PS2_KBD = $04

;******  Return to file: io.asm


;******  Processing file: api.asm

>ff00					NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04					ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08					ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c					Yield       .fill   4   ; Give unused time to the kernel.
>ff10					Putch       .fill   4   ; deprecated
>ff14					RunBlock    .fill   4   ; Chain to resident program by block ID.
>ff18					RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c					            .fill   4   ; reserved
>ff20					List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24					GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28					GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c					Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30					Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34					Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38					Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c					List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40					GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44					MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48					CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c					Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50					Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54					ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58					WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c					Open        .fill   4   ; Open the given file for read, create, or append.
>ff60					Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64					Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68					Close       .fill   4   ; Close an open file.
>ff6c					Rename      .fill   4   ; Rename a closed file.
>ff70					Delete      .fill   4   ; Delete a closed file.
>ff74					Open        .fill   4   ; Open a directory for reading.
>ff78					Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff7c					Close       .fill   4   ; Close a directory once finished reading.
>ff80					MkDir       .fill   4
>ff84					RmDir       .fill   4
>ff88					            .fill   4   ; call gate
>ff8c					GetIP       .fill   4   ; Get the local IP address.
>ff90					SetIP       .fill   4   ; Set the local IP address.
>ff94					GetDNS      .fill   4   ; Get the configured DNS IP address.
>ff98					SetDNS      .fill   4   ; Set the configured DNS IP address.
>ff9c					SendICMP    .fill   4
>ffa0					Match       .fill   4
>ffa4					Init        .fill   4
>ffa8					Send        .fill   4
>ffac					Recv        .fill   4
>ffb0					Open        .fill   4
>ffb4					Accept      .fill   4
>ffb8					Reject      .fill   4
>ffbc					Send        .fill   4
>ffc0					Recv        .fill   4
>ffc4					Close       .fill   4
>ffc8					Reset       .fill   4   ; Re-init the display
>ffcc					GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ffd0					DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ffd4					DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ffd8					GetTime     .fill   4
>ffdc					SetTime     .fill   4
>ffe0					GetSysInfo  .fill   4
>ffe4					SetBPS      .fill   4   ; Set the serial BPS (should match the SLIP router's speed).
.00f0					args
.00f0					events
>00f0					dest        .word       ?   ; GetNextEvent copies event data here
>00f2					pending     .byte       ?   ; Negative count of pending events
.00f3					end
.00f3					run
>00f3					block_id    .byte   ?
.00f3					recv
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.00f3					fs
.00f3					format
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.00f3					mkfs
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.00f3					file
.00f3					open
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>00f5					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.00f3					read
>00f3					stream      .byte       ?
>00f4					buflen      .byte       ?
.00f3					write
>00f3					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.00f3					close
>00f3					stream      .byte       ?
.00f3					rename
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.00f3					delete
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>00f5					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.00f3					directory
.00f3					open
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.00f3					read
>00f3					stream      .byte       ?
>00f4					buflen      .byte       ?
.00f3					close
>00f3					stream      .byte       ?
.00f3					display
>00f3					x           .byte       ?   ; coordinate or size
>00f4					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.00f3					net
=$fb					socket      = args.buf
>00f3					src_port    .word       ?
>00f5					dest_port   .word       ?
>00f7					dest_ip     .fill       4
>00f3					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
=$f8					ext         = $f8
=$fa					extlen      = $fa
=$fb					buf         = $fb
=$fd					buflen      = $fd
=$fe					ptr         = $fe
.0000					args_t
.0000					events
>0000					dest        .word       ?   ; GetNextEvent copies event data here
>0002					pending     .byte       ?   ; Negative count of pending events
.0003					end
.0003					run
>0003					block_id    .byte   ?
.0003					recv
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0003					fs
.0003					format
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0003					mkfs
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0003					file
.0003					open
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0005					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0003					read
>0003					stream      .byte       ?
>0004					buflen      .byte       ?
.0003					write
>0003					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0003					close
>0003					stream      .byte       ?
.0003					rename
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0003					delete
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0005					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0003					directory
.0003					open
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0003					read
>0003					stream      .byte       ?
>0004					buflen      .byte       ?
.0003					close
>0003					stream      .byte       ?
.0003					display
>0003					x           .byte       ?   ; coordinate or size
>0004					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.0003					net
=$fb					socket      = args.buf
>0003					src_port    .word       ?
>0005					dest_port   .word       ?
>0007					dest_ip     .fill       4
>0003					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
=$f8					ext         = $f8
=$fa					extlen      = $fa
=$fb					buf         = $fb
=$fd					buflen      = $fd
=$fe					ptr         = $fe
.0000					event_t
>0000					dest        .word       ?   ; GetNextEvent copies event data here
>0002					pending     .byte       ?   ; Negative count of pending events
.0003					end
.0000					recv_t
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0000					run_t
>0000					block_id    .byte   ?
.0000					fs_t
.0000					format
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					mkfs
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					fs_mkfs_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					file_t
.0000					open
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0000					read
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					write
>0000					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0000					close
>0000					stream      .byte       ?
.0000					rename
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0000					delete
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0000					fs_open_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0000					fs_read_t
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					fs_write_t
>0000					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0000					fs_close_t
>0000					stream      .byte       ?
.0000					fs_rename_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0000					fs_delete_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fnane       = args.buf
=$fd					fname_len   = args.buflen
.0000					dir_t
.0000					open
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0000					read
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					close
>0000					stream      .byte       ?
.0000					dir_open_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0000					dir_read_t
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					dir_close_t
>0000					stream      .byte       ?
.0000					display_t
>0000					x           .byte       ?   ; coordinate or size
>0001					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.0000					net_t
=$fb					socket      = args.buf
>0000					src_port    .word       ?
>0002					dest_port   .word       ?
>0004					dest_ip     .fill       4
>0000					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
>0000					            .word   ?   ; Reserved
>0002					            .word   ?   ; Deprecated
>0004					JOYSTICK    .word   ?   ; Game Controller changes.
>0006					DEVICE      .word   ?   ; Device added/removed.
>0008					PRESSED     .word   ?   ; Key pressed
>000a					RELEASED    .word   ?   ; Key released.
>000c					DELTA       .word   ?   ; Regular mouse move and button state
>000e					CLICKS      .word   ?   ; Click counts
>0010					NAME        .word   ?
>0012					SIZE        .word   ?
>0014					DATA        .word   ?   ; The read request has succeeded.
>0016					WROTE       .word   ?   ; The write request has completed.
>0018					FORMATTED   .word   ?   ; The low-level format has completed.
>001a					ERROR       .word   ?
>001c					SIZE        .word   ?
>001e					CREATED     .word   ?
>0020					CHECKED     .word   ?
>0022					DATA        .word   ?   ; The read request has succeeded.
>0024					WROTE       .word   ?   ; The write request has completed.
>0026					ERROR       .word   ?
>0028					NOT_FOUND   .word   ?   ; The file file was not found.
>002a					OPENED      .word   ?   ; The file was successfully opened.
>002c					DATA        .word   ?   ; The read request has succeeded.
>002e					WROTE       .word   ?   ; The write request has completed.
>0030					EOF         .word   ?   ; All file data has been read.
>0032					CLOSED      .word   ?   ; The close request has completed.
>0034					RENAMED     .word   ?   ; The rename request has completed.
>0036					DELETED     .word   ?   ; The delete request has completed.
>0038					ERROR       .word   ?   ; An error occured; close the file if opened.
>003a					OPENED      .word   ?   ; The directory open request succeeded.
>003c					VOLUME      .word   ?   ; A volume record was found.
>003e					FILE        .word   ?   ; A file record was found.
>0040					FREE        .word   ?   ; A file-system free-space record was found.
>0042					EOF         .word   ?   ; All data has been read.
>0044					CLOSED      .word   ?   ; The directory file has been closed.
>0046					ERROR       .word   ?   ; An error occured; user should close.
>0048					TCP         .word   ?
>004a					UDP         .word   ?
.0000					event_t
>0000					type        .byte   ?   ; Enum above
>0001					buf         .byte   ?   ; page id or zero
>0002					ext         .byte   ?   ; page id or zero
.0003					key
>0003					keyboard    .byte   ?   ; Keyboard ID
>0004					raw         .byte   ?   ; Raw key ID
>0005					ascii       .byte   ?   ; ASCII value
>0006					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0003					mouse
.0003					delta
>0003					x           .byte   ?
>0004					y           .byte   ?
>0005					z           .byte   ?
>0006					buttons     .byte   ?
.0003					clicks
>0003					inner       .byte   ?
>0004					middle      .byte   ?
>0005					outer       .byte   ?
.0003					joystick
>0003					joy0        .byte   ?
>0004					joy1        .byte   ?
.0003					udp
>0003					token       .byte   ?   ; TODO: break out into fields
.0003					tcp
>0003					len         .byte   ?   ; Raw packet length.
.0003					file
>0003					stream      .byte   ?
>0004					cookie      .byte   ?
.0005					data
>0005					requested   .byte   ?   ; Requested number of bytes to read
>0006					read        .byte   ?   ; Number of bytes actually read
.0005					wrote
>0005					requested   .byte   ?   ; Requested number of bytes to read
>0006					wrote       .byte   ?   ; Number of bytes actually read
.0003					directory
>0003					stream      .byte   ?
>0004					cookie      .byte   ?
.0005					volume
>0005					len         .byte   ?   ; Length of volname (in buf)
>0006					flags       .byte   ?   ; block size, text encoding
.0005					file
>0005					len         .byte   ?
>0006					flags       .byte   ?   ; block scale, text encoding, approx size
.0005					free
>0005					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					key_t
>0000					keyboard    .byte   ?   ; Keyboard ID
>0001					raw         .byte   ?   ; Raw key ID
>0002					ascii       .byte   ?   ; ASCII value
>0003					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0000					mouse_t
.0000					delta
>0000					x           .byte   ?
>0001					y           .byte   ?
>0002					z           .byte   ?
>0003					buttons     .byte   ?
.0000					clicks
>0000					inner       .byte   ?
>0001					middle      .byte   ?
>0002					outer       .byte   ?
.0000					m_delta_t
>0000					x           .byte   ?
>0001					y           .byte   ?
>0002					z           .byte   ?
>0003					buttons     .byte   ?
.0000					m_clicks_t
>0000					inner       .byte   ?
>0001					middle      .byte   ?
>0002					outer       .byte   ?
.0000					joystick_t
>0000					joy0        .byte   ?
>0001					joy1        .byte   ?
.0000					file_t
>0000					stream      .byte   ?
>0001					cookie      .byte   ?
.0002					data
>0002					requested   .byte   ?   ; Requested number of bytes to read
>0003					read        .byte   ?   ; Number of bytes actually read
.0002					wrote
>0002					requested   .byte   ?   ; Requested number of bytes to read
>0003					wrote       .byte   ?   ; Number of bytes actually read
.0000					fs_data_t
>0000					requested   .byte   ?   ; Requested number of bytes to read
>0001					read        .byte   ?   ; Number of bytes actually read
.0000					fs_wrote_t
>0000					requested   .byte   ?   ; Requested number of bytes to read
>0001					wrote       .byte   ?   ; Number of bytes actually read
.0000					dir_t
>0000					stream      .byte   ?
>0001					cookie      .byte   ?
.0002					volume
>0002					len         .byte   ?   ; Length of volname (in buf)
>0003					flags       .byte   ?   ; block size, text encoding
.0002					file
>0002					len         .byte   ?
>0003					flags       .byte   ?   ; block scale, text encoding, approx size
.0002					free
>0002					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					dir_vol_t
>0000					len         .byte   ?   ; Length of volname (in buf)
>0001					flags       .byte   ?   ; block size, text encoding
.0000					dir_file_t
>0000					len         .byte   ?
>0001					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					dir_free_t
>0000					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					dir_ext_t
>0000					free        .fill   6   ; blocks used/free
.0000					udp_t
>0000					token       .byte   ?   ; TODO: break out into fields
.0000					tcp_t
>0000					len         .byte   ?   ; Raw packet length.

;******  Return to file: io.asm

=8					CHAR_BS = 8                         ; Backspace
=12					CHAR_FF = 12                        ; Form feed character
=13					CHAR_NL = 13                        ; Newline character
=$f4					DEF_COLOR = $f4                     ; Default color
>0031					cur_line    .word ?                 ; Address of the current line on the text screen
>0033					src_ptr     .word ?                 ; General pointer for the source of something in memory
>0035					dst_ptr     .word ?                 ; General pointer for the destination of something in memory
.0200					event
>0200					type        .byte   ?   ; Enum above
>0201					buf         .byte   ?   ; page id or zero
>0202					ext         .byte   ?   ; page id or zero
.0203					key
>0203					keyboard    .byte   ?   ; Keyboard ID
>0204					raw         .byte   ?   ; Raw key ID
>0205					ascii       .byte   ?   ; ASCII value
>0206					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0203					mouse
.0203					delta
>0203					x           .byte   ?
>0204					y           .byte   ?
>0205					z           .byte   ?
>0206					buttons     .byte   ?
.0203					clicks
>0203					inner       .byte   ?
>0204					middle      .byte   ?
>0205					outer       .byte   ?
.0203					joystick
>0203					joy0        .byte   ?
>0204					joy1        .byte   ?
.0203					udp
>0203					token       .byte   ?   ; TODO: break out into fields
.0203					tcp
>0203					len         .byte   ?   ; Raw packet length.
.0203					file
>0203					stream      .byte   ?
>0204					cookie      .byte   ?
.0205					data
>0205					requested   .byte   ?   ; Requested number of bytes to read
>0206					read        .byte   ?   ; Number of bytes actually read
.0205					wrote
>0205					requested   .byte   ?   ; Requested number of bytes to read
>0206					wrote       .byte   ?   ; Number of bytes actually read
.0203					directory
>0203					stream      .byte   ?
>0204					cookie      .byte   ?
.0205					volume
>0205					len         .byte   ?   ; Length of volname (in buf)
>0206					flags       .byte   ?   ; block size, text encoding
.0205					file
>0205					len         .byte   ?
>0206					flags       .byte   ?   ; block scale, text encoding, approx size
.0205					free
>0205					flags       .byte   ?   ; block scale, text encoding, approx size
>0207					curs_color  .byte ?                 ; Current color for printing
>0208					curs_x      .byte ?                 ; Current column for the text cursor
>0209					curs_y      .byte ?                 ; Current row for the text cursor
>020a					old_y       .byte ?                 ; Previous cursor row
>020b					curs_width  .byte ?                 ; Width of the screen in text columns
>020c					curs_height .byte ?                 ; Height of the screen in text columns
.4064					ioinit:
.4064	a9 00		lda #$00	            lda #<event                     ; Point to our event record
.4066	85 f0		sta $f0				    sta kernel.args.events+0
.4068	a9 02		lda #$02			    lda #>event
.406a	85 f1		sta $f1				    sta kernel.args.events+1
.406c	20 87 40	jsr $4087	            jsr initlut                     ; Initialize the CLUT
.406f	a9 f4		lda #$f4	            lda #DEF_COLOR                  ; Set the default color (will be defined with the LUT)
.4071	8d 07 02	sta $0207	            sta curs_color
.4074	a9 ff		lda #$ff	            lda #$ff                        ; Set old_y to something silly
.4076	8d 0a 02	sta $020a	            sta old_y
.4079	a9 50		lda #$50	            lda #80
.407b	8d 0b 02	sta $020b	            sta curs_width
.407e	a9 3c		lda #$3c	            lda #60
.4080	8d 0c 02	sta $020c	            sta curs_height
.4083	20 f9 40	jsr $40f9	            jsr consclr                     ; Clear the text screen and home the cursor
.4086	60		rts		            rts
.4087					initlut:
.4087	48		pha		            pha
.4088	5a		phy		            phy
.4089	a5 01		lda $01		            lda MMU_IO_CTRL             ; Save the current I/O page
.408b	48		pha		            pha
.408c	a9 00		lda #$00	            lda #MMU_IO_PAGE_0          ; Make sure we're on I/O page #0
.408e	85 01		sta $01		            sta MMU_IO_CTRL
.4090	a0 00		ldy #$00	            ldy #0
.4092	b9 a6 40	lda $40a6,y	loop:       lda text_lut,y              ; Get a color component
.4095	99 00 d8	sta $d800,y	            sta VKY_TEXT_FG_LUT,y       ; Write it to the text foreground CLUT
.4098	99 40 d8	sta $d840,y	            sta VKY_TEXT_BG_LUT,y       ; And then to the text background CLUT
.409b	c8		iny		            iny
.409c	c0 40		cpy #$40	            cpy #4*16                   ; Have we copied all 16 colors (4 components)
.409e	d0 f2		bne $4092	            bne loop                    ; No: copy the next one
.40a0	68		pla		            pla
.40a1	85 01		sta $01		            sta MMU_IO_CTRL             ; Restore the current I/O page
.40a3	7a		ply		            ply
.40a4	68		pla		            pla
.40a5	60		rts		            rts
>40a6	00 00 00 00			text_lut:   .byte $00, $00, $00, $00    ; Black
>40aa	00 00 80 00			            .byte $00, $00, $80, $00    ; Red
>40ae	00 80 00 00			            .byte $00, $80, $00, $00    ; Green
>40b2	00 80 80 00			            .byte $00, $80, $80, $00    ; Yellow
>40b6	80 00 00 00			            .byte $80, $00, $00, $00    ; Blue
>40ba	80 00 80 00			            .byte $80, $00, $80, $00    ; Magenta
>40be	80 80 00 00			            .byte $80, $80, $00, $00    ; Cyan
>40c2	8c 8c 8c 00			            .byte $8c, $8c, $8c, $00    ; White
>40c6	80 80 80 00			            .byte $80, $80, $80, $00    ; Bright Black
>40ca	00 00 ff 00			            .byte $00, $00, $ff, $00    ; Bright Red
>40ce	00 ff 00 00			            .byte $00, $ff, $00, $00    ; Bright Green
>40d2	00 ff ff 00			            .byte $00, $ff, $ff, $00    ; Bright Yellow
>40d6	ff 00 00 00			            .byte $ff, $00, $00, $00    ; Bright Blue
>40da	ff 00 ff 00			            .byte $ff, $00, $ff, $00    ; Bright Magenta
>40de	ff ff 00 00			            .byte $ff, $ff, $00, $00    ; Bright Cyan
>40e2	ff ff ff 00			            .byte $ff, $ff, $ff, $00    ; Bright White
.40e6					constat:
.40e6	a9 00		lda #$00	            lda #0
.40e8	60		rts		            rts
.40e9					conin:
.40e9	20 00 ff	jsr $ff00	            jsr kernel.NextEvent            ; Grab the event
.40ec	b0 fb		bcs $40e9	            bcs conin
.40ee	ad 00 02	lda $0200	            lda event.type                  ; Check the event type
.40f1	c9 08		cmp #$08	            cmp #kernel.event.key.PRESSED
.40f3	d0 f4		bne $40e9	            bne conin
.40f5	ad 05 02	lda $0205	            lda event.key.ascii             ; Get the ASCII code of the key pressed
.40f8	60		rts		            rts
.40f9					consclr:
.40f9	48		pha		            pha
.40fa	da		phx		            phx
.40fb	a9 00		lda #$00	            lda #<VKY_TEXT_MATRIX   ; Move the current line to the first line
.40fd	85 31		sta $31		            sta cur_line
.40ff	a9 c0		lda #$c0	            lda #>VKY_TEXT_MATRIX
.4101	85 32		sta $32		            sta cur_line+1
.4103	a0 00		ldy #$00	            ldy #0
.4105	20 00 42	jsr $4200	loop:       jsr clrline             ; Clear the current line
.4108	c8		iny		            iny                     ; Move to the next line
.4109	cc 0c 02	cpy $020c	            cpy curs_height
.410c	f0 10		beq $411e	            beq home                ; If we've done the last line, home the cursor
.410e	18		clc		            clc                     ; Advance cur_line to the next line in the matrix
.410f	a5 31		lda $31		            lda cur_line
.4111	6d 0b 02	adc $020b	            adc curs_width
.4114	85 31		sta $31		            sta cur_line
.4116	a5 32		lda $32		            lda cur_line+1
.4118	69 00		adc #$00	            adc #0
.411a	85 32		sta $32		            sta cur_line+1
.411c	80 e7		bra $4105	            bra loop                ; And go back to clear it too
.411e	9c 08 02	stz $0208	home:       stz curs_x              ; Set the cursor to (0, 0)
.4121	9c 09 02	stz $0209	            stz curs_y
.4124	20 2a 41	jsr $412a	            jsr cursset
.4127	fa		plx		            plx
.4128	68		pla		            pla
.4129	60		rts		            rts
.412a					cursset:
.412a	48		pha		            pha
.412b	5a		phy		            phy
.412c	ad 08 02	lda $0208	            lda curs_x              ; Where is the cursor column pointing
.412f	cd 0b 02	cmp $020b	            cmp curs_width
.4132	90 06		bcc $413a	            blt chk_row             ; If on screen, let's check the row
.4134	9c 08 02	stz $0208	            stz curs_x              ; If not on screen, move it to the left and down
.4137	ee 09 02	inc $0209	            inc curs_y
.413a					chk_row:
.413a	ad 09 02	lda $0209	            lda curs_y              ; Where is the cursor row pointing
.413d	cd 0c 02	cmp $020c	            cmp curs_height
.4140	90 0a		bcc $414c	            blt set_hw              ; If on screen, set the hardware registers
.4142	ad 0c 02	lda $020c	            lda curs_height         ; Otherwise: Move the last visible row
.4145	3a		dec a		            dec a
.4146	8d 09 02	sta $0209	            sta curs_y
.4149	20 8a 41	jsr $418a	            jsr consscroll          ; And we need to scroll the screen
.414c	ad 08 02	lda $0208	set_hw:     lda curs_x              ; Set the hardware cursor column
.414f	8d 14 d0	sta $d014	            sta VKY_CURS_X
.4152	9c 15 d0	stz $d015	            stz VKY_CURS_X+1
.4155	ad 09 02	lda $0209	            lda curs_y              ; Set the hardware cursor row
.4158	8d 16 d0	sta $d016	            sta VKY_CURS_Y
.415b	9c 17 d0	stz $d017	            stz VKY_CURS_Y+1
.415e	ad 0a 02	lda $020a	            lda old_y               ; Is old_y == curs_y
.4161	cd 09 02	cmp $0209	            cmp curs_y
.4164	f0 21		beq $4187	            beq done                ; Yes: we are done
.4166	a9 00		lda #$00	            lda #<VKY_TEXT_MATRIX   ; Start on the first line
.4168	85 31		sta $31		            sta cur_line
.416a	a9 c0		lda #$c0	            lda #>VKY_TEXT_MATRIX
.416c	85 32		sta $32		            sta cur_line+1
.416e	ac 09 02	ldy $0209	            ldy curs_y              ; Get the desired row
.4171	8c 0a 02	sty $020a	            sty old_y               ; And mark that it will be our old row from now on
.4174	f0 11		beq $4187	            beq done                ; If it's zero, we are done
.4176	18		clc		loop:       clc                     ; Move cur_line to the next line
.4177	a5 31		lda $31		            lda cur_line
.4179	6d 0b 02	adc $020b	            adc curs_width
.417c	85 31		sta $31		            sta cur_line
.417e	a5 32		lda $32		            lda cur_line+1
.4180	69 00		adc #$00	            adc #0
.4182	85 32		sta $32		            sta cur_line+1
.4184	88		dey		            dey                     ; Decrement line counter
.4185	d0 ef		bne $4176	            bne loop                ; If not zero, keep moving down a line
.4187	7a		ply		done:       ply
.4188	68		pla		            pla
.4189	60		rts		            rts
.418a					consscroll:
.418a	48		pha		            pha
.418b	da		phx		            phx
.418c	a5 32		lda $32		            lda cur_line+1          ; Save the current line
.418e	48		pha		            pha
.418f	a5 31		lda $31		            lda cur_line
.4191	48		pha		            pha
.4192	a5 01		lda $01		            lda MMU_IO_CTRL         ; Save the current I/O page
.4194	48		pha		            pha
.4195	a9 00		lda #$00	            lda #<VKY_TEXT_MATRIX   ; Destination pointer is the first line
.4197	85 35		sta $35		            sta dst_ptr
.4199	a9 c0		lda #$c0	            lda #>VKY_TEXT_MATRIX
.419b	85 36		sta $36		            sta dst_ptr+1
.419d	18		clc		            clc                     ; src_ptr is the second line
.419e	a5 35		lda $35		            lda dst_ptr
.41a0	6d 0b 02	adc $020b	            adc curs_width
.41a3	85 33		sta $33		            sta src_ptr
.41a5	a5 36		lda $36		            lda dst_ptr+1
.41a7	69 00		adc #$00	            adc #0
.41a9	85 34		sta $34		            sta src_ptr+1
.41ab	a2 01		ldx #$01	            ldx #1                  ; X will be our source row number
.41ad	a9 02		lda #$02	copy_text:  lda #MMU_IO_PAGE_TEXT   ; Move to the text page
.41af	85 01		sta $01		            sta MMU_IO_CTRL
.41b1	a0 00		ldy #$00	            ldy #0                  ; Copy a text line from src to dst
.41b3	b1 33		lda ($33),y	loop1:      lda (src_ptr),y
.41b5	91 35		sta ($35),y	            sta (dst_ptr),y
.41b7	c8		iny		            iny
.41b8	cc 0b 02	cpy $020b	            cpy curs_width
.41bb	d0 f6		bne $41b3	            bne loop1
.41bd	a9 03		lda #$03	            lda #MMU_IO_PAGE_COLOR  ; Move to the text color page
.41bf	85 01		sta $01		            sta MMU_IO_CTRL
.41c1	a0 00		ldy #$00	            ldy #0                  ; Copy a color line from src to dst
.41c3	b1 33		lda ($33),y	loop2:      lda (src_ptr),y
.41c5	91 35		sta ($35),y	            sta (dst_ptr),y
.41c7	c8		iny		            iny
.41c8	cc 0b 02	cpy $020b	            cpy curs_width
.41cb	d0 f6		bne $41c3	            bne loop2
.41cd	a5 33		lda $33		            lda src_ptr             ; Move dst_ptr to the next line
.41cf	85 35		sta $35		            sta dst_ptr
.41d1	a5 34		lda $34		            lda src_ptr+1
.41d3	85 36		sta $36		            sta dst_ptr+1
.41d5	18		clc		            clc                     ; Move src_ptr to the next line
.41d6	a5 33		lda $33		            lda src_ptr
.41d8	6d 0b 02	adc $020b	            adc curs_width
.41db	85 33		sta $33		            sta src_ptr
.41dd	a5 34		lda $34		            lda src_ptr+1
.41df	69 00		adc #$00	            adc #0
.41e1	85 34		sta $34		            sta src_ptr+1
.41e3	e8		inx		            inx                     ; Move src line number to the next row
.41e4	ec 0c 02	cpx $020c	            cpx curs_height         ; Have we copied the last row?
.41e7	d0 c4		bne $41ad	            bne copy_text           ; No: copy the line
.41e9	a5 35		lda $35		            lda dst_ptr             ; Clear the destination line
.41eb	85 31		sta $31		            sta cur_line
.41ed	a5 36		lda $36		            lda dst_ptr+1
.41ef	85 31		sta $31		            sta cur_line
.41f1	20 00 42	jsr $4200	            jsr clrline
.41f4	68		pla		            pla                     ; Restore the original I/O page
.41f5	85 01		sta $01		            sta MMU_IO_CTRL
.41f7	68		pla		            pla                     ; Restore the current line
.41f8	85 31		sta $31		            sta cur_line
.41fa	68		pla		            pla
.41fb	85 32		sta $32		            sta cur_line+1
.41fd	fa		plx		            plx
.41fe	68		pla		            pla
.41ff	60		rts		            rts
.4200					clrline:
.4200	48		pha		            pha
.4201	5a		phy		            phy
.4202	a5 01		lda $01		            lda MMU_IO_CTRL         ; Save the current I/O page
.4204	48		pha		            pha
.4205	a9 02		lda #$02	            lda #MMU_IO_PAGE_TEXT   ; Move to the text page
.4207	85 01		sta $01		            sta MMU_IO_CTRL
.4209	a0 00		ldy #$00	            ldy #0                  ; Fill the text matrix line with blanks
.420b	a9 20		lda #$20	            lda #' '
.420d	91 31		sta ($31),y	loop1:      sta (cur_line),y
.420f	c8		iny		            iny
.4210	cc 0b 02	cpy $020b	            cpy curs_width
.4213	d0 f8		bne $420d	            bne loop1
.4215	a9 03		lda #$03	            lda #MMU_IO_PAGE_COLOR  ; Move to the text color page
.4217	85 01		sta $01		            sta MMU_IO_CTRL
.4219	a0 00		ldy #$00	            ldy #0                  ; Fill the color matrix line with the current color
.421b	ad 07 02	lda $0207	            lda curs_color
.421e	91 31		sta ($31),y	loop2:      sta (cur_line),y
.4220	c8		iny		            iny
.4221	cc 0b 02	cpy $020b	            cpy curs_width
.4224	d0 f8		bne $421e	            bne loop2
.4226	68		pla		            pla                     ; Restore the original I/O page
.4227	85 01		sta $01		            sta MMU_IO_CTRL
.4229	7a		ply		            ply
.422a	68		pla		            pla
.422b	60		rts		            rts
.422c					conout:
.422c	5a		phy		            phy
.422d	c9 0d		cmp #$0d	            cmp #CHAR_NL            ; Is it a carriage return?
.422f	d0 0b		bne $423c	            bne not_cr
.4231	9c 08 02	stz $0208	            stz curs_x              ; Yes: Do a carriage return
.4234	ee 09 02	inc $0209	            inc curs_y
.4237	20 2a 41	jsr $412a	            jsr cursset
.423a	80 44		bra $4280	            bra done
.423c	c9 0c		cmp #$0c	not_cr:     cmp #CHAR_FF            ; Is it a FF character?
.423e	d0 05		bne $4245	            bne not_ff
.4240	20 f9 40	jsr $40f9	            jsr consclr             ; Yes: clear the screen
.4243	80 3b		bra $4280	            bra done
.4245	c9 08		cmp #$08	not_ff:     cmp #CHAR_BS            ; Is it a backspace character?
.4247	d0 15		bne $425e	            bne not_bs
.4249	ad 08 02	lda $0208	            lda curs_x              ; Yes: move the cursor back
.424c	f0 07		beq $4255	            beq bs_leftmost         ; Is it already on column 0?
.424e	3a		dec a		            dec a                   ; No: move it back one
.424f	8d 08 02	sta $0208	            sta curs_x
.4252	20 2a 41	jsr $412a	            jsr cursset
.4255					bs_leftmost:
.4255	a9 20		lda #$20	            lda #' '                ; Clear the current character
.4257	ac 08 02	ldy $0208	            ldy curs_x              ; Get the index to the cursor
.425a	91 31		sta ($31),y	            sta (cur_line),y        ; Write the character to the screen
.425c	80 22		bra $4280	            bra done
.425e	85 2a		sta $2a		not_bs:     sta tmp                 ; Otherwise: save A in preparation for printing
.4260	a5 01		lda $01		            lda MMU_IO_CTRL         ; Save the current I/O page
.4262	48		pha		            pha
.4263	a9 02		lda #$02	            lda #MMU_IO_PAGE_TEXT   ; Move to the text page
.4265	85 01		sta $01		            sta MMU_IO_CTRL
.4267	a5 2a		lda $2a		            lda tmp                 ; Get A back
.4269	ac 08 02	ldy $0208	            ldy curs_x              ; Get the index to the cursor
.426c	91 31		sta ($31),y	            sta (cur_line),y        ; Write the character to the screen
.426e	a9 03		lda #$03	            lda #MMU_IO_PAGE_COLOR  ; Move to the color page
.4270	85 01		sta $01		            sta MMU_IO_CTRL
.4272	ad 07 02	lda $0207	            lda curs_color          ; Get the current color
.4275	91 31		sta ($31),y	            sta (cur_line),y        ; And set it on the screen
.4277	68		pla		            pla                     ; Restore the I/O page
.4278	85 01		sta $01		            sta MMU_IO_CTRL
.427a	ee 08 02	inc $0208	            inc curs_x              ; Move to the next column
.427d	20 2a 41	jsr $412a	            jsr cursset
.4280	7a		ply		done:       ply
.4281	60		rts		            rts
.4282					printah:
.4282	da		phx		            phx
.4283	48		pha		            pha
.4284	4a		lsr a		            lsr a
.4285	4a		lsr a		            lsr a
.4286	4a		lsr a		            lsr a
.4287	4a		lsr a		            lsr a
.4288	29 0f		and #$0f	            and #$0f
.428a	aa		tax		            tax                     ; Convert it to an index
.428b	bd a7 42	lda $42a7,x	            lda hex_digits,x        ; Lookup the hex digit for that nibble
.428e	20 2c 42	jsr $422c	            jsr conout              ; And print it
.4291	68		pla		            pla
.4292	29 0f		and #$0f	            and #$0f                ; Isolate the low nibble
.4294	aa		tax		            tax                     ; Convert it to an index
.4295	bd a7 42	lda $42a7,x	            lda hex_digits,x        ; Lookup the hex digit for that nibble
.4298	20 2c 42	jsr $422c	            jsr conout              ; And print it
.429b	fa		plx		            plx
.429c	60		rts		            rts
.429d					printyah:
.429d	48		pha		            pha
.429e	98		tya		            tya
.429f	20 82 42	jsr $4282	            jsr printah
.42a2	68		pla		            pla
.42a3	20 82 42	jsr $4282	            jsr printah
.42a6	60		rts		            rts
>42a7	30 31 32 33 34 35 36 37		hex_digits: .text "0123456789ABCDEF"
>42af	38 39 41 42 43 44 45 46
.42b7					prints:
.42b7	48		pha		            pha
.42b8	5a		phy		            phy
.42b9	a0 00		ldy #$00	            ldy #0
.42bb	b1 33		lda ($33),y	loop:       lda (src_ptr),y
.42bd	f0 06		beq $42c5	            beq done
.42bf	20 2c 42	jsr $422c	            jsr conout
.42c2	c8		iny		            iny
.42c3	d0 f6		bne $42bb	            bne loop
.42c5	7a		ply		done:       ply
.42c6	68		pla		            pla
.42c7	60		rts		            rts

;******  Return to file: mf_pre_65c02.asm


;******  Return to file: forth.asm

.42c8					w_exit:
>42c8	04					.byte $04
>42c9	65 78 69 74				.text 'exit'
>42cd	00 00 00 00 00 00 00 00			.fill 12,0
>42d5	00 00 00 00
>42d9	00 00					.word 0
.42db					xt_exit:
.42db	68		pla			pla             ; ip := pop()
.42dc	85 20		sta $20			sta ip
.42de	68		pla			pla
.42df	85 21		sta $21			sta ip+1
.42e1	4c 4a 40	jmp $404a		jmp next        ; jmp next
.42e4					w_enter:
>42e4	05					.byte $05
>42e5	65 6e 74 65 72				.text 'enter'
>42ea	00 00 00 00 00 00 00 00			.fill 11,0
>42f2	00 00 00
>42f5	c8 42					.word w_exit
.42f7					xt_enter:
.42f7	a5 21		lda $21			lda ip+1        ; push(ip)
.42f9	48		pha			pha
.42fa	a5 20		lda $20			lda ip
.42fc	48		pha			pha
.42fd	18		clc			clc             ; ip := wp + 3
.42fe	a5 22		lda $22			lda wp
.4300	69 03		adc #$03		adc #3
.4302	85 20		sta $20			sta ip
.4304	a5 23		lda $23			lda wp+1
.4306	69 00		adc #$00		adc #0
.4308	85 21		sta $21			sta ip+1
.430a	4c 4a 40	jmp $404a		jmp next
.430d					w_testname:
>430d	08					.byte $08
>430e	74 65 73 74 6e 61 6d 65			.text 'testname'
>4316	00 00 00 00 00 00 00 00			.fill 8,0
>431e	e4 42					.word w_enter
.4320					xt_testname:
.4320	b5 02		lda $02,x		lda pstack+2,x
.4322	85 28		sta $28			sta test
.4324	b5 03		lda $03,x		lda pstack+3,x
.4326	85 29		sta $29			sta test+1
.4328	e8		inx			inx
.4329	e8		inx			inx
.432a	4c 4a 40	jmp $404a		jmp next
.432d					w_assertx3d:
>432d	07					.byte $07
>432e	61 73 73 65 72 74 3d			.text 'assert='
>4335	00 00 00 00 00 00 00 00			.fill 9,0
>433d	00
>433e	0d 43					.word w_testname
.4340					xt_assertx3d:
.4340	b5 02		lda $02,x		lda pstack+2,x      ; Check to see if x1 and x2 are equal
.4342	d5 04		cmp $04,x		cmp pstack+4,x
.4344	d0 0e		bne $4354		bne fail            ; If not, fail
.4346	b5 03		lda $03,x		lda pstack+3,x
.4348	d5 05		cmp $05,x		cmp pstack+5,x
.434a	d0 08		bne $4354		bne fail
.434c	8a		txa			txa                 ; If so, clean up the stack
.434d	18		clc			clc
.434e	69 04		adc #$04		adc #4
.4350	aa		tax			tax
.4351	4c 4a 40	jmp $404a		jmp next            ; And continue
.4354						fail:
.4354	a9 91		lda #$91		lda #<leadin        ; Print the failure message
.4356	85 33		sta $33			sta src_ptr
.4358	a9 43		lda #$43		lda #>leadin
.435a	85 34		sta $34			sta src_ptr+1
.435c	20 b7 42	jsr $42b7		jsr prints
.435f	a5 28		lda $28			lda test            ; Print the name of the test
.4361	85 33		sta $33			sta src_ptr
.4363	a5 29		lda $29			lda test+1
.4365	85 34		sta $34			sta src_ptr+1
.4367	20 b7 42	jsr $42b7		jsr prints
.436a	a9 a4		lda #$a4		lda #<actual        ; Print the "Actual" label
.436c	85 33		sta $33			sta src_ptr
.436e	a9 43		lda #$43		lda #>actual
.4370	85 34		sta $34			sta src_ptr+1
.4372	20 b7 42	jsr $42b7		jsr prints
.4375	b4 05		ldy $05,x		ldy pstack+5,x      ; Print the actual value computed
.4377	b5 04		lda $04,x		lda pstack+4,x
.4379	20 9d 42	jsr $429d		jsr printyah
.437c	a9 98		lda #$98		lda #<expected      ; Print the "Expected" label
.437e	85 33		sta $33			sta src_ptr
.4380	a9 43		lda #$43		lda #>expected
.4382	85 34		sta $34			sta src_ptr+1
.4384	20 b7 42	jsr $42b7		jsr prints
.4387	b4 03		ldy $03,x		ldy pstack+3,x      ; Print the expected value
.4389	b5 02		lda $02,x		lda pstack+2,x
.438b	20 9d 42	jsr $429d		jsr printyah
.438e						lock:
.438e	ea		nop			nop                 ; Lock up
.438f	80 fd		bra $438e		bra lock
.4391						leadin:
>4391	46 41 49 4c 3a 20 00			.null "FAIL: "
.4398						expected:
>4398	20 45 58 50 45 43 54 45			.null " EXPECTED: "
>43a0	44 3a 20 00
.43a4						actual:
>43a4	20 41 43 54 55 41 4c 3a			.null " ACTUAL: "
>43ac	20 00
.43ae					w_halt:
>43ae	04					.byte $04
>43af	68 61 6c 74				.text 'halt'
>43b3	00 00 00 00 00 00 00 00			.fill 12,0
>43bb	00 00 00 00
>43bf	2d 43					.word w_assertx3d
.43c1					xt_halt:
.43c1	a9 25		lda #$25		lda #<registers         ; Print register banner
.43c3	85 33		sta $33			sta src_ptr
.43c5	a9 44		lda #$44		lda #>registers
.43c7	85 34		sta $34			sta src_ptr+1
.43c9	20 b7 42	jsr $42b7		jsr prints
.43cc	a4 21		ldy $21			ldy ip+1                ; Print the IP
.43ce	a5 20		lda $20			lda ip
.43d0	20 9d 42	jsr $429d		jsr printyah
.43d3	a9 20		lda #$20		lda #' '
.43d5	20 2c 42	jsr $422c		jsr conout
.43d8	a4 23		ldy $23			ldy wp+1                ; Print the WP
.43da	a5 22		lda $22			lda wp
.43dc	20 9d 42	jsr $429d		jsr printyah
.43df	a9 20		lda #$20		lda #' '
.43e1	20 2c 42	jsr $422c		jsr conout
.43e4	86 2e		stx $2e			stx savex               ; Print the return stack pointer
.43e6	a0 01		ldy #$01		ldy #$01
.43e8	ba		tsx			tsx
.43e9	8a		txa			txa
.43ea	20 9d 42	jsr $429d		jsr printyah
.43ed	a6 2e		ldx $2e			ldx savex
.43ef	a9 20		lda #$20		lda #' '
.43f1	20 2c 42	jsr $422c		jsr conout
.43f4	a0 00		ldy #$00		ldy #0                  ; Print the parameter stack pointer
.43f6	8a		txa			txa
.43f7	20 9d 42	jsr $429d		jsr printyah
.43fa	a9 0d		lda #$0d		lda #13
.43fc	20 2c 42	jsr $422c		jsr conout
.43ff	e0 6e		cpx #$6e		cpx #$6e                ; Check to see if there is anything on the parameter stack
.4401	b0 1f		bcs $4422		bge lock
.4403	a9 44		lda #$44		lda #>stackmsg          ; Yes: print the stack message and the stack contents
.4405	85 34		sta $34			sta src_ptr+1
.4407	a9 40		lda #$40		lda #<stackmsg
.4409	85 33		sta $33			sta src_ptr
.440b	20 b7 42	jsr $42b7		jsr prints
.440e						loop:
.440e	e0 6e		cpx #$6e		cpx #$6e
.4410	b0 10		bcs $4422		bge lock
.4412	b4 03		ldy $03,x		ldy pstack+3,x
.4414	b5 02		lda $02,x		lda pstack+2,x
.4416	e8		inx			inx
.4417	e8		inx			inx
.4418	20 9d 42	jsr $429d		jsr printyah
.441b	a9 20		lda #$20		lda #' '
.441d	20 2c 42	jsr $422c		jsr conout
.4420	80 ec		bra $440e		bra loop
.4422						lock:
.4422						wait:
.4422	ea		nop			nop
.4423	80 fd		bra $4422		bra wait
>4425	0d 0d 7c 20 20 20 49 50			registers:  .text 13,13,"|   IP   WP  RSP  PSP",13
>442d	20 20 20 57 50 20 20 52 53 50 20 20 50 53 50 0d
>443d	7c 20 00				.null "| "
>4440	0d 50 61 72 61 6d 65 74			stackmsg:   .null 13,"Parameter Stack:",13
>4448	65 72 20 53 74 61 63 6b 3a 0d 00
.4453					w_rpx40:
>4453	03					.byte $03
>4454	72 70 40				.text 'rp@'
>4457	00 00 00 00 00 00 00 00			.fill 13,0
>445f	00 00 00 00 00
>4464	ae 43					.word w_halt
.4466					xt_rpx40:
.4466	86 2e		stx $2e			stx savex           ; Save the parameter stack pointer
.4468	ba		tsx			tsx                 ; Get the return stack pointer
.4469	85 2a		sta $2a			sta tmp             ; Save it for later
.446b	a6 2e		ldx $2e			ldx savex           ; Recover the parameter stack pointer
.446d	a9 01		lda #$01		lda #$01            ; Get the high byte of the RSP
.446f	95 01		sta $01,x		sta pstack+1,x      ; Save it to the parameter stack
.4471	a5 2a		lda $2a			lda tmp             ; Get the low byte of the RSP
.4473	95 00		sta $00,x		sta pstack,x        ; Save it to the parameter stack
.4475	ca		dex			dex
.4476	ca		dex			dex
.4477	4c 4a 40	jmp $404a		jmp next
.447a					w_rpx21:
>447a	03					.byte $03
>447b	72 70 21				.text 'rp!'
>447e	00 00 00 00 00 00 00 00			.fill 13,0
>4486	00 00 00 00 00
>448b	53 44					.word w_rpx40
.448d					xt_rpx21:
.448d	86 2e		stx $2e			stx savex           ; Save the parameter stack pointer
.448f	b5 02		lda $02,x		lda pstack+2,x      ; Get the new RSP from the parameter stack
.4491	aa		tax			tax
.4492	9a		txs			txs                 ; Set the RSP
.4493	a6 2e		ldx $2e			ldx savex           ; Restore the parameter stack pointer
.4495	e8		inx			inx
.4496	e8		inx			inx
.4497	4c 4a 40	jmp $404a		jmp next
.449a					w_spx40:
>449a	03					.byte $03
>449b	73 70 40				.text 'sp@'
>449e	00 00 00 00 00 00 00 00			.fill 13,0
>44a6	00 00 00 00 00
>44ab	7a 44					.word w_rpx21
.44ad					xt_spx40:
.44ad	a9 00		lda #$00		lda #>pstack        ; Get the high byte of the stack address
.44af	95 01		sta $01,x		sta pstack+1,x      ; And push it to the stack
.44b1	8a		txa			txa                 ; Get the low byte of the stack address
.44b2	95 00		sta $00,x		sta pstack,x        ; And push it to the stack
.44b4	ca		dex			dex
.44b5	ca		dex			dex
.44b6	4c 4a 40	jmp $404a		jmp next
.44b9					w_spx21:
>44b9	03					.byte $03
>44ba	73 70 21				.text 'sp!'
>44bd	00 00 00 00 00 00 00 00			.fill 13,0
>44c5	00 00 00 00 00
>44ca	9a 44					.word w_spx40
.44cc					xt_spx21:
.44cc	b5 02		lda $02,x		lda pstack+2,x      ; Get the address from the stack
.44ce	aa		tax			tax                 ; And set the stack pointer
.44cf	4c 4a 40	jmp $404a		jmp next
.44d2					w_emit:
>44d2	04					.byte $04
>44d3	65 6d 69 74				.text 'emit'
>44d7	00 00 00 00 00 00 00 00			.fill 12,0
>44df	00 00 00 00
>44e3	b9 44					.word w_spx21
.44e5					xt_emit:
.44e5	b5 02		lda $02,x		lda pstack+2,x
.44e7	da		phx			phx
.44e8	20 2c 42	jsr $422c		jsr conout
.44eb	fa		plx			plx
.44ec	e8		inx			inx
.44ed	e8		inx			inx
.44ee	4c 4a 40	jmp $404a		jmp next
.44f1					w_keyx3f:
>44f1	04					.byte $04
>44f2	6b 65 79 3f				.text 'key?'
>44f6	00 00 00 00 00 00 00 00			.fill 12,0
>44fe	00 00 00 00
>4502	d2 44					.word w_emit
.4504					xt_keyx3f:
.4504	20 e6 40	jsr $40e6		jsr constat
.4507	29 01		and #$01		and #1
.4509	f0 06		beq $4511		beq waiting
.450b	74 00		stz $00,x		stz pstack,x
.450d	74 01		stz $01,x		stz pstack+1,x
.450f	80 06		bra $4517		bra done
.4511						waiting:
.4511	a9 ff		lda #$ff		lda #$ff
.4513	95 00		sta $00,x		sta pstack,x
.4515	95 01		sta $01,x		sta pstack+1,x
.4517						done:
.4517	ca		dex			dex
.4518	ca		dex			dex
.4519	4c 4a 40	jmp $404a		jmp next
.451c					w_key:
>451c	03					.byte $03
>451d	6b 65 79				.text 'key'
>4520	00 00 00 00 00 00 00 00			.fill 13,0
>4528	00 00 00 00 00
>452d	f1 44					.word w_keyx3f
.452f					xt_key:
.452f	da		phx			phx
.4530						wait:
.4530	20 e9 40	jsr $40e9		jsr conin
.4533	c9 00		cmp #$00		cmp #0
.4535	f0 f9		beq $4530		beq wait
.4537	fa		plx			plx
.4538	95 00		sta $00,x		sta pstack,x
.453a	74 01		stz $01,x		stz pstack+1,x
.453c	ca		dex			dex
.453d	ca		dex			dex
.453e	4c 4a 40	jmp $404a		jmp next
.4541					w_cr:
>4541	02					.byte $02
>4542	63 72					.text 'cr'
>4544	00 00 00 00 00 00 00 00			.fill 14,0
>454c	00 00 00 00 00 00
>4552	1c 45					.word w_key
.4554					xt_cr:
.4554	da		phx			phx
.4555	a9 0d		lda #$0d		lda #$0d
.4557	20 2c 42	jsr $422c		jsr conout
.455a	fa		plx			plx
.455b	4c 4a 40	jmp $404a		jmp next
.455e					w_0:
>455e	01					.byte $01
>455f	30					.text '0'
>4560	00 00 00 00 00 00 00 00			.fill 15,0
>4568	00 00 00 00 00 00 00
>456f	41 45					.word w_cr
.4571					xt_0:
.4571	74 01		stz $01,x		stz pstack+1,x
.4573	74 00		stz $00,x		stz pstack,x
.4575	ca		dex			dex
.4576	ca		dex			dex
.4577	4c 4a 40	jmp $404a		jmp next
.457a					w_1:
>457a	01					.byte $01
>457b	31					.text '1'
>457c	00 00 00 00 00 00 00 00			.fill 15,0
>4584	00 00 00 00 00 00 00
>458b	5e 45					.word w_0
.458d					xt_1:
.458d	74 01		stz $01,x		stz pstack+1,x
.458f	a9 01		lda #$01		lda #1
.4591	95 00		sta $00,x		sta pstack,x
.4593	ca		dex			dex
.4594	ca		dex			dex
.4595	4c 4a 40	jmp $404a		jmp next
.4598					w_2:
>4598	01					.byte $01
>4599	32					.text '2'
>459a	00 00 00 00 00 00 00 00			.fill 15,0
>45a2	00 00 00 00 00 00 00
>45a9	7a 45					.word w_1
.45ab					xt_2:
.45ab	74 01		stz $01,x		stz pstack+1,x
.45ad	a9 02		lda #$02		lda #2
.45af	95 00		sta $00,x		sta pstack,x
.45b1	ca		dex			dex
.45b2	ca		dex			dex
.45b3	4c 4a 40	jmp $404a		jmp next
.45b6					w_x2d1:
>45b6	02					.byte $02
>45b7	2d 31					.text '-1'
>45b9	00 00 00 00 00 00 00 00			.fill 14,0
>45c1	00 00 00 00 00 00
>45c7	98 45					.word w_2
.45c9					xt_x2d1:
.45c9	a9 ff		lda #$ff		lda #$ff
.45cb	95 01		sta $01,x		sta pstack+1,x
.45cd	95 00		sta $00,x		sta pstack,x
.45cf	ca		dex			dex
.45d0	ca		dex			dex
.45d1	4c 4a 40	jmp $404a		jmp next
.45d4					w_x2d2:
>45d4	02					.byte $02
>45d5	2d 32					.text '-2'
>45d7	00 00 00 00 00 00 00 00			.fill 14,0
>45df	00 00 00 00 00 00
>45e5	b6 45					.word w_x2d1
.45e7					xt_x2d2:
.45e7	a9 fe		lda #$fe		lda #$fe
.45e9	95 01		sta $01,x		sta pstack+1,x
.45eb	95 00		sta $00,x		sta pstack,x
.45ed	ca		dex			dex
.45ee	ca		dex			dex
.45ef	4c 4a 40	jmp $404a		jmp next
.45f2					w_x28literalx29:
>45f2	09					.byte $09
>45f3	28 6c 69 74 65 72 61 6c			.text '(literal)'
>45fb	29
>45fc	00 00 00 00 00 00 00			.fill 7,0
>4603	d4 45					.word w_x2d2
.4605					xt_x28literalx29:
.4605	a0 01		ldy #$01		ldy #1
.4607	b2 20		lda ($20)		lda (ip)
.4609	95 00		sta $00,x		sta pstack,x
.460b	b1 20		lda ($20),y		lda (ip),y
.460d	95 01		sta $01,x		sta pstack+1,x
.460f	ca		dex			dex
.4610	ca		dex			dex
.4611	18		clc			clc
.4612	a5 20		lda $20			lda ip
.4614	69 02		adc #$02		adc #2
.4616	85 20		sta $20			sta ip
.4618	a5 21		lda $21			lda ip+1
.461a	69 00		adc #$00		adc #0
.461c	85 21		sta $21			sta ip+1
.461e	4c 4a 40	jmp $404a		jmp next
.4621					w_x28dliteralx29:
>4621	0a					.byte $0A
>4622	28 64 6c 69 74 65 72 61			.text '(dliteral)'
>462a	6c 29
>462c	00 00 00 00 00 00			.fill 6,0
>4632	f2 45					.word w_x28literalx29
.4634					xt_x28dliteralx29:
.4634	a0 01		ldy #$01		ldy #1
.4636	b2 20		lda ($20)		lda (ip)
.4638	95 00		sta $00,x		sta pstack,x
.463a	b1 20		lda ($20),y		lda (ip),y
.463c	95 01		sta $01,x		sta pstack+1,x
.463e	c8		iny			iny
.463f	95 02		sta $02,x		sta pstack+2,x
.4641	c8		iny			iny
.4642	95 03		sta $03,x		sta pstack+3,x
.4644	ca		dex			dex
.4645	ca		dex			dex
.4646	ca		dex			dex
.4647	ca		dex			dex
.4648	18		clc			clc
.4649	a5 20		lda $20			lda ip
.464b	69 02		adc #$02		adc #2
.464d	85 20		sta $20			sta ip
.464f	a5 21		lda $21			lda ip+1
.4651	69 00		adc #$00		adc #0
.4653	85 21		sta $21			sta ip+1
.4655	4c 4a 40	jmp $404a		jmp next
.4658					w_depth:
>4658	05					.byte $05
>4659	64 65 70 74 68				.text 'depth'
>465e	00 00 00 00 00 00 00 00			.fill 11,0
>4666	00 00 00
>4669	21 46					.word w_x28dliteralx29
.466b					xt_depth:
.466b	86 2a		stx $2a			stx tmp
.466d	38		sec			sec
.466e	a9 6e		lda #$6e		lda #$6e
.4670	e5 2a		sbc $2a			sbc tmp
.4672	4a		lsr a			lsr a
.4673	74 01		stz $01,x		stz pstack+1,x
.4675	95 00		sta $00,x		sta pstack,x
.4677	ca		dex			dex
.4678	ca		dex			dex
.4679	4c 4a 40	jmp $404a		jmp next
.467c					w_drop:
>467c	04					.byte $04
>467d	64 72 6f 70				.text 'drop'
>4681	00 00 00 00 00 00 00 00			.fill 12,0
>4689	00 00 00 00
>468d	58 46					.word w_depth
.468f					xt_drop:
.468f	e8		inx			inx
.4690	e8		inx			inx
.4691	4c 4a 40	jmp $404a		jmp next
.4694					w_dup:
>4694	03					.byte $03
>4695	64 75 70				.text 'dup'
>4698	00 00 00 00 00 00 00 00			.fill 13,0
>46a0	00 00 00 00 00
>46a5	7c 46					.word w_drop
.46a7					xt_dup:
.46a7	b5 02		lda $02,x		lda pstack+2,x
.46a9	95 00		sta $00,x		sta pstack,x
.46ab	b5 03		lda $03,x		lda pstack+3,x
.46ad	95 01		sta $01,x		sta pstack+1,x
.46af	ca		dex			dex
.46b0	ca		dex			dex
.46b1	4c 4a 40	jmp $404a		jmp next
.46b4					w_swap:
>46b4	04					.byte $04
>46b5	73 77 61 70				.text 'swap'
>46b9	00 00 00 00 00 00 00 00			.fill 12,0
>46c1	00 00 00 00
>46c5	94 46					.word w_dup
.46c7					xt_swap:
.46c7	b5 02		lda $02,x		lda pstack+2,x
.46c9	b4 04		ldy $04,x		ldy pstack+4,x
.46cb	94 02		sty $02,x		sty pstack+2,x
.46cd	95 04		sta $04,x		sta pstack+4,x
.46cf	b5 03		lda $03,x		lda pstack+3,x
.46d1	b4 05		ldy $05,x		ldy pstack+5,x
.46d3	94 03		sty $03,x		sty pstack+3,x
.46d5	95 05		sta $05,x		sta pstack+5,x
.46d7	4c 4a 40	jmp $404a		jmp next
.46da					w_2swap:
>46da	05					.byte $05
>46db	32 73 77 61 70				.text '2swap'
>46e0	00 00 00 00 00 00 00 00			.fill 11,0
>46e8	00 00 00
>46eb	b4 46					.word w_swap
.46ed					xt_2swap:
.46ed	b5 05		lda $05,x		lda pstack+5,x
.46ef	48		pha			pha
.46f0	b5 04		lda $04,x		lda pstack+4,x
.46f2	48		pha			pha
.46f3	b5 03		lda $03,x		lda pstack+3,x
.46f5	48		pha			pha
.46f6	b5 02		lda $02,x		lda pstack+2,x
.46f8	48		pha			pha
.46f9	b5 09		lda $09,x		lda pstack+9,x
.46fb	95 05		sta $05,x		sta pstack+5,x
.46fd	b5 08		lda $08,x		lda pstack+8,x
.46ff	95 04		sta $04,x		sta pstack+4,x
.4701	b5 07		lda $07,x		lda pstack+7,x
.4703	95 03		sta $03,x		sta pstack+3,x
.4705	b5 06		lda $06,x		lda pstack+6,x
.4707	95 02		sta $02,x		sta pstack+2,x
.4709	68		pla			pla
.470a	95 06		sta $06,x		sta pstack+6,x
.470c	68		pla			pla
.470d	95 07		sta $07,x		sta pstack+7,x
.470f	68		pla			pla
.4710	95 08		sta $08,x		sta pstack+8,x
.4712	68		pla			pla
.4713	95 09		sta $09,x		sta pstack+9,x
.4715	4c 4a 40	jmp $404a		jmp next
.4718					w_over:
>4718	04					.byte $04
>4719	6f 76 65 72				.text 'over'
>471d	00 00 00 00 00 00 00 00			.fill 12,0
>4725	00 00 00 00
>4729	da 46					.word w_2swap
.472b					xt_over:
.472b	b5 04		lda $04,x		lda pstack+4,x
.472d	95 00		sta $00,x		sta pstack,x
.472f	b5 05		lda $05,x		lda pstack+5,x
.4731	95 01		sta $01,x		sta pstack+1,x
.4733	ca		dex			dex
.4734	ca		dex			dex
.4735	4c 4a 40	jmp $404a		jmp next
.4738					w_2over:
>4738	05					.byte $05
>4739	32 6f 76 65 72				.text '2over'
>473e	00 00 00 00 00 00 00 00			.fill 11,0
>4746	00 00 00
>4749	18 47					.word w_over
.474b					xt_2over:
.474b	ca		dex			dex
.474c	ca		dex			dex
.474d	ca		dex			dex
.474e	ca		dex			dex
.474f	b5 0d		lda $0d,x		lda pstack+13,x
.4751	95 05		sta $05,x		sta pstack+5,x
.4753	b5 0c		lda $0c,x		lda pstack+12,x
.4755	95 04		sta $04,x		sta pstack+4,x
.4757	b5 0b		lda $0b,x		lda pstack+11,x
.4759	95 03		sta $03,x		sta pstack+3,x
.475b	b5 0a		lda $0a,x		lda pstack+10,x
.475d	95 02		sta $02,x		sta pstack+2,x
.475f	4c 4a 40	jmp $404a		jmp next
.4762					w_x3er:
>4762	02					.byte $02
>4763	3e 72					.text '>r'
>4765	00 00 00 00 00 00 00 00			.fill 14,0
>476d	00 00 00 00 00 00
>4773	38 47					.word w_2over
.4775					xt_x3er:
.4775	b5 03		lda $03,x		lda pstack+3,x
.4777	48		pha			pha
.4778	b5 02		lda $02,x		lda pstack+2,x
.477a	48		pha			pha
.477b	e8		inx			inx
.477c	e8		inx			inx
.477d	4c 4a 40	jmp $404a		jmp next
.4780					w_rx3e:
>4780	02					.byte $02
>4781	72 3e					.text 'r>'
>4783	00 00 00 00 00 00 00 00			.fill 14,0
>478b	00 00 00 00 00 00
>4791	62 47					.word w_x3er
.4793					xt_rx3e:
.4793	68		pla			pla
.4794	95 00		sta $00,x		sta pstack,x
.4796	68		pla			pla
.4797	95 01		sta $01,x		sta pstack+1,x
.4799	ca		dex			dex
.479a	ca		dex			dex
.479b	4c 4a 40	jmp $404a		jmp next
.479e					w_r:
>479e	01					.byte $01
>479f	72					.text 'r'
>47a0	00 00 00 00 00 00 00 00			.fill 15,0
>47a8	00 00 00 00 00 00 00
>47af	80 47					.word w_rx3e
.47b1					xt_r:
.47b1	68		pla			pla
.47b2	95 00		sta $00,x		sta pstack,x
.47b4	68		pla			pla
.47b5	95 01		sta $01,x		sta pstack+1,x
.47b7	48		pha			pha
.47b8	b5 00		lda $00,x		lda pstack,x
.47ba	48		pha			pha
.47bb	ca		dex			dex
.47bc	ca		dex			dex
.47bd	4c 4a 40	jmp $404a		jmp next
.47c0					w_rdrop:
>47c0	05					.byte $05
>47c1	72 64 72 6f 70				.text 'rdrop'
>47c6	00 00 00 00 00 00 00 00			.fill 11,0
>47ce	00 00 00
>47d1	9e 47					.word w_r
.47d3					xt_rdrop:
.47d3	68		pla			pla
.47d4	68		pla			pla
.47d5					w_x21:
>47d5	01					.byte $01
>47d6	21					.text '!'
>47d7	00 00 00 00 00 00 00 00			.fill 15,0
>47df	00 00 00 00 00 00 00
>47e6	c0 47					.word w_rdrop
.47e8					xt_x21:
.47e8	b5 02		lda $02,x		lda pstack+2,x
.47ea	85 2a		sta $2a			sta tmp
.47ec	b5 03		lda $03,x		lda pstack+3,x
.47ee	85 2b		sta $2b			sta tmp+1
.47f0	a0 01		ldy #$01		ldy #1
.47f2	b5 04		lda $04,x		lda pstack+4,x
.47f4	92 2a		sta ($2a)		sta (tmp)
.47f6	b5 05		lda $05,x		lda pstack+5,x
.47f8	91 2a		sta ($2a),y		sta (tmp),y
.47fa	e8		inx			inx
.47fb	e8		inx			inx
.47fc	e8		inx			inx
.47fd	e8		inx			inx
.47fe	4c 4a 40	jmp $404a		jmp next
.4801					w_x40:
>4801	01					.byte $01
>4802	40					.text '@'
>4803	00 00 00 00 00 00 00 00			.fill 15,0
>480b	00 00 00 00 00 00 00
>4812	d5 47					.word w_x21
.4814					xt_x40:
.4814	b5 02		lda $02,x		lda pstack+2,x
.4816	85 2a		sta $2a			sta tmp
.4818	b5 03		lda $03,x		lda pstack+3,x
.481a	85 2b		sta $2b			sta tmp+1
.481c	a0 01		ldy #$01		ldy #1
.481e	b2 2a		lda ($2a)		lda (tmp)
.4820	95 02		sta $02,x		sta pstack+2,x
.4822	b1 2a		lda ($2a),y		lda (tmp),y
.4824	95 03		sta $03,x		sta pstack+3,x
.4826	4c 4a 40	jmp $404a		jmp next
.4829					w_cx21:
>4829	02					.byte $02
>482a	63 21					.text 'c!'
>482c	00 00 00 00 00 00 00 00			.fill 14,0
>4834	00 00 00 00 00 00
>483a	01 48					.word w_x40
.483c					xt_cx21:
.483c	b5 04		lda $04,x		lda pstack+4,x
.483e	81 02		sta ($02,x)		sta (pstack+2,x)
.4840	e8		inx			inx
.4841	e8		inx			inx
.4842	e8		inx			inx
.4843	e8		inx			inx
.4844	4c 4a 40	jmp $404a		jmp next
.4847					w_cx40:
>4847	02					.byte $02
>4848	63 40					.text 'c@'
>484a	00 00 00 00 00 00 00 00			.fill 14,0
>4852	00 00 00 00 00 00
>4858	29 48					.word w_cx21
.485a					xt_cx40:
.485a	a1 02		lda ($02,x)		lda (pstack+2,x)
.485c	95 02		sta $02,x		sta pstack+2,x
.485e	74 03		stz $03,x		stz pstack+3,x
.4860	4c 4a 40	jmp $404a		jmp next
.4863					w_fill:
>4863	04					.byte $04
>4864	66 69 6c 6c				.text 'fill'
>4868	00 00 00 00 00 00 00 00			.fill 12,0
>4870	00 00 00 00
>4874	47 48					.word w_cx40
.4876					xt_fill:
.4876						loop:
.4876	b5 03		lda $03,x		lda pstack+3,x          ; Check to see if the count is 0
.4878	d0 04		bne $487e		bne do_write
.487a	b5 04		lda $04,x		lda pstack+4,x
.487c	f0 19		beq $4897		beq done                ; Yes: we're done...
.487e						do_write:
.487e	b5 01		lda $01,x		lda pstack+1,x          ; No:; get the byte to use for the fill
.4880	81 05		sta ($05,x)		sta (pstack+5,x)        ; And store it in the indicated location
.4882	f6 05		inc $05,x		inc pstack+5,x          ; Increment the address
.4884	d0 02		bne $4888		bne deccount
.4886	f6 06		inc $06,x		inc pstack+6,x
.4888						deccount:
.4888	38		sec			sec                     ; Decrement the count
.4889	b5 03		lda $03,x		lda pstack+3,x
.488b	e9 01		sbc #$01		sbc #1
.488d	95 03		sta $03,x		sta pstack+3,x
.488f	b5 04		lda $04,x		lda pstack+4,x
.4891	e9 00		sbc #$00		sbc #0
.4893	95 04		sta $04,x		sta pstack+4,x
.4895	80 df		bra $4876		bra loop                ; And check again
.4897						done:
.4897	8a		txa			txa                     ; Clean up the parameter stack
.4898	69 06		adc #$06		adc #6
.489a	aa		tax			tax
.489b	4c 4a 40	jmp $404a		jmp next
.489e					w_x2bx21:
>489e	02					.byte $02
>489f	2b 21					.text '+!'
>48a1	00 00 00 00 00 00 00 00			.fill 14,0
>48a9	00 00 00 00 00 00
>48af	63 48					.word w_fill
.48b1					xt_x2bx21:
.48b1	b5 03		lda $03,x		lda pstack+3,x
.48b3	85 2b		sta $2b			sta tmp+1
.48b5	b5 02		lda $02,x		lda pstack+2,x
.48b7	85 2a		sta $2a			sta tmp
.48b9	18		clc			clc
.48ba	a0 01		ldy #$01		ldy #1
.48bc	b2 2a		lda ($2a)		lda (tmp)
.48be	75 04		adc $04,x		adc pstack+4,x
.48c0	92 2a		sta ($2a)		sta (tmp)
.48c2	b1 2a		lda ($2a),y		lda (tmp),y
.48c4	75 05		adc $05,x		adc pstack+5,x
.48c6	91 2a		sta ($2a),y		sta (tmp),y
.48c8						done:
.48c8	e8		inx			inx                     ; Clean up the stack
.48c9	e8		inx			inx
.48ca	e8		inx			inx
.48cb	e8		inx			inx
.48cc	4c 4a 40	jmp $404a		jmp next
.48cf					w_enclose:
>48cf	07					.byte $07
>48d0	65 6e 63 6c 6f 73 65			.text 'enclose'
>48d7	00 00 00 00 00 00 00 00			.fill 9,0
>48df	00
>48e0	9e 48					.word w_x2bx21
.48e2					xt_enclose:
.48e2	b5 05		lda $05,x		lda pstack+5,x          ; Copy the address
.48e4	85 34		sta $34			sta src_ptr+1
.48e6	b5 04		lda $04,x		lda pstack+4,x
.48e8	85 33		sta $33			sta src_ptr
.48ea	b5 02		lda $02,x		lda pstack+2,x          ; tmp := c
.48ec	85 2a		sta $2a			sta tmp
.48ee	8a		txa			txa
.48ef	38		sec			sec
.48f0	e9 04		sbc #$04		sbc #4
.48f2	aa		tax			tax
.48f3	74 07		stz $07,x		stz pstack+7,x          ; n1 ... offset to first character
.48f5	74 06		stz $06,x		stz pstack+6,x
.48f7	74 05		stz $05,x		stz pstack+5,x          ; n2 ... offset to first delimiter
.48f9	74 04		stz $04,x		stz pstack+4,x
.48fb	74 03		stz $03,x		stz pstack+3,x          ; n3 ... n2 + 1 or n2
.48fd	74 02		stz $02,x		stz pstack+2,x
.48ff	a0 00		ldy #$00		ldy #0
.4901						loop1:
.4901	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character
.4903	d0 03		bne $4908		bne chk_delim1          ; NUL? No:; check it against the delimiter
.4905						none:
.4905	4c 4a 40	jmp $404a		jmp next                ; Yes: we want to return 0s
.4908						chk_delim1:
.4908	c5 2a		cmp $2a			cmp tmp                 ; Is it the delimiter?
.490a	f0 13		beq $491f		beq skip2               ; Yes: skip the character
.490c	a5 2a		lda $2a			lda tmp                 ; Check the delimiter
.490e	c9 20		cmp #$20		cmp #' '                ; Is it BL?
.4910	d0 0b		bne $491d		bne found               ; No: ok, we've found the first character;
.4912	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character back
.4914	c9 09		cmp #$09		cmp #CHAR_TAB           ; Is it a TAB?
.4916	d0 05		bne $491d		bne found               ; No: we found the first character
.4918	c8		iny			iny                     ; Move to the next character
.4919	f0 ea		beq $4905		beq none                ; If we've rolled over, we found nothing
.491b	80 e4		bra $4901		bra loop1               ; Otherwise: check the next character
.491d						found:
.491d	94 06		sty $06,x		sty pstack+6,x          ; Save the offset to it in n1
.491f						skip2:
.491f	c8		iny			iny                     ; Go to the next character
.4920	f0 1c		beq $493e		beq found_nul           ; If it rolls over, we've reached the end (NUL)
.4922						loop2:
.4922	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character
.4924	f0 18		beq $493e		beq found_nul           ; If it is NUL, we've reached the end (NUL)
.4926	c5 2a		cmp $2a			cmp tmp                 ; Check it against the delimiter
.4928	f0 0c		beq $4936		beq found_delim         ; If it's the delimiter, we've reached the end (with delimiter)
.492a	a5 2a		lda $2a			lda tmp                 ; Get the delimiter
.492c	c9 20		cmp #$20		cmp #' '                ; Is it space?
.492e	d0 ef		bne $491f		bne skip2               ; No: go to the next character
.4930	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character again
.4932	c9 09		cmp #$09		cmp #CHAR_TAB           ; Is it a tab?
.4934	d0 e9		bne $491f		bne skip2               ; No: go to the next character
.4936						found_delim:
.4936	94 04		sty $04,x		sty pstack+4,x          ; Save the offset of the delimiter in n2
.4938	c8		iny			iny
.4939	94 02		sty $02,x		sty pstack+2,x          ; And the offset +1 to n3
.493b	4c 4a 40	jmp $404a		jmp next                ; And we're done
.493e						found_nul:
.493e	94 04		sty $04,x		sty pstack+4,x          ; Save the offset of the delimiter in n2
.4940	94 02		sty $02,x		sty pstack+2,x          ; And to n3
.4942	4c 4a 40	jmp $404a		jmp next                ; And we're done
.4945					w_cmove:
>4945	05					.byte $05
>4946	63 6d 6f 76 65				.text 'cmove'
>494b	00 00 00 00 00 00 00 00			.fill 11,0
>4953	00 00 00
>4956	cf 48					.word w_enclose
.4958					xt_cmove:
.4958	b5 03		lda $03,x		lda pstack+3,x          ; Pull count off the stack
.495a	85 2b		sta $2b			sta tmp+1
.495c	b5 02		lda $02,x		lda pstack+2,x
.495e	85 2a		sta $2a			sta tmp
.4960	b5 05		lda $05,x		lda pstack+5,x          ; Pull the dst_ptr
.4962	85 36		sta $36			sta dst_ptr+1
.4964	b5 04		lda $04,x		lda pstack+4,x
.4966	85 35		sta $35			sta dst_ptr
.4968	b5 07		lda $07,x		lda pstack+7,x          ; Pull the src_ptr
.496a	85 34		sta $34			sta src_ptr+1
.496c	b5 06		lda $06,x		lda pstack+6,x
.496e	85 33		sta $33			sta src_ptr
.4970	8a		txa			txa                     ; Clean up the stack
.4971	18		clc			clc
.4972	69 06		adc #$06		adc #6
.4974	85 2e		sta $2e			sta savex               ; And save it for later restoration
.4976	a2 00		ldx #$00		ldx #0                  ; We'll use X for the high byte of the count
.4978	a0 00		ldy #$00		ldy #0                  ; and Y for the low byte of the count
.497a						loop:
.497a	e4 2b		cpx $2b			cpx tmp+1               ; is tmp == X:Y?
.497c	d0 04		bne $4982		bne copy
.497e	c4 2a		cpy $2a			cpy tmp
.4980	f0 0e		beq $4990		beq done                ; Yes: we're done
.4982						copy:
.4982	b1 33		lda ($33),y		lda (src_ptr),y         ; Copy the byte
.4984	91 35		sta ($35),y		sta (dst_ptr),y
.4986	c8		iny			iny                     ; Move to the next byte
.4987	d0 f1		bne $497a		bne loop                ; Repeat for 256 bytes
.4989	e8		inx			inx                     ; Move to the next block of 256
.498a	e6 34		inc $34			inc src_ptr+1
.498c	e6 36		inc $36			inc dst_ptr+1
.498e	80 ea		bra $497a		bra loop                ; And continue the loop
.4990						done:
.4990	a6 2e		ldx $2e			ldx savex
.4992	4c 4a 40	jmp $404a		jmp next
.4995					w_move:
>4995	04					.byte $04
>4996	6d 6f 76 65				.text 'move'
>499a	00 00 00 00 00 00 00 00			.fill 12,0
>49a2	00 00 00 00
>49a6	45 49					.word w_cmove
.49a8					xt_move:
.49a8	38		sec			sec                     ; Compare addr1 and addr2
.49a9	b5 06		lda $06,x		lda pstack+6,x
.49ab	f5 04		sbc $04,x		sbc pstack+4,x
.49ad	85 2a		sta $2a			sta tmp
.49af	b5 07		lda $07,x		lda pstack+7,x
.49b1	f5 05		sbc $05,x		sbc pstack+5,x
.49b3	85 2b		sta $2b			sta tmp+1
.49b5	30 24		bmi $49db		bmi a1less
.49b7	f0 72		beq $4a2b		beq chklo
.49b9						a1greater:
.49b9	b5 02		lda $02,x		lda pstack+2,x          ; Is u = 0?
.49bb	d0 50		bne $4a0d		bne docopy1
.49bd	b5 03		lda $03,x		lda pstack+3,x
.49bf	f0 72		beq $4a33		beq done                ; Yes: we're done;
.49c1	a1 06		lda ($06,x)		lda (pstack+6,x)        ; Get the source byte
.49c3	81 04		sta ($04,x)		sta (pstack+4,x)        ; Write it to the destination
.49c5	f6 06		inc $06,x		inc pstack+6,x          ; addr1 := addr1 + 1
.49c7	d0 02		bne $49cb		bne inc2
.49c9	f6 07		inc $07,x		inc pstack+7,x
.49cb						inc2:
.49cb	f6 04		inc $04,x		inc pstack+4,x          ; addr2 := addr2 + 1
.49cd	d0 02		bne $49d1		bne dec_count
.49cf	f6 03		inc $03,x		inc pstack+3,x
.49d1						dec_count:
.49d1	b5 02		lda $02,x		lda pstack+2,x          ; Decrement counter
.49d3	d0 02		bne $49d7		bne l1
.49d5	d6 03		dec $03,x		dec pstack+3,x
.49d7						l1:
.49d7	d6 02		dec $02,x		dec pstack+2,x
.49d9	80 de		bra $49b9		bra a1greater
.49db						a1less:
.49db	b5 04		lda $04,x		lda pstack+4,x          ; Decrement addr2
.49dd	d0 02		bne $49e1		bne l2
.49df	d6 05		dec $05,x		dec pstack+5,x
.49e1						l2:
.49e1	d6 04		dec $04,x		dec pstack+4,x
.49e3	18		clc			clc                     ; addr2 := addr2 + u
.49e4	b5 04		lda $04,x		lda pstack+4,x
.49e6	75 02		adc $02,x		adc pstack+2,x
.49e8	95 04		sta $04,x		sta pstack+4,x
.49ea	b5 05		lda $05,x		lda pstack+5,x
.49ec	75 03		adc $03,x		adc pstack+3,x
.49ee	95 05		sta $05,x		sta pstack+5,x
.49f0	b5 06		lda $06,x		lda pstack+6,x          ; Decrement addr1
.49f2	d0 02		bne $49f6		bne l3
.49f4	d6 07		dec $07,x		dec pstack+7,x
.49f6						l3:
.49f6	d6 06		dec $06,x		dec pstack+6,x
.49f8	18		clc			clc                     ; addr1 := addr1 + u
.49f9	b5 06		lda $06,x		lda pstack+6,x
.49fb	75 02		adc $02,x		adc pstack+2,x
.49fd	95 06		sta $06,x		sta pstack+6,x
.49ff	b5 07		lda $07,x		lda pstack+7,x
.4a01	75 03		adc $03,x		adc pstack+3,x
.4a03	95 07		sta $07,x		sta pstack+7,x
.4a05						loop2:
.4a05	b5 02		lda $02,x		lda pstack+2,x          ; Is u = 0?
.4a07	d0 04		bne $4a0d		bne docopy1
.4a09	b5 03		lda $03,x		lda pstack+3,x
.4a0b	f0 26		beq $4a33		beq done                ; Yes: we're done;
.4a0d						docopy1:
.4a0d	a1 06		lda ($06,x)		lda (pstack+6,x)        ; Get the source byte
.4a0f	81 04		sta ($04,x)		sta (pstack+4,x)        ; Write it to the destination
.4a11	b5 06		lda $06,x		lda pstack+6,x          ; Decrement addr1
.4a13	d0 02		bne $4a17		bne l4
.4a15	d6 07		dec $07,x		dec pstack+7,x
.4a17						l4:
.4a17	d6 06		dec $06,x		dec pstack+6,x
.4a19	b5 04		lda $04,x		lda pstack+4,x          ; Decrement addr2
.4a1b	d0 02		bne $4a1f		bne l5
.4a1d	d6 05		dec $05,x		dec pstack+5,x
.4a1f						l5:
.4a1f	d6 04		dec $04,x		dec pstack+4,x
.4a21	b5 02		lda $02,x		lda pstack+2,x          ; Decrement counter
.4a23	d0 02		bne $4a27		bne l6
.4a25	d6 03		dec $03,x		dec pstack+3,x
.4a27						l6:
.4a27	d6 02		dec $02,x		dec pstack+2,x
.4a29	80 da		bra $4a05		bra loop2
.4a2b						chklo:
.4a2b	a5 2a		lda $2a			lda tmp                 ; High bytes are equal: check the low byte
.4a2d	30 ac		bmi $49db		bmi a1less
.4a2f	f0 02		beq $4a33		beq done                ; If equal, we don't need to move the data
.4a31	80 86		bra $49b9		bra a1greater
.4a33						done:
.4a33	8a		txa			txa
.4a34	18		clc			clc
.4a35	69 06		adc #$06		adc #6
.4a37	aa		tax			tax
.4a38	60		rts			rts
.4a39					w_x2b:
>4a39	01					.byte $01
>4a3a	2b					.text '+'
>4a3b	00 00 00 00 00 00 00 00			.fill 15,0
>4a43	00 00 00 00 00 00 00
>4a4a	95 49					.word w_move
.4a4c					xt_x2b:
.4a4c	18		clc			clc
.4a4d	b5 04		lda $04,x		lda pstack+4,x
.4a4f	75 02		adc $02,x		adc pstack+2,x
.4a51	95 04		sta $04,x		sta pstack+4,x
.4a53	b5 05		lda $05,x		lda pstack+5,x
.4a55	75 03		adc $03,x		adc pstack+3,x
.4a57	95 05		sta $05,x		sta pstack+5,x
.4a59	e8		inx			inx
.4a5a	e8		inx			inx
.4a5b	4c 4a 40	jmp $404a		jmp next
.4a5e					w_dx2b:
>4a5e	02					.byte $02
>4a5f	64 2b					.text 'd+'
>4a61	00 00 00 00 00 00 00 00			.fill 14,0
>4a69	00 00 00 00 00 00
>4a6f	39 4a					.word w_x2b
.4a71					xt_dx2b:
.4a71	18		clc			clc
.4a72	b5 06		lda $06,x		lda pstack+6,x
.4a74	75 02		adc $02,x		adc pstack+2,x
.4a76	95 06		sta $06,x		sta pstack+6,x
.4a78	b5 07		lda $07,x		lda pstack+7,x
.4a7a	75 03		adc $03,x		adc pstack+3,x
.4a7c	95 07		sta $07,x		sta pstack+7,x
.4a7e	b5 08		lda $08,x		lda pstack+8,x
.4a80	75 04		adc $04,x		adc pstack+4,x
.4a82	95 08		sta $08,x		sta pstack+8,x
.4a84	b5 09		lda $09,x		lda pstack+9,x
.4a86	75 05		adc $05,x		adc pstack+5,x
.4a88	95 09		sta $09,x		sta pstack+9,x
.4a8a	e8		inx			inx
.4a8b	e8		inx			inx
.4a8c	e8		inx			inx
.4a8d	e8		inx			inx
.4a8e	4c 4a 40	jmp $404a		jmp next
.4a91					w_dx2d:
>4a91	02					.byte $02
>4a92	64 2d					.text 'd-'
>4a94	00 00 00 00 00 00 00 00			.fill 14,0
>4a9c	00 00 00 00 00 00
>4aa2	5e 4a					.word w_dx2b
.4aa4					xt_dx2d:
.4aa4	38		sec			sec
.4aa5	b5 06		lda $06,x		lda pstack+6,x
.4aa7	f5 02		sbc $02,x		sbc pstack+2,x
.4aa9	95 06		sta $06,x		sta pstack+6,x
.4aab	b5 07		lda $07,x		lda pstack+7,x
.4aad	f5 03		sbc $03,x		sbc pstack+3,x
.4aaf	95 07		sta $07,x		sta pstack+7,x
.4ab1	b5 08		lda $08,x		lda pstack+8,x
.4ab3	f5 04		sbc $04,x		sbc pstack+4,x
.4ab5	95 08		sta $08,x		sta pstack+8,x
.4ab7	b5 09		lda $09,x		lda pstack+9,x
.4ab9	f5 05		sbc $05,x		sbc pstack+5,x
.4abb	95 09		sta $09,x		sta pstack+9,x
.4abd	e8		inx			inx
.4abe	e8		inx			inx
.4abf	e8		inx			inx
.4ac0	e8		inx			inx
.4ac1	4c 4a 40	jmp $404a		jmp next
.4ac4					w_x2d:
>4ac4	01					.byte $01
>4ac5	2d					.text '-'
>4ac6	00 00 00 00 00 00 00 00			.fill 15,0
>4ace	00 00 00 00 00 00 00
>4ad5	91 4a					.word w_dx2d
.4ad7					xt_x2d:
.4ad7	38		sec			sec
.4ad8	b5 04		lda $04,x		lda pstack+4,x
.4ada	f5 02		sbc $02,x		sbc pstack+2,x
.4adc	95 04		sta $04,x		sta pstack+4,x
.4ade	b5 05		lda $05,x		lda pstack+5,x
.4ae0	f5 03		sbc $03,x		sbc pstack+3,x
.4ae2	95 05		sta $05,x		sta pstack+5,x
.4ae4	e8		inx			inx
.4ae5	e8		inx			inx
.4ae6	4c 4a 40	jmp $404a		jmp next
.4ae9					w_ux2a:
>4ae9	02					.byte $02
>4aea	75 2a					.text 'u*'
>4aec	00 00 00 00 00 00 00 00			.fill 14,0
>4af4	00 00 00 00 00 00
>4afa	c4 4a					.word w_x2d
.4afc					xt_ux2a:
.4afc	64 01		stz $01			stz MMU_IO_CTRL ; Go to I/O page #0
.4afe	b5 05		lda $05,x		lda pstack+5,x  ; Set coprocessor unsigned A argument
.4b00	8d 01 de	sta $de01		sta $de01
.4b03	b5 04		lda $04,x		lda pstack+4,x
.4b05	8d 00 de	sta $de00		sta $de00
.4b08	b5 03		lda $03,x		lda pstack+3,x  ; Set coprocessor unsigned B argument
.4b0a	8d 03 de	sta $de03		sta $de03
.4b0d	b5 02		lda $02,x		lda pstack+2,x
.4b0f	8d 02 de	sta $de02		sta $de02
.4b12	e8		inx			inx
.4b13	e8		inx			inx
.4b14	ad 05 de	lda $de05		lda $de05       ; Read the coprocessor unsigned multiplication result
.4b17	95 03		sta $03,x		sta pstack+3,x
.4b19	ad 04 de	lda $de04		lda $de04
.4b1c	95 02		sta $02,x		sta pstack+2,x
.4b1e	4c 4a 40	jmp $404a		jmp next
.4b21					w_x2a:
>4b21	01					.byte $01
>4b22	2a					.text '*'
>4b23	00 00 00 00 00 00 00 00			.fill 15,0
>4b2b	00 00 00 00 00 00 00
>4b32	e9 4a					.word w_ux2a
.4b34					xt_x2a:
.4b34	64 01		stz $01			stz MMU_IO_CTRL ; Go to I/O page #0
.4b36	b5 05		lda $05,x		lda pstack+5,x  ; Set coprocessor unsigned A argument
.4b38	8d 05 de	sta $de05		sta $de05
.4b3b	b5 04		lda $04,x		lda pstack+4,x
.4b3d	8d 04 de	sta $de04		sta $de04
.4b40	b5 03		lda $03,x		lda pstack+3,x  ; Set coprocessor unsigned B argument
.4b42	8d 07 de	sta $de07		sta $de07
.4b45	b5 02		lda $02,x		lda pstack+2,x
.4b47	8d 06 de	sta $de06		sta $de06
.4b4a	e8		inx			inx
.4b4b	e8		inx			inx
.4b4c	ad 0d de	lda $de0d		lda $de0d       ; Read the coprocessor unsigned multiplication result
.4b4f	95 03		sta $03,x		sta pstack+3,x
.4b51	ad 0c de	lda $de0c		lda $de0c
.4b54	95 02		sta $02,x		sta pstack+2,x
.4b56	4c 4a 40	jmp $404a		jmp next
.4b59					w_ux2ax2dsoft:
>4b59	07					.byte $07
>4b5a	75 2a 2d 73 6f 66 74			.text 'u*-soft'
>4b61	00 00 00 00 00 00 00 00			.fill 9,0
>4b69	00
>4b6a	21 4b					.word w_x2a
.4b6c					xt_ux2ax2dsoft:
.4b6c	a9 00		lda #$00		lda #0          ; Initialize RESULT to 0
.4b6e	85 2c		sta $2c			sta tmp+2
.4b70	a2 10		ldx #$10		ldx #16         ; There are 16 bits in n2
.4b72						l1:
.4b72	56 03		lsr $03,x		lsr pstack+3,x  ; Get low bit of n2
.4b74	76 02		ror $02,x		ror pstack+2,x
.4b76	90 0b		bcc $4b83		bcc l2          ; 0 or 1?
.4b78	a8		tay			tay             ; If 1, add n1 (hi byte of tmp is in A)
.4b79	18		clc			clc
.4b7a	b5 04		lda $04,x		lda pstack+4,x
.4b7c	65 2c		adc $2c			adc tmp+2
.4b7e	85 2c		sta $2c			sta tmp+2
.4b80	98		tya			tya
.4b81	75 05		adc $05,x		adc pstack+5,x
.4b83						l2:
.4b83	6a		ror a			ror A
.4b84	66 2c		ror $2c			ror tmp+2
.4b86	66 2b		ror $2b			ror tmp+1
.4b88	66 2a		ror $2a			ror tmp
.4b8a	3a		dec a			dec a
.4b8b	d0 e5		bne $4b72		bne l1
.4b8d	85 2d		sta $2d			sta tmp+3
.4b8f	a5 2a		lda $2a			lda tmp         ; Save result to parameter stack
.4b91	95 04		sta $04,x		sta pstack+4,x
.4b93	a5 2b		lda $2b			lda tmp+1
.4b95	95 05		sta $05,x		sta pstack+5,x
.4b97	e8		inx			inx             ; Clean up parameter stack
.4b98	e8		inx			inx
.4b99	4c 4a 40	jmp $404a		jmp next
.4b9c					w_x2ax2dsoft:
>4b9c	06					.byte $06
>4b9d	2a 2d 73 6f 66 74			.text '*-soft'
>4ba3	00 00 00 00 00 00 00 00			.fill 10,0
>4bab	00 00
>4bad	59 4b					.word w_ux2ax2dsoft
.4baf					xt_x2ax2dsoft:
.4baf	64 30		stz $30			stz sign
.4bb1	b5 05		lda $05,x		lda pstack+5,x  ; Check to see if n1 is negative
.4bb3	10 11		bpl $4bc6		bpl chk_n2
.4bb5	a9 80		lda #$80		lda #$80        ; Yes: record the sign
.4bb7	85 30		sta $30			sta sign
.4bb9	38		sec			sec             ; Negate n1
.4bba	a9 00		lda #$00		lda #0
.4bbc	f5 04		sbc $04,x		sbc pstack+4,x
.4bbe	95 04		sta $04,x		sta pstack+4,x
.4bc0	a9 00		lda #$00		lda #0
.4bc2	f5 05		sbc $05,x		sbc pstack+5,x
.4bc4	95 05		sta $05,x		sta pstack+5,x
.4bc6						chk_n2:
.4bc6	b5 03		lda $03,x		lda pstack+3,x  ; Check to see if n2 is negative
.4bc8	10 13		bpl $4bdd		bpl init_tmp
.4bca	a5 30		lda $30			lda sign        ; Flip the sign bit, if so
.4bcc	49 80		eor #$80		eor #$80        ; And set the bit for the remainder
.4bce	85 30		sta $30			sta sign
.4bd0	38		sec			sec             ; Negate n2
.4bd1	a9 00		lda #$00		lda #0
.4bd3	f5 02		sbc $02,x		sbc pstack+2,x
.4bd5	95 02		sta $02,x		sta pstack+2,x
.4bd7	a9 00		lda #$00		lda #0
.4bd9	f5 03		sbc $03,x		sbc pstack+3,x
.4bdb	95 03		sta $03,x		sta pstack+3,x
.4bdd						init_tmp:
.4bdd	a9 00		lda #$00		lda #0          ; Initialize RESULT to 0
.4bdf	85 2c		sta $2c			sta tmp+2
.4be1	a2 10		ldx #$10		ldx #16         ; There are 16 bits in n2
.4be3						l1:
.4be3	56 03		lsr $03,x		lsr pstack+3,x  ; Get low bit of n2
.4be5	76 02		ror $02,x		ror pstack+2,x
.4be7	90 0b		bcc $4bf4		bcc l2          ; 0 or 1?
.4be9	a8		tay			tay             ; If 1, add n1 (hi byte of tmp is in A)
.4bea	18		clc			clc
.4beb	b5 04		lda $04,x		lda pstack+4,x
.4bed	65 2c		adc $2c			adc tmp+2
.4bef	85 2c		sta $2c			sta tmp+2
.4bf1	98		tya			tya
.4bf2	75 05		adc $05,x		adc pstack+5,x
.4bf4						l2:
.4bf4	6a		ror a			ror A
.4bf5	66 2c		ror $2c			ror tmp+2
.4bf7	66 2b		ror $2b			ror tmp+1
.4bf9	66 2a		ror $2a			ror tmp
.4bfb	3a		dec a			dec a
.4bfc	d0 e5		bne $4be3		bne l1
.4bfe	85 2d		sta $2d			sta tmp+3
.4c00	a5 2a		lda $2a			lda tmp         ; Save result to parameter stack
.4c02	95 04		sta $04,x		sta pstack+4,x
.4c04	a5 2b		lda $2b			lda tmp+1
.4c06	95 05		sta $05,x		sta pstack+5,x
.4c08	e8		inx			inx             ; Clean up parameter stack
.4c09	e8		inx			inx
.4c0a	a5 30		lda $30			lda sign        ; Check the sign
.4c0c	10 0d		bpl $4c1b		bpl done
.4c0e	38		sec			sec             ; If negative, negate result
.4c0f	a9 00		lda #$00		lda #0
.4c11	f5 02		sbc $02,x		sbc pstack+2,x
.4c13	95 02		sta $02,x		sta pstack+2,x
.4c15	a9 00		lda #$00		lda #0
.4c17	f5 03		sbc $03,x		sbc pstack+3,x
.4c19	95 03		sta $03,x		sta pstack+3,x
.4c1b						done:
.4c1b	4c 4a 40	jmp $404a		jmp next
.4c1e					w_umx2fmod:
>4c1e	06					.byte $06
>4c1f	75 6d 2f 6d 6f 64			.text 'um/mod'
>4c25	00 00 00 00 00 00 00 00			.fill 10,0
>4c2d	00 00
>4c2f	9c 4b					.word w_x2ax2dsoft
.4c31					xt_umx2fmod:
.4c31	38		sec			sec
.4c32	b5 06		lda $06,x		lda     pstack+6,x          ; Subtract hi cell of dividend by
.4c34	f5 02		sbc $02,x		sbc     pstack+2,x          ; divisor to see if there's an overflow condition.
.4c36	b5 07		lda $07,x		lda     pstack+7,x
.4c38	f5 03		sbc $03,x		sbc     pstack+3,x
.4c3a	b0 2e		bcs $4c6a		bcs     overflow            ; Branch if /0 or overflow.
.4c3c	a9 11		lda #$11		lda     #$11                ; Loop 17x.
.4c3e	85 2a		sta $2a			sta     tmp                 ; Use tmp for loop counter.
.4c40						loop:
.4c40	36 04		rol $04,x		rol     pstack+4,x          ; Rotate dividend lo cell left one bit.
.4c42	36 05		rol $05,x		rol     pstack+5,x
.4c44	c6 2a		dec $2a			dec     tmp                 ; Decrement loop counter.
.4c46	f0 2c		beq $4c74		beq     done                ; If we're done, then branch to end.
.4c48	36 06		rol $06,x		rol     pstack+6,x          ; Otherwise rotate dividend hi cell left one bit.
.4c4a	36 07		rol $07,x		rol     pstack+7,x
.4c4c	64 2b		stz $2b			stz     tmp+1
.4c4e	26 2b		rol $2b			rol     tmp+1               ; Rotate the bit carried out of above into tmp+1.
.4c50	38		sec			sec
.4c51	b5 06		lda $06,x		lda     pstack+6,x          ; Subtract dividend hi cell minus divisor.
.4c53	f5 02		sbc $02,x		sbc     pstack+2,x
.4c55	85 2c		sta $2c			sta     tmp+2               ; Put result temporarily in tmp+2 (lo byte)
.4c57	b5 07		lda $07,x		lda     pstack+7,x
.4c59	f5 03		sbc $03,x		sbc     pstack+3,x
.4c5b	a8		tay			tay                         ; and Y (hi byte).
.4c5c	a5 2b		lda $2b			lda     tmp+1               ; Remember now to bring in the bit carried out above.
.4c5e	e9 00		sbc #$00		sbc     #0
.4c60	90 de		bcc $4c40		bcc     loop
.4c62	a5 2c		lda $2c			lda     tmp+2               ; If that didn't cause a borrow,
.4c64	95 06		sta $06,x		sta     pstack+6,x          ; make the result from above to
.4c66	94 07		sty $07,x		sty     pstack+7,x          ; be the new dividend hi cell
.4c68	80 d6		bra $4c40		bra     loop                ; and then brach up.  (NMOS 6502 can use BCS here.)
.4c6a						overflow:
.4c6a	a9 ff		lda #$ff		lda     #$ff                ; If overflow or /0 condition found,
.4c6c	95 06		sta $06,x		sta     pstack+6,x          ; just put FFFF in both the remainder
.4c6e	95 07		sta $07,x		sta     pstack+7,x
.4c70	95 04		sta $04,x		sta     pstack+4,x          ; and the quotient.
.4c72	95 05		sta $05,x		sta     pstack+5,x
.4c74						done:
.4c74	e8		inx			inx
.4c75	e8		inx			inx
.4c76	4c 4a 40	jmp $404a		jmp next
.4c79					w_sx3ed:
>4c79	03					.byte $03
>4c7a	73 3e 64				.text 's>d'
>4c7d	00 00 00 00 00 00 00 00			.fill 13,0
>4c85	00 00 00 00 00
>4c8a	1e 4c					.word w_umx2fmod
.4c8c					xt_sx3ed:
.4c8c	ca		dex			dex
.4c8d	ca		dex			dex
.4c8e	b5 04		lda $04,x		lda pstack+4,x
.4c90	95 02		sta $02,x		sta pstack+2,x
.4c92	b5 05		lda $05,x		lda pstack+5,x
.4c94	95 03		sta $03,x		sta pstack+3,x
.4c96	30 07		bmi $4c9f		bmi is_neg
.4c98	74 04		stz $04,x		stz pstack+4,x
.4c9a	74 05		stz $05,x		stz pstack+5,x
.4c9c	4c 4a 40	jmp $404a		jmp next
.4c9f						is_neg:
.4c9f	a9 ff		lda #$ff		lda #$ff
.4ca1	95 04		sta $04,x		sta pstack+4,x
.4ca3	95 05		sta $05,x		sta pstack+5,x
.4ca5	4c 4a 40	jmp $404a		jmp next
.4ca8					w_1x2b:
>4ca8	02					.byte $02
>4ca9	31 2b					.text '1+'
>4cab	00 00 00 00 00 00 00 00			.fill 14,0
>4cb3	00 00 00 00 00 00
>4cb9	79 4c					.word w_sx3ed
.4cbb					xt_1x2b:
.4cbb	f6 02		inc $02,x		inc pstack+2,x
.4cbd	d0 02		bne $4cc1		bne skip
.4cbf	f6 03		inc $03,x		inc pstack+3,x
.4cc1						skip:
.4cc1	4c 4a 40	jmp $404a		jmp next
.4cc4					w_2x2b:
>4cc4	02					.byte $02
>4cc5	32 2b					.text '2+'
>4cc7	00 00 00 00 00 00 00 00			.fill 14,0
>4ccf	00 00 00 00 00 00
>4cd5	a8 4c					.word w_1x2b
.4cd7					xt_2x2b:
.4cd7	18		clc			clc
.4cd8	b5 02		lda $02,x		lda pstack+2,x
.4cda	69 02		adc #$02		adc #2
.4cdc	95 02		sta $02,x		sta pstack+2,x
.4cde	b5 03		lda $03,x		lda pstack+3,x
.4ce0	69 00		adc #$00		adc #0
.4ce2	95 03		sta $03,x		sta pstack+3,x
.4ce4	4c 4a 40	jmp $404a		jmp next
.4ce7					w_1x2d:
>4ce7	02					.byte $02
>4ce8	31 2d					.text '1-'
>4cea	00 00 00 00 00 00 00 00			.fill 14,0
>4cf2	00 00 00 00 00 00
>4cf8	c4 4c					.word w_2x2b
.4cfa					xt_1x2d:
.4cfa	b5 02		lda $02,x		lda pstack+2,x
.4cfc	d0 02		bne $4d00		bne l1
.4cfe	d6 03		dec $03,x		dec pstack+3,x
.4d00						l1:
.4d00	d6 02		dec $02,x		dec pstack+2,x
.4d02	4c 4a 40	jmp $404a		jmp next
.4d05					w_2x2d:
>4d05	02					.byte $02
>4d06	32 2d					.text '2-'
>4d08	00 00 00 00 00 00 00 00			.fill 14,0
>4d10	00 00 00 00 00 00
>4d16	e7 4c					.word w_1x2d
.4d18					xt_2x2d:
.4d18	38		sec			sec
.4d19	b5 02		lda $02,x		lda pstack+2,x
.4d1b	e9 02		sbc #$02		sbc #2
.4d1d	95 02		sta $02,x		sta pstack+2,x
.4d1f	b5 03		lda $03,x		lda pstack+3,x
.4d21	e9 00		sbc #$00		sbc #0
.4d23	95 03		sta $03,x		sta pstack+3,x
.4d25	4c 4a 40	jmp $404a		jmp next
.4d28					w_and:
>4d28	03					.byte $03
>4d29	61 6e 64				.text 'and'
>4d2c	00 00 00 00 00 00 00 00			.fill 13,0
>4d34	00 00 00 00 00
>4d39	05 4d					.word w_2x2d
.4d3b					xt_and:
.4d3b	b5 02		lda $02,x		lda pstack+2,x
.4d3d	35 04		and $04,x		and pstack+4,x
.4d3f	95 04		sta $04,x		sta pstack+4,x
.4d41	b5 03		lda $03,x		lda pstack+3,x
.4d43	35 05		and $05,x		and pstack+5,x
.4d45	95 05		sta $05,x		sta pstack+5,x
.4d47	e8		inx			inx
.4d48	e8		inx			inx
.4d49	4c 4a 40	jmp $404a		jmp next
.4d4c					w_or:
>4d4c	02					.byte $02
>4d4d	6f 72					.text 'or'
>4d4f	00 00 00 00 00 00 00 00			.fill 14,0
>4d57	00 00 00 00 00 00
>4d5d	28 4d					.word w_and
.4d5f					xt_or:
.4d5f	b5 02		lda $02,x		lda pstack+2,x
.4d61	15 04		ora $04,x		ora pstack+4,x
.4d63	95 04		sta $04,x		sta pstack+4,x
.4d65	b5 03		lda $03,x		lda pstack+3,x
.4d67	15 05		ora $05,x		ora pstack+5,x
.4d69	95 05		sta $05,x		sta pstack+5,x
.4d6b	e8		inx			inx
.4d6c	e8		inx			inx
.4d6d	4c 4a 40	jmp $404a		jmp next
.4d70					w_xor:
>4d70	03					.byte $03
>4d71	78 6f 72				.text 'xor'
>4d74	00 00 00 00 00 00 00 00			.fill 13,0
>4d7c	00 00 00 00 00
>4d81	4c 4d					.word w_or
.4d83					xt_xor:
.4d83	b5 02		lda $02,x		lda pstack+2,x
.4d85	55 04		eor $04,x		eor pstack+4,x
.4d87	95 04		sta $04,x		sta pstack+4,x
.4d89	b5 03		lda $03,x		lda pstack+3,x
.4d8b	55 05		eor $05,x		eor pstack+5,x
.4d8d	95 05		sta $05,x		sta pstack+5,x
.4d8f	e8		inx			inx
.4d90	e8		inx			inx
.4d91	4c 4a 40	jmp $404a		jmp next
.4d94					w_not:
>4d94	03					.byte $03
>4d95	6e 6f 74				.text 'not'
>4d98	00 00 00 00 00 00 00 00			.fill 13,0
>4da0	00 00 00 00 00
>4da5	70 4d					.word w_xor
.4da7					xt_not:
.4da7	b5 02		lda $02,x		lda pstack+2,x
.4da9	49 ff		eor #$ff		eor #$ff
.4dab	95 02		sta $02,x		sta pstack+2,x
.4dad	b5 03		lda $03,x		lda pstack+3,x
.4daf	49 ff		eor #$ff		eor #$ff
.4db1	95 03		sta $03,x		sta pstack+3,x
.4db3	4c 4a 40	jmp $404a		jmp next
.4db6					w_0x3c:
>4db6	02					.byte $02
>4db7	30 3c					.text '0<'
>4db9	00 00 00 00 00 00 00 00			.fill 14,0
>4dc1	00 00 00 00 00 00
>4dc7	94 4d					.word w_not
.4dc9					xt_0x3c:
.4dc9	b5 03		lda $03,x		lda pstack+3,x
.4dcb	30 07		bmi $4dd4		bmi istrue
.4dcd	74 02		stz $02,x		stz pstack+2,x
.4dcf	74 03		stz $03,x		stz pstack+3,x
.4dd1	4c 4a 40	jmp $404a		jmp next
.4dd4						istrue:
.4dd4	a9 ff		lda #$ff		lda #$ff
.4dd6	95 02		sta $02,x		sta pstack+2,x
.4dd8	95 03		sta $03,x		sta pstack+3,x
.4dda	4c 4a 40	jmp $404a		jmp next
.4ddd					w_0x3d:
>4ddd	02					.byte $02
>4dde	30 3d					.text '0='
>4de0	00 00 00 00 00 00 00 00			.fill 14,0
>4de8	00 00 00 00 00 00
>4dee	b6 4d					.word w_0x3c
.4df0					xt_0x3d:
.4df0	b5 02		lda $02,x		lda pstack+2,x
.4df2	d0 0d		bne $4e01		bne isfalse
.4df4	b5 03		lda $03,x		lda pstack+3,x
.4df6	d0 09		bne $4e01		bne isfalse
.4df8	a9 ff		lda #$ff		lda #$ff
.4dfa	95 02		sta $02,x		sta pstack+2,x
.4dfc	95 03		sta $03,x		sta pstack+3,x
.4dfe	4c 4a 40	jmp $404a		jmp next
.4e01						isfalse:
.4e01	74 02		stz $02,x		stz pstack+2,x
.4e03	74 03		stz $03,x		stz pstack+3,x
.4e05	4c 4a 40	jmp $404a		jmp next
.4e08					w_0x3e:
>4e08	02					.byte $02
>4e09	30 3e					.text '0>'
>4e0b	00 00 00 00 00 00 00 00			.fill 14,0
>4e13	00 00 00 00 00 00
>4e19	dd 4d					.word w_0x3d
.4e1b					xt_0x3e:
.4e1b	b5 03		lda $03,x		lda pstack+3,x
.4e1d	30 0f		bmi $4e2e		bmi isfalse
.4e1f	d0 04		bne $4e25		bne istrue
.4e21	b5 02		lda $02,x		lda pstack+2,x
.4e23	f0 09		beq $4e2e		beq isfalse
.4e25						istrue:
.4e25	a9 ff		lda #$ff		lda #$ff
.4e27	95 02		sta $02,x		sta pstack+2,x
.4e29	95 03		sta $03,x		sta pstack+3,x
.4e2b	4c 4a 40	jmp $404a		jmp next
.4e2e						isfalse:
.4e2e	74 02		stz $02,x		stz pstack+2,x
.4e30	74 03		stz $03,x		stz pstack+3,x
.4e32	4c 4a 40	jmp $404a		jmp next
.4e35					w_x28variablex29:
>4e35	0a					.byte $0A
>4e36	28 76 61 72 69 61 62 6c			.text '(variable)'
>4e3e	65 29
>4e40	00 00 00 00 00 00			.fill 6,0
>4e46	08 4e					.word w_0x3e
.4e48					xt_x28variablex29:
.4e48	18		clc			clc                     ; push(wp + 3)
.4e49	a5 22		lda $22			lda wp
.4e4b	69 03		adc #$03		adc #3
.4e4d	95 00		sta $00,x		sta pstack,x
.4e4f	a5 23		lda $23			lda wp+1
.4e51	69 00		adc #$00		adc #0
.4e53	95 01		sta $01,x		sta pstack+1,x
.4e55	ca		dex			dex
.4e56	ca		dex			dex
.4e57	4c 4a 40	jmp $404a		jmp next
.4e5a					w_x28constantx29:
>4e5a	0a					.byte $0A
>4e5b	28 63 6f 6e 73 74 61 6e			.text '(constant)'
>4e63	74 29
>4e65	00 00 00 00 00 00			.fill 6,0
>4e6b	35 4e					.word w_x28variablex29
.4e6d					xt_x28constantx29:
.4e6d	a0 03		ldy #$03		ldy #3                  ; push(memory(wp + 3))
.4e6f	b1 22		lda ($22),y		lda (wp),y
.4e71	95 00		sta $00,x		sta pstack,x
.4e73	c8		iny			iny
.4e74	b1 22		lda ($22),y		lda (wp),y
.4e76	95 01		sta $01,x		sta pstack+1,x
.4e78	ca		dex			dex
.4e79	ca		dex			dex
.4e7a	4c 4a 40	jmp $404a		jmp next
.4e7d					w_cells:
>4e7d	05					.byte $05
>4e7e	63 65 6c 6c 73				.text 'cells'
>4e83	00 00 00 00 00 00 00 00			.fill 11,0
>4e8b	00 00 00
>4e8e	5a 4e					.word w_x28constantx29
.4e90					xt_cells:
.4e90	4c 6d 4e	jmp $4e6d		jmp xt_x28constantx29
>4e93	02 00					.word 2
.4e95					w_x28userx29:
>4e95	06					.byte $06
>4e96	28 75 73 65 72 29			.text '(user)'
>4e9c	00 00 00 00 00 00 00 00			.fill 10,0
>4ea4	00 00
>4ea6	7d 4e					.word w_cells
.4ea8					xt_x28userx29:
.4ea8	18		clc			clc                     ; push(up + memory(wp + 3))
.4ea9	a0 03		ldy #$03		ldy #3
.4eab	a5 24		lda $24			lda up
.4ead	71 22		adc ($22),y		adc (wp),y
.4eaf	95 00		sta $00,x		sta pstack,x
.4eb1	c8		iny			iny
.4eb2	a5 25		lda $25			lda up+1
.4eb4	71 22		adc ($22),y		adc (wp),y
.4eb6	95 01		sta $01,x		sta pstack+1,x
.4eb8	ca		dex			dex
.4eb9	ca		dex			dex
.4eba	4c 4a 40	jmp $404a		jmp next
.4ebd					w_x28branchx29:
>4ebd	08					.byte $08
>4ebe	28 62 72 61 6e 63 68 29			.text '(branch)'
>4ec6	00 00 00 00 00 00 00 00			.fill 8,0
>4ece	95 4e					.word w_x28userx29
.4ed0					xt_x28branchx29:
.4ed0	a0 01		ldy #$01		ldy #1              ; ip := branch address
.4ed2	b2 20		lda ($20)		lda (ip)
.4ed4	85 2a		sta $2a			sta tmp
.4ed6	b1 20		lda ($20),y		lda (ip),y
.4ed8	85 21		sta $21			sta ip+1
.4eda	a5 2a		lda $2a			lda tmp
.4edc	85 20		sta $20			sta ip
.4ede	4c 4a 40	jmp $404a		jmp next
.4ee1					w_x28branch0x29:
>4ee1	09					.byte $09
>4ee2	28 62 72 61 6e 63 68 30			.text '(branch0)'
>4eea	29
>4eeb	00 00 00 00 00 00 00			.fill 7,0
>4ef2	bd 4e					.word w_x28branchx29
.4ef4					xt_x28branch0x29:
.4ef4	b5 02		lda $02,x		lda pstack+2,x      ; Check to see if TOS is 0
.4ef6	d0 04		bne $4efc		bne nobranch        ; No: skip over the branch address
.4ef8	b5 03		lda $03,x		lda pstack+3,x
.4efa	f0 0f		beq $4f0b		beq dobranch        ; Yes: take the branch
.4efc						nobranch:
.4efc	18		clc			clc                 ; No: skip over the branch address
.4efd	a5 20		lda $20			lda ip
.4eff	69 02		adc #$02		adc #2
.4f01	85 20		sta $20			sta ip
.4f03	a5 21		lda $21			lda ip+1
.4f05	69 00		adc #$00		adc #0
.4f07	85 21		sta $21			sta ip+1
.4f09	80 0e		bra $4f19		bra done
.4f0b						dobranch:
.4f0b	a0 01		ldy #$01		ldy #1              ; ip := branch address
.4f0d	b2 20		lda ($20)		lda (ip)
.4f0f	85 2a		sta $2a			sta tmp
.4f11	b1 20		lda ($20),y		lda (ip),y
.4f13	85 21		sta $21			sta ip+1
.4f15	a5 2a		lda $2a			lda tmp
.4f17	85 20		sta $20			sta ip
.4f19						done:
.4f19	e8		inx			inx                 ; clean up the parameter stack
.4f1a	e8		inx			inx
.4f1b	4c 4a 40	jmp $404a		jmp next
.4f1e					w_x28dox29:
>4f1e	04					.byte $04
>4f1f	28 64 6f 29				.text '(do)'
>4f23	00 00 00 00 00 00 00 00			.fill 12,0
>4f2b	00 00 00 00
>4f2f	e1 4e					.word w_x28branch0x29
.4f31					xt_x28dox29:
.4f31	b5 03		lda $03,x		lda pstack+3,x
.4f33	48		pha			pha
.4f34	b5 02		lda $02,x		lda pstack+2,x
.4f36	48		pha			pha
.4f37	b5 05		lda $05,x		lda pstack+5,x
.4f39	48		pha			pha
.4f3a	b5 04		lda $04,x		lda pstack+4,x
.4f3c	48		pha			pha
.4f3d	18		clc			clc
.4f3e	8a		txa			txa
.4f3f	69 04		adc #$04		adc #4
.4f41	aa		tax			tax
.4f42	4c 4a 40	jmp $404a		jmp next
.4f45					w_x3ei:
>4f45	02					.byte $02
>4f46	3e 69					.text '>i'
>4f48	00 00 00 00 00 00 00 00			.fill 14,0
>4f50	00 00 00 00 00 00
>4f56	1e 4f					.word w_x28dox29
.4f58					xt_x3ei:
>0101						limit       .word ?
>0103						current     .word ?
.4f58	b5 03		lda $03,x		lda pstack+3,x      ; tmp := n
.4f5a	85 2b		sta $2b			sta tmp+1
.4f5c	b5 02		lda $02,x		lda pstack+2,x
.4f5e	85 2a		sta $2a			sta tmp
.4f60	e8		inx			inx
.4f61	e8		inx			inx
.4f62	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.4f64	ba		tsx			tsx
.4f65	a5 2b		lda $2b			lda tmp+1           ; current := tmp = n
.4f67	9d 04 01	sta $0104,x		sta current+1
.4f6a	a5 2a		lda $2a			lda tmp
.4f6c	9d 03 01	sta $0103,x		sta current
.4f6f	a6 2e		ldx $2e			ldx savex
.4f71	4c 4a 40	jmp $404a		jmp next
.4f74					w_leave:
>4f74	05					.byte $05
>4f75	6c 65 61 76 65				.text 'leave'
>4f7a	00 00 00 00 00 00 00 00			.fill 11,0
>4f82	00 00 00
>4f85	45 4f					.word w_x3ei
.4f87					xt_leave:
>0101						limit       .word ?
>0103						current     .word ?
.4f87	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.4f89	ba		tsx			tsx
.4f8a	bd 04 01	lda $0104,x		lda current+1       ; limit := current
.4f8d	9d 02 01	sta $0102,x		sta limit+1
.4f90	bd 03 01	lda $0103,x		lda current
.4f93	9d 01 01	sta $0101,x		sta limit
.4f96	a6 2e		ldx $2e			ldx savex
.4f98	4c 4a 40	jmp $404a		jmp next
.4f9b					w_x28loopx29:
>4f9b	06					.byte $06
>4f9c	28 6c 6f 6f 70 29			.text '(loop)'
>4fa2	00 00 00 00 00 00 00 00			.fill 10,0
>4faa	00 00
>4fac	74 4f					.word w_leave
.4fae					xt_x28loopx29:
>0101						limit       .word ?
>0103						current     .word ?
.4fae	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.4fb0	ba		tsx			tsx
.4fb1	fe 03 01	inc $0103,x		inc current         ; Increment current
.4fb4	d0 03		bne $4fb9		bne chk_current
.4fb6	fe 04 01	inc $0104,x		inc current+1
.4fb9						chk_current:
.4fb9	38		sec			sec
.4fba	bd 04 01	lda $0104,x		lda current+1       ; compare high bytes
.4fbd	fd 02 01	sbc $0102,x		sbc limit+1
.4fc0	50 02		bvc $4fc4		bvc label1          ; the equality comparison is in the Z flag here
.4fc2	49 80		eor #$80		eor #$80            ; the Z flag is affected here
.4fc4						label1:
.4fc4	30 23		bmi $4fe9		bmi dobranch        ; if current+1 < limit+1 then NUM1 < limit
.4fc6	50 02		bvc $4fca		bvc label2          ; the Z flag was affected only if V is 1
.4fc8	49 80		eor #$80		eor #$80            ; restore the Z flag to the value it had after sbc NUM2H
.4fca						label2:
.4fca	d0 08		bne $4fd4		bne nobranch        ; if current+1 <> limit+1 then current > limit (so current >= limit)
.4fcc	bd 03 01	lda $0103,x		lda current         ; compare low bytes
.4fcf	fd 01 01	sbc $0101,x		sbc limit
.4fd2	90 15		bcc $4fe9		bcc dobranch        ; if current < limit then current < limit
.4fd4						nobranch:
.4fd4	8a		txa			txa                 ; Yes: Remove the context from the return stack
.4fd5	18		clc			clc
.4fd6	69 04		adc #$04		adc #4
.4fd8	aa		tax			tax
.4fd9	9a		txs			txs
.4fda	18		clc			clc                 ; And skip over the branch address
.4fdb	a5 20		lda $20			lda ip
.4fdd	69 02		adc #$02		adc #2
.4fdf	85 20		sta $20			sta ip
.4fe1	a5 21		lda $21			lda ip+1
.4fe3	69 00		adc #$00		adc #0
.4fe5	85 21		sta $21			sta ip+1
.4fe7	80 0e		bra $4ff7		bra done
.4fe9						dobranch:
.4fe9	a0 01		ldy #$01		ldy #1              ; No: ip := branch address
.4feb	b2 20		lda ($20)		lda (ip)
.4fed	85 2a		sta $2a			sta tmp
.4fef	b1 20		lda ($20),y		lda (ip),y
.4ff1	85 21		sta $21			sta ip+1
.4ff3	a5 2a		lda $2a			lda tmp
.4ff5	85 20		sta $20			sta ip
.4ff7						done:
.4ff7	a6 2e		ldx $2e			ldx savex           ; Restore the parameter stack pointer
.4ff9	4c 4a 40	jmp $404a		jmp next
.4ffc					w_x28x2bloopx29:
>4ffc	07					.byte $07
>4ffd	28 2b 6c 6f 6f 70 29			.text '(+loop)'
>5004	00 00 00 00 00 00 00 00			.fill 9,0
>500c	00
>500d	9b 4f					.word w_x28loopx29
.500f					xt_x28x2bloopx29:
>0101						limit       .word ?
>0103						current     .word ?
.500f	b5 03		lda $03,x		lda pstack+3,x      ; Pop n from the stack
.5011	85 2b		sta $2b			sta tmp+1
.5013	b5 02		lda $02,x		lda pstack+2,x
.5015	85 2a		sta $2a			sta tmp
.5017	e8		inx			inx
.5018	e8		inx			inx
.5019	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.501b	ba		tsx			tsx
.501c	18		clc			clc                 ; Increment current by n
.501d	bd 03 01	lda $0103,x		lda current
.5020	65 2a		adc $2a			adc tmp
.5022	9d 03 01	sta $0103,x		sta current
.5025	bd 04 01	lda $0104,x		lda current+1
.5028	65 2b		adc $2b			adc tmp+1
.502a	9d 04 01	sta $0104,x		sta current+1
.502d						chk_current:
.502d	38		sec			sec
.502e	bd 04 01	lda $0104,x		lda current+1       ; compare high bytes
.5031	fd 02 01	sbc $0102,x		sbc limit+1
.5034	50 02		bvc $5038		bvc label1          ; the equality comparison is in the Z flag here
.5036	49 80		eor #$80		eor #$80            ; the Z flag is affected here
.5038						label1:
.5038	30 23		bmi $505d		bmi dobranch        ; if current+1 < limit+1 then current < limit
.503a	50 02		bvc $503e		bvc label2          ; the Z flag was affected only if V is 1
.503c	49 80		eor #$80		eor #$80            ; restore the Z flag to the value it had after sbc current+1
.503e						label2:
.503e	d0 08		bne $5048		bne nobranch        ; if current+1 <> limit+1 then current > limit (so current >= limit)
.5040	bd 03 01	lda $0103,x		lda current         ; compare low bytes
.5043	fd 01 01	sbc $0101,x		sbc limit
.5046	90 15		bcc $505d		bcc dobranch        ; if current < limit then current < limit
.5048						nobranch:
.5048	8a		txa			txa                 ; Yes: Remove the context from the return stack
.5049	18		clc			clc
.504a	69 04		adc #$04		adc #4
.504c	aa		tax			tax
.504d	9a		txs			txs
.504e	18		clc			clc                 ; And skip over the branch address
.504f	a5 20		lda $20			lda ip
.5051	69 02		adc #$02		adc #2
.5053	85 20		sta $20			sta ip
.5055	a5 21		lda $21			lda ip+1
.5057	69 00		adc #$00		adc #0
.5059	85 21		sta $21			sta ip+1
.505b	80 0e		bra $506b		bra done
.505d						dobranch:
.505d	a0 01		ldy #$01		ldy #1              ; No: ip := branch address
.505f	b2 20		lda ($20)		lda (ip)
.5061	85 2a		sta $2a			sta tmp
.5063	b1 20		lda ($20),y		lda (ip),y
.5065	85 21		sta $21			sta ip+1
.5067	a5 2a		lda $2a			lda tmp
.5069	85 20		sta $20			sta ip
.506b						done:
.506b	a6 2e		ldx $2e			ldx savex           ; Restore the parameter stack pointer
.506d	4c 4a 40	jmp $404a		jmp next
.5070					w_i:
>5070	01					.byte $01
>5071	69					.text 'i'
>5072	00 00 00 00 00 00 00 00			.fill 15,0
>507a	00 00 00 00 00 00 00
>5081	fc 4f					.word w_x28x2bloopx29
.5083					xt_i:
>0101						limit       .word ?
>0103						current     .word ?
.5083	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.5085	ba		tsx			tsx
.5086	bc 04 01	ldy $0104,x		ldy current+1       ; Get the value of current
.5089	bd 03 01	lda $0103,x		lda current
.508c	a6 2e		ldx $2e			ldx savex           ; Restore the PSP
.508e	94 01		sty $01,x		sty pstack+1,x      ; Save the value of current to the stack
.5090	95 00		sta $00,x		sta pstack,x
.5092	ca		dex			dex
.5093	ca		dex			dex
.5094	4c 4a 40	jmp $404a		jmp next
.5097					w_x28ofx29:
>5097	04					.byte $04
>5098	28 6f 66 29				.text '(of)'
>509c	00 00 00 00 00 00 00 00			.fill 12,0
>50a4	00 00 00 00
>50a8	70 50					.word w_i
.50aa					xt_x28ofx29:
.50aa	b5 02		lda $02,x		lda pstack+2,x      ; Does n1 == n2?
.50ac	d5 04		cmp $04,x		cmp pstack+4,x
.50ae	d0 1a		bne $50ca		bne not_eq
.50b0	b5 03		lda $03,x		lda pstack+3,x
.50b2	d5 05		cmp $05,x		cmp pstack+5,x
.50b4	d0 14		bne $50ca		bne not_eq
.50b6	e8		inx			inx
.50b7	e8		inx			inx
.50b8	e8		inx			inx
.50b9	e8		inx			inx
.50ba	18		clc			clc                 ; Skip over the branch target
.50bb	a5 20		lda $20			lda ip
.50bd	69 02		adc #$02		adc #2
.50bf	85 20		sta $20			sta ip
.50c1	a5 21		lda $21			lda ip+1
.50c3	69 00		adc #$00		adc #0
.50c5	85 21		sta $21			sta ip+1
.50c7	4c 4a 40	jmp $404a		jmp next
.50ca						not_eq:
.50ca	e8		inx			inx                 ; Remove n2 from stack
.50cb	e8		inx			inx
.50cc	a0 01		ldy #$01		ldy #1              ; Take the branch target
.50ce	b2 20		lda ($20)		lda (ip)
.50d0	85 2a		sta $2a			sta tmp
.50d2	b1 20		lda ($20),y		lda (ip),y
.50d4	85 21		sta $21			sta ip+1
.50d6	a5 2a		lda $2a			lda tmp
.50d8	85 20		sta $20			sta ip
.50da	4c 4a 40	jmp $404a		jmp next
.50dd					w_execute:
>50dd	07					.byte $07
>50de	65 78 65 63 75 74 65			.text 'execute'
>50e5	00 00 00 00 00 00 00 00			.fill 9,0
>50ed	00
>50ee	97 50					.word w_x28ofx29
.50f0					xt_execute:
.50f0	b5 02		lda $02,x		lda pstack+2,x      ; wp := xt
.50f2	85 22		sta $22			sta wp
.50f4	b5 03		lda $03,x		lda pstack+3,x
.50f6	85 23		sta $23			sta wp+1
.50f8	e8		inx			inx                 ; Clean up stack
.50f9	e8		inx			inx
.50fa	6c 22 00	jmp ($0022)		jmp (wp)            ; jmp xt
.50fd					w_x28vocabularyx29:
>50fd	0c					.byte $0C
>50fe	28 76 6f 63 61 62 75 6c			.text '(vocabulary)'
>5106	61 72 79 29
>510a	00 00 00 00				.fill 4,0
>510e	dd 50					.word w_execute
.5110					xt_x28vocabularyx29:
.5110	18		clc			clc                 ; tmp := up + user_context
.5111	a5 24		lda $24			lda up
.5113	69 08		adc #$08		adc #user_context
.5115	85 2a		sta $2a			sta tmp
.5117	a5 25		lda $25			lda up+1
.5119	69 00		adc #$00		adc #0
.511b	85 2b		sta $2b			sta tmp+1
.511d	a0 01		ldy #$01		ldy #1              ; (tmp) := wp + 3
.511f	18		clc			clc
.5120	a5 22		lda $22			lda wp
.5122	69 03		adc #$03		adc #3
.5124	92 2a		sta ($2a)		sta (tmp)
.5126	a5 23		lda $23			lda wp+1
.5128	69 00		adc #$00		adc #0
.512a	91 2a		sta ($2a),y		sta (tmp),y
.512c	4c 4a 40	jmp $404a		jmp next
.512f					w_forth:
>512f	05					.byte $05
>5130	66 6f 72 74 68				.text 'forth'
>5135	00 00 00 00 00 00 00 00			.fill 11,0
>513d	00 00 00
>5140	fd 50					.word w_x28vocabularyx29
.5142					xt_forth:
.5142	4c 10 51	jmp $5110		jmp xt_x28vocabularyx29
>5145	a1 60					.word <>w_cold
.5147					w_x28findx29:
>5147	06					.byte $06
>5148	28 66 69 6e 64 29			.text '(find)'
>514e	00 00 00 00 00 00 00 00			.fill 10,0
>5156	00 00
>5158	2f 51					.word w_forth
.515a					xt_x28findx29:
.515a	b5 03		lda $03,x		lda pstack+3,x          ; src_ptr = dictionary name
.515c	85 34		sta $34			sta src_ptr+1
.515e	b5 02		lda $02,x		lda pstack+2,x
.5160	85 33		sta $33			sta src_ptr
.5162	b5 05		lda $05,x		lda pstack+5,x          ; dst_ptr = word to find
.5164	85 36		sta $36			sta dst_ptr+1
.5166	b5 04		lda $04,x		lda pstack+4,x
.5168	85 35		sta $35			sta dst_ptr
.516a						loop:
.516a	a5 33		lda $33			lda src_ptr             ; Check to see if src_ptr = NULL
.516c	d0 0d		bne $517b		bne not_eod
.516e	a5 34		lda $34			lda src_ptr+1
.5170	d0 09		bne $517b		bne not_eod
.5172	e8		inx			inx                     ; Clean up the stack
.5173	e8		inx			inx
.5174	74 03		stz $03,x		stz pstack+3,x          ; And return 0
.5176	74 02		stz $02,x		stz pstack+2,x
.5178	4c 4a 40	jmp $404a		jmp next
.517b						not_eod:
.517b	b2 33		lda ($33)		lda (src_ptr)           ; Get the size of the word in the dictionary
.517d	29 3f		and #$3f		and #$3f                ; Filter out the flags
.517f	d2 35		cmp ($35)		cmp (dst_ptr)           ; Check it against the word to search
.5181	f0 1b		beq $519e		beq chk_chars           ; If they match, check the characters
.5183						next_word:
.5183	18		clc			clc                     ; Move src_ptr to the link field
.5184	a5 33		lda $33			lda src_ptr
.5186	69 11		adc #$11		adc #17
.5188	85 33		sta $33			sta src_ptr
.518a	a5 34		lda $34			lda src_ptr+1
.518c	69 00		adc #$00		adc #0
.518e	85 34		sta $34			sta src_ptr+1
.5190	a0 01		ldy #$01		ldy #1                  ; Follow the link to the next word in the dictionary
.5192	b2 33		lda ($33)		lda (src_ptr)
.5194	48		pha			pha
.5195	b1 33		lda ($33),y		lda (src_ptr),y
.5197	85 34		sta $34			sta src_ptr+1
.5199	68		pla			pla
.519a	85 33		sta $33			sta src_ptr
.519c	80 cc		bra $516a		bra loop                ; And check that word
.519e						chk_chars:
.519e	a8		tay			tay                     ; y := index to character to check
.519f						char_loop:
.519f	b1 33		lda ($33),y		lda (src_ptr),y         ; Check the yth character
.51a1	d1 35		cmp ($35),y		cmp (dst_ptr),y
.51a3	d0 de		bne $5183		bne next_word           ; If they are not equal, go to the next word in the dictionary
.51a5	88		dey			dey                     ; Move to the previous character in the words
.51a6	d0 f7		bne $519f		bne char_loop           ; Are we back at the size? No: keep checking
.51a8	ca		dex			dex                     ; Make room for all the return values
.51a9	ca		dex			dex
.51aa	a9 01		lda #$01		lda #1                  ; 1 at top of stack
.51ac	74 03		stz $03,x		stz pstack+3,x
.51ae	95 02		sta $02,x		sta pstack+2,x
.51b0	b2 33		lda ($33)		lda (src_ptr)           ; Then the length of the word
.51b2	74 05		stz $05,x		stz pstack+5,x
.51b4	95 04		sta $04,x		sta pstack+4,x
.51b6	18		clc			clc                     ; Then the pfa pointer
.51b7	a5 33		lda $33			lda src_ptr
.51b9	69 16		adc #$16		adc #17+5               ; Skip size, name, link, and code cfa
.51bb	95 06		sta $06,x		sta pstack+6,x
.51bd	a5 34		lda $34			lda src_ptr+1
.51bf	69 00		adc #$00		adc #0
.51c1	95 07		sta $07,x		sta pstack+7,x
.51c3	4c 4a 40	jmp $404a		jmp next
.51c6					w_digit:
>51c6	05					.byte $05
>51c7	64 69 67 69 74				.text 'digit'
>51cc	00 00 00 00 00 00 00 00			.fill 11,0
>51d4	00 00 00
>51d7	47 51					.word w_x28findx29
.51d9					xt_digit:
.51d9	b5 04		lda $04,x		lda pstack+4,x          ; Get the character in A
.51db	c9 61		cmp #$61		cmp #'a'
.51dd	90 06		bcc $51e5		blt get_base
.51df	c9 7b		cmp #$7b		cmp #'z'+1
.51e1	b0 02		bcs $51e5		bge get_base
.51e3	29 df		and #$df		and #$df               ; Turn off the case bit
.51e5						get_base:
.51e5	b4 02		ldy $02,x		ldy pstack+2,x          ; Get the base into Y
.51e7	88		dey			dey
.51e8						loop:
.51e8	d9 08 52	cmp $5208,y		cmp digits,y            ; Check to see if we have a match
.51eb	f0 0e		beq $51fb		beq found               ; If so: return the number
.51ed	88		dey			dey                     ; Move to the previous digit
.51ee	c0 ff		cpy #$ff		cpy #$ff                ; Have we checked the first digit?
.51f0	d0 f6		bne $51e8		bne loop                ; No: check against this digit
.51f2						not_found:
.51f2	e8		inx			inx                     ; Clean up the stack
.51f3	e8		inx			inx
.51f4	74 03		stz $03,x		stz pstack+3,x          ; Return false
.51f6	74 02		stz $02,x		stz pstack+2,x
.51f8	4c 4a 40	jmp $404a		jmp next
.51fb						found:
.51fb	74 05		stz $05,x		stz pstack+5,x          ; Return the value of the digit
.51fd	94 04		sty $04,x		sty pstack+4,x
.51ff	a9 ff		lda #$ff		lda #$ff                ; And the true flag
.5201	95 03		sta $03,x		sta pstack+3,x
.5203	95 02		sta $02,x		sta pstack+2,x
.5205	4c 4a 40	jmp $404a		jmp next
.5208						digits:
>5208	30 31 32 33 34 35 36 37			.text "0123456789ABCDEF"
>5210	38 39 41 42 43 44 45 46
.5218					w_bs:
>5218	02					.byte $02
>5219	62 73					.text 'bs'
>521b	00 00 00 00 00 00 00 00			.fill 14,0
>5223	00 00 00 00 00 00
>5229	c6 51					.word w_digit
.522b					xt_bs:
.522b	4c 6d 4e	jmp $4e6d		jmp xt_x28constantx29
>522e	08 00					.word 8
.5230					w_nl:
>5230	02					.byte $02
>5231	6e 6c					.text 'nl'
>5233	00 00 00 00 00 00 00 00			.fill 14,0
>523b	00 00 00 00 00 00
>5241	18 52					.word w_bs
.5243					xt_nl:
.5243	4c 6d 4e	jmp $4e6d		jmp xt_x28constantx29
>5246	0d 00					.word 13
.5248					w_bl:
>5248	02					.byte $02
>5249	62 6c					.text 'bl'
>524b	00 00 00 00 00 00 00 00			.fill 14,0
>5253	00 00 00 00 00 00
>5259	30 52					.word w_nl
.525b					xt_bl:
.525b	4c 6d 4e	jmp $4e6d		jmp xt_x28constantx29
>525e	20 00					.word 32
.5260					w_s0:
>5260	02					.byte $02
>5261	73 30					.text 's0'
>5263	00 00 00 00 00 00 00 00			.fill 14,0
>526b	00 00 00 00 00 00
>5271	48 52					.word w_bl
.5273					xt_s0:
.5273	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>5276	00 00					.word 0
.5278					w_r0:
>5278	02					.byte $02
>5279	72 30					.text 'r0'
>527b	00 00 00 00 00 00 00 00			.fill 14,0
>5283	00 00 00 00 00 00
>5289	60 52					.word w_s0
.528b					xt_r0:
.528b	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>528e	02 00					.word 2
.5290					w_base:
>5290	04					.byte $04
>5291	62 61 73 65				.text 'base'
>5295	00 00 00 00 00 00 00 00			.fill 12,0
>529d	00 00 00 00
>52a1	78 52					.word w_r0
.52a3					xt_base:
.52a3	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>52a6	04 00					.word 4
.52a8					w_state:
>52a8	05					.byte $05
>52a9	73 74 61 74 65				.text 'state'
>52ae	00 00 00 00 00 00 00 00			.fill 11,0
>52b6	00 00 00
>52b9	90 52					.word w_base
.52bb					xt_state:
.52bb	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>52be	06 00					.word 6
.52c0					w_context:
>52c0	07					.byte $07
>52c1	63 6f 6e 74 65 78 74			.text 'context'
>52c8	00 00 00 00 00 00 00 00			.fill 9,0
>52d0	00
>52d1	a8 52					.word w_state
.52d3					xt_context:
.52d3	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>52d6	08 00					.word 8
.52d8					w_current:
>52d8	07					.byte $07
>52d9	63 75 72 72 65 6e 74			.text 'current'
>52e0	00 00 00 00 00 00 00 00			.fill 9,0
>52e8	00
>52e9	c0 52					.word w_context
.52eb					xt_current:
.52eb	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>52ee	0a 00					.word 10
.52f0					w_dp:
>52f0	02					.byte $02
>52f1	64 70					.text 'dp'
>52f3	00 00 00 00 00 00 00 00			.fill 14,0
>52fb	00 00 00 00 00 00
>5301	d8 52					.word w_current
.5303					xt_dp:
.5303	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>5306	0c 00					.word 12
.5308					w_x3ein:
>5308	03					.byte $03
>5309	3e 69 6e				.text '>in'
>530c	00 00 00 00 00 00 00 00			.fill 13,0
>5314	00 00 00 00 00
>5319	f0 52					.word w_dp
.531b					xt_x3ein:
.531b	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>531e	0e 00					.word 14
.5320					w_tib:
>5320	03					.byte $03
>5321	74 69 62				.text 'tib'
>5324	00 00 00 00 00 00 00 00			.fill 13,0
>532c	00 00 00 00 00
>5331	08 53					.word w_x3ein
.5333					xt_tib:
.5333	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>5336	10 00					.word 16
.5338					w_sourcex2did:
>5338	09					.byte $09
>5339	73 6f 75 72 63 65 2d 69			.text 'source-id'
>5341	64
>5342	00 00 00 00 00 00 00			.fill 7,0
>5349	20 53					.word w_tib
.534b					xt_sourcex2did:
.534b	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>534e	12 00					.word 18
.5350					w_blk:
>5350	03					.byte $03
>5351	62 6c 6b				.text 'blk'
>5354	00 00 00 00 00 00 00 00			.fill 13,0
>535c	00 00 00 00 00
>5361	38 53					.word w_sourcex2did
.5363					xt_blk:
.5363	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>5366	14 00					.word 20
.5368					w_dpl:
>5368	03					.byte $03
>5369	64 70 6c				.text 'dpl'
>536c	00 00 00 00 00 00 00 00			.fill 13,0
>5374	00 00 00 00 00
>5379	50 53					.word w_blk
.537b					xt_dpl:
.537b	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>537e	16 00					.word 22
.5380					w_hld:
>5380	03					.byte $03
>5381	68 6c 64				.text 'hld'
>5384	00 00 00 00 00 00 00 00			.fill 13,0
>538c	00 00 00 00 00
>5391	68 53					.word w_dpl
.5393					xt_hld:
.5393	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>5396	18 00					.word 24
.5398					w_handler:
>5398	07					.byte $07
>5399	68 61 6e 64 6c 65 72			.text 'handler'
>53a0	00 00 00 00 00 00 00 00			.fill 9,0
>53a8	00
>53a9	80 53					.word w_hld
.53ab					xt_handler:
.53ab	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>53ae	1a 00					.word 26
.53b0					w_csp:
>53b0	03					.byte $03
>53b1	63 73 70				.text 'csp'
>53b4	00 00 00 00 00 00 00 00			.fill 13,0
>53bc	00 00 00 00 00
>53c1	98 53					.word w_handler
.53c3					xt_csp:
.53c3	4c a8 4e	jmp $4ea8		jmp xt_x28userx29
>53c6	1c 00					.word 28
.53c8					w_pad:
>53c8	03					.byte $03
>53c9	70 61 64				.text 'pad'
>53cc	00 00 00 00 00 00 00 00			.fill 13,0
>53d4	00 00 00 00 00
>53d9	b0 53					.word w_csp
.53db					xt_pad:
.53db	4c f7 42	jmp $42f7		jmp xt_enter
>53de	03 53					.word xt_dp
>53e0	14 48					.word xt_x40
>53e2	05 46					.word xt_x28literalx29
>53e4	00 01					.word 256
>53e6	4c 4a					.word xt_x2b
>53e8	db 42					.word xt_exit
.53ea					w_x5b:
>53ea	c1					.byte $C1
>53eb	5b					.text '['
>53ec	00 00 00 00 00 00 00 00			.fill 15,0
>53f4	00 00 00 00 00 00 00
>53fb	c8 53					.word w_pad
.53fd					xt_x5b:
.53fd	4c f7 42	jmp $42f7		jmp xt_enter
>5400	71 45					.word xt_0
>5402	bb 52					.word xt_state
>5404	e8 47					.word xt_x21
>5406	db 42					.word xt_exit
.5408					w_x5d:
>5408	c1					.byte $C1
>5409	5d					.text ']'
>540a	00 00 00 00 00 00 00 00			.fill 15,0
>5412	00 00 00 00 00 00 00
>5419	ea 53					.word w_x5b
.541b					xt_x5d:
.541b	4c f7 42	jmp $42f7		jmp xt_enter
>541e	05 46					.word xt_x28literalx29
>5420	c0 00					.word 192
>5422	bb 52					.word xt_state
>5424	e8 47					.word xt_x21
>5426	db 42					.word xt_exit
.5428					w_x3fdup:
>5428	04					.byte $04
>5429	3f 64 75 70				.text '?dup'
>542d	00 00 00 00 00 00 00 00			.fill 12,0
>5435	00 00 00 00
>5439	08 54					.word w_x5d
.543b					xt_x3fdup:
.543b	4c f7 42	jmp $42f7		jmp xt_enter
>543e	a7 46					.word xt_dup
>5440	f4 4e					.word xt_x28branch0x29
>5442	46 54					.word l_1
>5444	a7 46					.word xt_dup
.5446					l_1:
>5446	db 42					.word xt_exit
.5448					w_rot:
>5448	03					.byte $03
>5449	72 6f 74				.text 'rot'
>544c	00 00 00 00 00 00 00 00			.fill 13,0
>5454	00 00 00 00 00
>5459	28 54					.word w_x3fdup
.545b					xt_rot:
.545b	4c f7 42	jmp $42f7		jmp xt_enter
>545e	75 47					.word xt_x3er
>5460	c7 46					.word xt_swap
>5462	93 47					.word xt_rx3e
>5464	c7 46					.word xt_swap
>5466	db 42					.word xt_exit
.5468					w_2dup:
>5468	04					.byte $04
>5469	32 64 75 70				.text '2dup'
>546d	00 00 00 00 00 00 00 00			.fill 12,0
>5475	00 00 00 00
>5479	48 54					.word w_rot
.547b					xt_2dup:
.547b	4c f7 42	jmp $42f7		jmp xt_enter
>547e	2b 47					.word xt_over
>5480	2b 47					.word xt_over
>5482	db 42					.word xt_exit
.5484					w_2drop:
>5484	05					.byte $05
>5485	32 64 72 6f 70				.text '2drop'
>548a	00 00 00 00 00 00 00 00			.fill 11,0
>5492	00 00 00
>5495	68 54					.word w_2dup
.5497					xt_2drop:
.5497	4c f7 42	jmp $42f7		jmp xt_enter
>549a	8f 46					.word xt_drop
>549c	8f 46					.word xt_drop
>549e	db 42					.word xt_exit
.54a0					w_x3c:
>54a0	01					.byte $01
>54a1	3c					.text '<'
>54a2	00 00 00 00 00 00 00 00			.fill 15,0
>54aa	00 00 00 00 00 00 00
>54b1	84 54					.word w_2drop
.54b3					xt_x3c:
.54b3	4c f7 42	jmp $42f7		jmp xt_enter
>54b6	d7 4a					.word xt_x2d
>54b8	c9 4d					.word xt_0x3c
>54ba	db 42					.word xt_exit
.54bc					w_x3e:
>54bc	01					.byte $01
>54bd	3e					.text '>'
>54be	00 00 00 00 00 00 00 00			.fill 15,0
>54c6	00 00 00 00 00 00 00
>54cd	a0 54					.word w_x3c
.54cf					xt_x3e:
.54cf	4c f7 42	jmp $42f7		jmp xt_enter
>54d2	d7 4a					.word xt_x2d
>54d4	1b 4e					.word xt_0x3e
>54d6	db 42					.word xt_exit
.54d8					w_x3d:
>54d8	01					.byte $01
>54d9	3d					.text '='
>54da	00 00 00 00 00 00 00 00			.fill 15,0
>54e2	00 00 00 00 00 00 00
>54e9	bc 54					.word w_x3e
.54eb					xt_x3d:
.54eb	4c f7 42	jmp $42f7		jmp xt_enter
>54ee	d7 4a					.word xt_x2d
>54f0	f0 4d					.word xt_0x3d
>54f2	db 42					.word xt_exit
.54f4					w_dx3c:
>54f4	02					.byte $02
>54f5	64 3c					.text 'd<'
>54f7	00 00 00 00 00 00 00 00			.fill 14,0
>54ff	00 00 00 00 00 00
>5505	d8 54					.word w_x3d
.5507					xt_dx3c:
.5507	4c f7 42	jmp $42f7		jmp xt_enter
>550a	a4 4a					.word xt_dx2d
>550c	8f 46					.word xt_drop
>550e	c9 4d					.word xt_0x3c
>5510	db 42					.word xt_exit
.5512					w_abs:
>5512	03					.byte $03
>5513	61 62 73				.text 'abs'
>5516	00 00 00 00 00 00 00 00			.fill 13,0
>551e	00 00 00 00 00
>5523	f4 54					.word w_dx3c
.5525					xt_abs:
.5525	4c f7 42	jmp $42f7		jmp xt_enter
>5528	a7 46					.word xt_dup
>552a	c9 4d					.word xt_0x3c
>552c	f4 4e					.word xt_x28branch0x29
>552e	36 55					.word l_2
>5530	71 45					.word xt_0
>5532	c7 46					.word xt_swap
>5534	d7 4a					.word xt_x2d
.5536					l_2:
>5536	db 42					.word xt_exit
.5538					w_dabs:
>5538	04					.byte $04
>5539	64 61 62 73				.text 'dabs'
>553d	00 00 00 00 00 00 00 00			.fill 12,0
>5545	00 00 00 00
>5549	12 55					.word w_abs
.554b					xt_dabs:
.554b	4c f7 42	jmp $42f7		jmp xt_enter
>554e	2b 47					.word xt_over
>5550	c9 4d					.word xt_0x3c
>5552	f4 4e					.word xt_x28branch0x29
>5554	5e 55					.word l_3
>5556	71 45					.word xt_0
>5558	71 45					.word xt_0
>555a	ed 46					.word xt_2swap
>555c	a4 4a					.word xt_dx2d
.555e					l_3:
>555e	db 42					.word xt_exit
.5560					w_x2fmod:
>5560	04					.byte $04
>5561	2f 6d 6f 64				.text '/mod'
>5565	00 00 00 00 00 00 00 00			.fill 12,0
>556d	00 00 00 00
>5571	38 55					.word w_dabs
.5573					xt_x2fmod:
.5573	4c f7 42	jmp $42f7		jmp xt_enter
>5576	db 42					.word xt_exit
.5578					w_x2f:
>5578	01					.byte $01
>5579	2f					.text '/'
>557a	00 00 00 00 00 00 00 00			.fill 15,0
>5582	00 00 00 00 00 00 00
>5589	60 55					.word w_x2fmod
.558b					xt_x2f:
.558b	4c f7 42	jmp $42f7		jmp xt_enter
>558e	73 55					.word xt_x2fmod
>5590	c7 46					.word xt_swap
>5592	8f 46					.word xt_drop
>5594	db 42					.word xt_exit
.5596					w_mod:
>5596	03					.byte $03
>5597	6d 6f 64				.text 'mod'
>559a	00 00 00 00 00 00 00 00			.fill 13,0
>55a2	00 00 00 00 00
>55a7	78 55					.word w_x2f
.55a9					xt_mod:
.55a9	4c f7 42	jmp $42f7		jmp xt_enter
>55ac	73 55					.word xt_x2fmod
>55ae	8f 46					.word xt_drop
>55b0	db 42					.word xt_exit
.55b2					w_max:
>55b2	03					.byte $03
>55b3	6d 61 78				.text 'max'
>55b6	00 00 00 00 00 00 00 00			.fill 13,0
>55be	00 00 00 00 00
>55c3	96 55					.word w_mod
.55c5					xt_max:
.55c5	4c f7 42	jmp $42f7		jmp xt_enter
>55c8	7b 54					.word xt_2dup
>55ca	b3 54					.word xt_x3c
>55cc	f4 4e					.word xt_x28branch0x29
>55ce	d8 55					.word l_4
>55d0	2b 47					.word xt_over
>55d2	8f 46					.word xt_drop
>55d4	d0 4e					.word xt_x28branchx29
>55d6	da 55					.word l_5
.55d8					l_4:
>55d8	8f 46					.word xt_drop
.55da					l_5:
>55da	db 42					.word xt_exit
.55dc					w_min:
>55dc	03					.byte $03
>55dd	6d 69 6e				.text 'min'
>55e0	00 00 00 00 00 00 00 00			.fill 13,0
>55e8	00 00 00 00 00
>55ed	b2 55					.word w_max
.55ef					xt_min:
.55ef	4c f7 42	jmp $42f7		jmp xt_enter
>55f2	7b 54					.word xt_2dup
>55f4	cf 54					.word xt_x3e
>55f6	f4 4e					.word xt_x28branch0x29
>55f8	02 56					.word l_6
>55fa	2b 47					.word xt_over
>55fc	8f 46					.word xt_drop
>55fe	d0 4e					.word xt_x28branchx29
>5600	04 56					.word l_7
.5602					l_6:
>5602	8f 46					.word xt_drop
.5604					l_7:
>5604	db 42					.word xt_exit
.5606					w_lfa:
>5606	03					.byte $03
>5607	6c 66 61				.text 'lfa'
>560a	00 00 00 00 00 00 00 00			.fill 13,0
>5612	00 00 00 00 00
>5617	dc 55					.word w_min
.5619					xt_lfa:
.5619	4c f7 42	jmp $42f7		jmp xt_enter
>561c	05 46					.word xt_x28literalx29
>561e	05 00					.word 5
>5620	d7 4a					.word xt_x2d
>5622	db 42					.word xt_exit
.5624					w_cfa:
>5624	03					.byte $03
>5625	63 66 61				.text 'cfa'
>5628	00 00 00 00 00 00 00 00			.fill 13,0
>5630	00 00 00 00 00
>5635	06 56					.word w_lfa
.5637					xt_cfa:
.5637	4c f7 42	jmp $42f7		jmp xt_enter
>563a	05 46					.word xt_x28literalx29
>563c	03 00					.word 3
>563e	d7 4a					.word xt_x2d
>5640	db 42					.word xt_exit
.5642					w_nfa:
>5642	03					.byte $03
>5643	6e 66 61				.text 'nfa'
>5646	00 00 00 00 00 00 00 00			.fill 13,0
>564e	00 00 00 00 00
>5653	24 56					.word w_cfa
.5655					xt_nfa:
.5655	4c f7 42	jmp $42f7		jmp xt_enter
>5658	05 46					.word xt_x28literalx29
>565a	16 00					.word 22
>565c	d7 4a					.word xt_x2d
>565e	db 42					.word xt_exit
.5660					w_pfa:
>5660	03					.byte $03
>5661	70 66 61				.text 'pfa'
>5664	00 00 00 00 00 00 00 00			.fill 13,0
>566c	00 00 00 00 00
>5671	42 56					.word w_nfa
.5673					xt_pfa:
.5673	4c f7 42	jmp $42f7		jmp xt_enter
>5676	05 46					.word xt_x28literalx29
>5678	16 00					.word 22
>567a	4c 4a					.word xt_x2b
>567c	db 42					.word xt_exit
.567e					w_here:
>567e	04					.byte $04
>567f	68 65 72 65				.text 'here'
>5683	00 00 00 00 00 00 00 00			.fill 12,0
>568b	00 00 00 00
>568f	60 56					.word w_pfa
.5691					xt_here:
.5691	4c f7 42	jmp $42f7		jmp xt_enter
>5694	03 53					.word xt_dp
>5696	14 48					.word xt_x40
>5698	db 42					.word xt_exit
.569a					w_allot:
>569a	05					.byte $05
>569b	61 6c 6c 6f 74				.text 'allot'
>56a0	00 00 00 00 00 00 00 00			.fill 11,0
>56a8	00 00 00
>56ab	7e 56					.word w_here
.56ad					xt_allot:
.56ad	4c f7 42	jmp $42f7		jmp xt_enter
>56b0	03 53					.word xt_dp
>56b2	b1 48					.word xt_x2bx21
>56b4	db 42					.word xt_exit
.56b6					w_x2c:
>56b6	01					.byte $01
>56b7	2c					.text ','
>56b8	00 00 00 00 00 00 00 00			.fill 15,0
>56c0	00 00 00 00 00 00 00
>56c7	9a 56					.word w_allot
.56c9					xt_x2c:
.56c9	4c f7 42	jmp $42f7		jmp xt_enter
>56cc	91 56					.word xt_here
>56ce	e8 47					.word xt_x21
>56d0	ab 45					.word xt_2
>56d2	ad 56					.word xt_allot
>56d4	db 42					.word xt_exit
.56d6					w_cx2c:
>56d6	02					.byte $02
>56d7	63 2c					.text 'c,'
>56d9	00 00 00 00 00 00 00 00			.fill 14,0
>56e1	00 00 00 00 00 00
>56e7	b6 56					.word w_x2c
.56e9					xt_cx2c:
.56e9	4c f7 42	jmp $42f7		jmp xt_enter
>56ec	91 56					.word xt_here
>56ee	3c 48					.word xt_cx21
>56f0	8d 45					.word xt_1
>56f2	ad 56					.word xt_allot
>56f4	db 42					.word xt_exit
.56f6					w_definitions:
>56f6	0b					.byte $0B
>56f7	64 65 66 69 6e 69 74 69			.text 'definitions'
>56ff	6f 6e 73
>5702	00 00 00 00 00				.fill 5,0
>5707	d6 56					.word w_cx2c
.5709					xt_definitions:
.5709	4c f7 42	jmp $42f7		jmp xt_enter
>570c	d3 52					.word xt_context
>570e	14 48					.word xt_x40
>5710	eb 52					.word xt_current
>5712	e8 47					.word xt_x21
>5714	db 42					.word xt_exit
.5716					w_latest:
>5716	06					.byte $06
>5717	6c 61 74 65 73 74			.text 'latest'
>571d	00 00 00 00 00 00 00 00			.fill 10,0
>5725	00 00
>5727	f6 56					.word w_definitions
.5729					xt_latest:
.5729	4c f7 42	jmp $42f7		jmp xt_enter
>572c	eb 52					.word xt_current
>572e	14 48					.word xt_x40
>5730	14 48					.word xt_x40
>5732	db 42					.word xt_exit
.5734					w_count:
>5734	05					.byte $05
>5735	63 6f 75 6e 74				.text 'count'
>573a	00 00 00 00 00 00 00 00			.fill 11,0
>5742	00 00 00
>5745	16 57					.word w_latest
.5747					xt_count:
.5747	4c f7 42	jmp $42f7		jmp xt_enter
>574a	a7 46					.word xt_dup
>574c	bb 4c					.word xt_1x2b
>574e	c7 46					.word xt_swap
>5750	5a 48					.word xt_cx40
>5752	db 42					.word xt_exit
.5754					w_type:
>5754	04					.byte $04
>5755	74 79 70 65				.text 'type'
>5759	00 00 00 00 00 00 00 00			.fill 12,0
>5761	00 00 00 00
>5765	34 57					.word w_count
.5767					xt_type:
.5767	4c f7 42	jmp $42f7		jmp xt_enter
>576a	3b 54					.word xt_x3fdup
>576c	f4 4e					.word xt_x28branch0x29
>576e	92 57					.word l_8
>5770	2b 47					.word xt_over
>5772	4c 4a					.word xt_x2b
>5774	c7 46					.word xt_swap
>5776	31 4f					.word xt_x28dox29
.5778					l_9:
>5778	83 50					.word xt_i
>577a	5a 48					.word xt_cx40
>577c	3b 54					.word xt_x3fdup
>577e	f4 4e					.word xt_x28branch0x29
>5780	88 57					.word l_11
>5782	e5 44					.word xt_emit
>5784	d0 4e					.word xt_x28branchx29
>5786	8a 57					.word l_12
.5788					l_11:
>5788	87 4f					.word xt_leave
.578a					l_12:
>578a	ae 4f					.word xt_x28loopx29
>578c	78 57					.word l_9
.578e					l_10:
>578e	d0 4e					.word xt_x28branchx29
>5790	94 57					.word l_13
.5792					l_8:
>5792	8f 46					.word xt_drop
.5794					l_13:
>5794	db 42					.word xt_exit
.5796					w_x28x2ex22x29:
>5796	04					.byte $04
>5797	28 2e 22 29				.text '(.")'
>579b	00 00 00 00 00 00 00 00			.fill 12,0
>57a3	00 00 00 00
>57a7	54 57					.word w_type
.57a9					xt_x28x2ex22x29:
.57a9	4c f7 42	jmp $42f7		jmp xt_enter
>57ac	b1 47					.word xt_r
>57ae	47 57					.word xt_count
>57b0	a7 46					.word xt_dup
>57b2	bb 4c					.word xt_1x2b
>57b4	93 47					.word xt_rx3e
>57b6	4c 4a					.word xt_x2b
>57b8	75 47					.word xt_x3er
>57ba	67 57					.word xt_type
>57bc	db 42					.word xt_exit
.57be					w_space:
>57be	05					.byte $05
>57bf	73 70 61 63 65				.text 'space'
>57c4	00 00 00 00 00 00 00 00			.fill 11,0
>57cc	00 00 00
>57cf	96 57					.word w_x28x2ex22x29
.57d1					xt_space:
.57d1	4c f7 42	jmp $42f7		jmp xt_enter
>57d4	05 46					.word xt_x28literalx29
>57d6	20 00					.word 32
>57d8	e5 44					.word xt_emit
>57da	db 42					.word xt_exit
.57dc					w_spaces:
>57dc	06					.byte $06
>57dd	73 70 61 63 65 73			.text 'spaces'
>57e3	00 00 00 00 00 00 00 00			.fill 10,0
>57eb	00 00
>57ed	be 57					.word w_space
.57ef					xt_spaces:
.57ef	4c f7 42	jmp $42f7		jmp xt_enter
>57f2	a7 46					.word xt_dup
>57f4	1b 4e					.word xt_0x3e
>57f6	f4 4e					.word xt_x28branch0x29
>57f8	08 58					.word l_14
>57fa	71 45					.word xt_0
>57fc	31 4f					.word xt_x28dox29
.57fe					l_15:
>57fe	d1 57					.word xt_space
>5800	ae 4f					.word xt_x28loopx29
>5802	fe 57					.word l_15
.5804					l_16:
>5804	d0 4e					.word xt_x28branchx29
>5806	0a 58					.word l_17
.5808					l_14:
>5808	8f 46					.word xt_drop
.580a					l_17:
>580a	db 42					.word xt_exit
.580c					w_expect:
>580c	06					.byte $06
>580d	65 78 70 65 63 74			.text 'expect'
>5813	00 00 00 00 00 00 00 00			.fill 10,0
>581b	00 00
>581d	dc 57					.word w_spaces
.581f					xt_expect:
.581f	4c f7 42	jmp $42f7		jmp xt_enter
>5822	2b 47					.word xt_over
>5824	4c 4a					.word xt_x2b
>5826	2b 47					.word xt_over
>5828	31 4f					.word xt_x28dox29
.582a					l_18:
>582a	2f 45					.word xt_key
>582c	2b 52					.word xt_bs
>582e	aa 50					.word xt_x28ofx29
>5830	5c 58					.word l_21
>5832	a7 46					.word xt_dup
>5834	83 50					.word xt_i
>5836	eb 54					.word xt_x3d
>5838	a7 4d					.word xt_not
>583a	f4 4e					.word xt_x28branch0x29
>583c	58 58					.word l_22
>583e	2b 52					.word xt_bs
>5840	e5 44					.word xt_emit
>5842	5b 52					.word xt_bl
>5844	e5 44					.word xt_emit
>5846	2b 52					.word xt_bs
>5848	e5 44					.word xt_emit
>584a	71 45					.word xt_0
>584c	83 50					.word xt_i
>584e	fa 4c					.word xt_1x2d
>5850	3c 48					.word xt_cx21
>5852	83 50					.word xt_i
>5854	18 4d					.word xt_2x2d
>5856	58 4f					.word xt_x3ei
.5858					l_22:
>5858	d0 4e					.word xt_x28branchx29
>585a	82 58					.word l_20
.585c					l_21:
>585c	43 52					.word xt_nl
>585e	aa 50					.word xt_x28ofx29
>5860	6e 58					.word l_23
>5862	71 45					.word xt_0
>5864	83 50					.word xt_i
>5866	3c 48					.word xt_cx21
>5868	87 4f					.word xt_leave
>586a	d0 4e					.word xt_x28branchx29
>586c	82 58					.word l_20
.586e					l_23:
>586e	a7 46					.word xt_dup
>5870	a7 46					.word xt_dup
>5872	83 50					.word xt_i
>5874	3c 48					.word xt_cx21
>5876	71 45					.word xt_0
>5878	83 50					.word xt_i
>587a	bb 4c					.word xt_1x2b
>587c	3c 48					.word xt_cx21
>587e	e5 44					.word xt_emit
>5880	8f 46					.word xt_drop
.5882					l_20:
>5882	ae 4f					.word xt_x28loopx29
>5884	2a 58					.word l_18
.5886					l_19:
>5886	8f 46					.word xt_drop
>5888	db 42					.word xt_exit
.588a					w_query:
>588a	05					.byte $05
>588b	71 75 65 72 79				.text 'query'
>5890	00 00 00 00 00 00 00 00			.fill 11,0
>5898	00 00 00
>589b	0c 58					.word w_expect
.589d					xt_query:
.589d	4c f7 42	jmp $42f7		jmp xt_enter
>58a0	33 53					.word xt_tib
>58a2	14 48					.word xt_x40
>58a4	05 46					.word xt_x28literalx29
>58a6	50 00					.word 80
>58a8	1f 58					.word xt_expect
>58aa	71 45					.word xt_0
>58ac	1b 53					.word xt_x3ein
>58ae	e8 47					.word xt_x21
>58b0	db 42					.word xt_exit
.58b2					w_erase:
>58b2	05					.byte $05
>58b3	65 72 61 73 65				.text 'erase'
>58b8	00 00 00 00 00 00 00 00			.fill 11,0
>58c0	00 00 00
>58c3	8a 58					.word w_query
.58c5					xt_erase:
.58c5	4c f7 42	jmp $42f7		jmp xt_enter
>58c8	71 45					.word xt_0
>58ca	76 48					.word xt_fill
>58cc	db 42					.word xt_exit
.58ce					w_blanks:
>58ce	06					.byte $06
>58cf	62 6c 61 6e 6b 73			.text 'blanks'
>58d5	00 00 00 00 00 00 00 00			.fill 10,0
>58dd	00 00
>58df	b2 58					.word w_erase
.58e1					xt_blanks:
.58e1	4c f7 42	jmp $42f7		jmp xt_enter
>58e4	5b 52					.word xt_bl
>58e6	76 48					.word xt_fill
>58e8	db 42					.word xt_exit
.58ea					w_word:
>58ea	04					.byte $04
>58eb	77 6f 72 64				.text 'word'
>58ef	00 00 00 00 00 00 00 00			.fill 12,0
>58f7	00 00 00 00
>58fb	ce 58					.word w_blanks
.58fd					xt_word:
.58fd	4c f7 42	jmp $42f7		jmp xt_enter
>5900	33 53					.word xt_tib
>5902	14 48					.word xt_x40
>5904	1b 53					.word xt_x3ein
>5906	14 48					.word xt_x40
>5908	4c 4a					.word xt_x2b
>590a	c7 46					.word xt_swap
>590c	e2 48					.word xt_enclose
>590e	71 45					.word xt_0
>5910	91 56					.word xt_here
>5912	e8 47					.word xt_x21
>5914	1b 53					.word xt_x3ein
>5916	b1 48					.word xt_x2bx21
>5918	2b 47					.word xt_over
>591a	d7 4a					.word xt_x2d
>591c	75 47					.word xt_x3er
>591e	b1 47					.word xt_r
>5920	91 56					.word xt_here
>5922	3c 48					.word xt_cx21
>5924	4c 4a					.word xt_x2b
>5926	91 56					.word xt_here
>5928	bb 4c					.word xt_1x2b
>592a	93 47					.word xt_rx3e
>592c	58 49					.word xt_cmove
>592e	5b 52					.word xt_bl
>5930	91 56					.word xt_here
>5932	47 57					.word xt_count
>5934	4c 4a					.word xt_x2b
>5936	3c 48					.word xt_cx21
>5938	db 42					.word xt_exit
.593a					w_x2dfind:
>593a	05					.byte $05
>593b	2d 66 69 6e 64				.text '-find'
>5940	00 00 00 00 00 00 00 00			.fill 11,0
>5948	00 00 00
>594b	ea 58					.word w_word
.594d					xt_x2dfind:
.594d	4c f7 42	jmp $42f7		jmp xt_enter
>5950	5b 52					.word xt_bl
>5952	fd 58					.word xt_word
>5954	91 56					.word xt_here
>5956	d3 52					.word xt_context
>5958	14 48					.word xt_x40
>595a	14 48					.word xt_x40
>595c	5a 51					.word xt_x28findx29
>595e	a7 46					.word xt_dup
>5960	f0 4d					.word xt_0x3d
>5962	f4 4e					.word xt_x28branch0x29
>5964	6e 59					.word l_24
>5966	8f 46					.word xt_drop
>5968	91 56					.word xt_here
>596a	29 57					.word xt_latest
>596c	5a 51					.word xt_x28findx29
.596e					l_24:
>596e	db 42					.word xt_exit
.5970					w_decimal:
>5970	07					.byte $07
>5971	64 65 63 69 6d 61 6c			.text 'decimal'
>5978	00 00 00 00 00 00 00 00			.fill 9,0
>5980	00
>5981	3a 59					.word w_x2dfind
.5983					xt_decimal:
.5983	4c f7 42	jmp $42f7		jmp xt_enter
>5986	05 46					.word xt_x28literalx29
>5988	0a 00					.word 10
>598a	a3 52					.word xt_base
>598c	e8 47					.word xt_x21
>598e	db 42					.word xt_exit
.5990					w_hex:
>5990	03					.byte $03
>5991	68 65 78				.text 'hex'
>5994	00 00 00 00 00 00 00 00			.fill 13,0
>599c	00 00 00 00 00
>59a1	70 59					.word w_decimal
.59a3					xt_hex:
.59a3	4c f7 42	jmp $42f7		jmp xt_enter
>59a6	05 46					.word xt_x28literalx29
>59a8	10 00					.word 16
>59aa	a3 52					.word xt_base
>59ac	e8 47					.word xt_x21
>59ae	db 42					.word xt_exit
.59b0					w_octal:
>59b0	05					.byte $05
>59b1	6f 63 74 61 6c				.text 'octal'
>59b6	00 00 00 00 00 00 00 00			.fill 11,0
>59be	00 00 00
>59c1	90 59					.word w_hex
.59c3					xt_octal:
.59c3	4c f7 42	jmp $42f7		jmp xt_enter
>59c6	05 46					.word xt_x28literalx29
>59c8	08 00					.word 8
>59ca	a3 52					.word xt_base
>59cc	e8 47					.word xt_x21
>59ce	db 42					.word xt_exit
.59d0					w_x2e:
>59d0	01					.byte $01
>59d1	2e					.text '.'
>59d2	00 00 00 00 00 00 00 00			.fill 15,0
>59da	00 00 00 00 00 00 00
>59e1	b0 59					.word w_octal
.59e3					xt_x2e:
.59e3	4c f7 42	jmp $42f7		jmp xt_enter
>59e6	8c 4c					.word xt_sx3ed
>59e8	ff 5b					.word xt_dx2e
>59ea	db 42					.word xt_exit
.59ec					w_x28numberx29:
>59ec	08					.byte $08
>59ed	28 6e 75 6d 62 65 72 29			.text '(number)'
>59f5	00 00 00 00 00 00 00 00			.fill 8,0
>59fd	d0 59					.word w_x2e
.59ff					xt_x28numberx29:
.59ff	4c f7 42	jmp $42f7		jmp xt_enter
.5a02					l_25:
>5a02	a7 46					.word xt_dup
>5a04	75 47					.word xt_x3er
>5a06	5a 48					.word xt_cx40
>5a08	a3 52					.word xt_base
>5a0a	14 48					.word xt_x40
>5a0c	d9 51					.word xt_digit
>5a0e	f4 4e					.word xt_x28branch0x29
>5a10	28 5a					.word l_26
>5a12	75 47					.word xt_x3er
>5a14	a3 52					.word xt_base
>5a16	14 48					.word xt_x40
>5a18	fc 4a					.word xt_ux2a
>5a1a	93 47					.word xt_rx3e
>5a1c	8c 4c					.word xt_sx3ed
>5a1e	71 4a					.word xt_dx2b
>5a20	93 47					.word xt_rx3e
>5a22	bb 4c					.word xt_1x2b
>5a24	d0 4e					.word xt_x28branchx29
>5a26	02 5a					.word l_25
.5a28					l_26:
>5a28	93 47					.word xt_rx3e
>5a2a	db 42					.word xt_exit
.5a2c					w_x3ferror:
>5a2c	06					.byte $06
>5a2d	3f 65 72 72 6f 72			.text '?error'
>5a33	00 00 00 00 00 00 00 00			.fill 10,0
>5a3b	00 00
>5a3d	ec 59					.word w_x28numberx29
.5a3f					xt_x3ferror:
.5a3f	4c f7 42	jmp $42f7		jmp xt_enter
>5a42	c7 46					.word xt_swap
>5a44	f4 4e					.word xt_x28branch0x29
>5a46	4e 5a					.word l_48
>5a48	c1 5d					.word xt_error
>5a4a	d0 4e					.word xt_x28branchx29
>5a4c	50 5a					.word l_49
.5a4e					l_48:
>5a4e	8f 46					.word xt_drop
.5a50					l_49:
>5a50	db 42					.word xt_exit
.5a52					w_number:
>5a52	06					.byte $06
>5a53	6e 75 6d 62 65 72			.text 'number'
>5a59	00 00 00 00 00 00 00 00			.fill 10,0
>5a61	00 00
>5a63	2c 5a					.word w_x3ferror
.5a65					xt_number:
.5a65	4c f7 42	jmp $42f7		jmp xt_enter
>5a68	71 45					.word xt_0
>5a6a	71 45					.word xt_0
>5a6c	5b 54					.word xt_rot
>5a6e	a7 46					.word xt_dup
>5a70	5a 48					.word xt_cx40
>5a72	05 46					.word xt_x28literalx29
>5a74	2d 00					.word 45
>5a76	eb 54					.word xt_x3d
>5a78	f4 4e					.word xt_x28branch0x29
>5a7a	84 5a					.word l_27
>5a7c	8d 45					.word xt_1
>5a7e	75 47					.word xt_x3er
>5a80	d0 4e					.word xt_x28branchx29
>5a82	8c 5a					.word l_28
.5a84					l_27:
>5a84	71 45					.word xt_0
>5a86	75 47					.word xt_x3er
>5a88	8d 45					.word xt_1
>5a8a	4c 4a					.word xt_x2b
.5a8c					l_28:
>5a8c	c9 45					.word xt_x2d1
.5a8e					l_29:
>5a8e	7b 53					.word xt_dpl
>5a90	e8 47					.word xt_x21
>5a92	ff 59					.word xt_x28numberx29
>5a94	a7 46					.word xt_dup
>5a96	5a 48					.word xt_cx40
>5a98	5b 52					.word xt_bl
>5a9a	d7 4a					.word xt_x2d
>5a9c	f4 4e					.word xt_x28branch0x29
>5a9e	ba 5a					.word l_30
>5aa0	a7 46					.word xt_dup
>5aa2	5a 48					.word xt_cx40
>5aa4	05 46					.word xt_x28literalx29
>5aa6	2e 00					.word 46
>5aa8	d7 4a					.word xt_x2d
>5aaa	f4 4e					.word xt_x28branch0x29
>5aac	b4 5a					.word l_31
>5aae	05 46					.word xt_x28literalx29
>5ab0	f3 ff					.word 65523
>5ab2	3f 5a					.word xt_x3ferror
.5ab4					l_31:
>5ab4	71 45					.word xt_0
>5ab6	d0 4e					.word xt_x28branchx29
>5ab8	8e 5a					.word l_29
.5aba					l_30:
>5aba	8f 46					.word xt_drop
>5abc	93 47					.word xt_rx3e
>5abe	f4 4e					.word xt_x28branch0x29
>5ac0	ca 5a					.word l_32
>5ac2	71 45					.word xt_0
>5ac4	71 45					.word xt_0
>5ac6	ed 46					.word xt_2swap
>5ac8	a4 4a					.word xt_dx2d
.5aca					l_32:
>5aca	db 42					.word xt_exit
.5acc					w_x3cx23:
>5acc	02					.byte $02
>5acd	3c 23					.text '<#'
>5acf	00 00 00 00 00 00 00 00			.fill 14,0
>5ad7	00 00 00 00 00 00
>5add	52 5a					.word w_number
.5adf					xt_x3cx23:
.5adf	4c f7 42	jmp $42f7		jmp xt_enter
>5ae2	db 53					.word xt_pad
>5ae4	93 53					.word xt_hld
>5ae6	e8 47					.word xt_x21
>5ae8	db 42					.word xt_exit
.5aea					w_hold:
>5aea	04					.byte $04
>5aeb	68 6f 6c 64				.text 'hold'
>5aef	00 00 00 00 00 00 00 00			.fill 12,0
>5af7	00 00 00 00
>5afb	cc 5a					.word w_x3cx23
.5afd					xt_hold:
.5afd	4c f7 42	jmp $42f7		jmp xt_enter
>5b00	c9 45					.word xt_x2d1
>5b02	93 53					.word xt_hld
>5b04	b1 48					.word xt_x2bx21
>5b06	93 53					.word xt_hld
>5b08	14 48					.word xt_x40
>5b0a	3c 48					.word xt_cx21
>5b0c	db 42					.word xt_exit
.5b0e					w_x23:
>5b0e	01					.byte $01
>5b0f	23					.text '#'
>5b10	00 00 00 00 00 00 00 00			.fill 15,0
>5b18	00 00 00 00 00 00 00
>5b1f	ea 5a					.word w_hold
.5b21					xt_x23:
.5b21	4c f7 42	jmp $42f7		jmp xt_enter
>5b24	a3 52					.word xt_base
>5b26	14 48					.word xt_x40
>5b28	31 4c					.word xt_umx2fmod
>5b2a	8c 4c					.word xt_sx3ed
>5b2c	5b 54					.word xt_rot
>5b2e	05 46					.word xt_x28literalx29
>5b30	09 00					.word 9
>5b32	2b 47					.word xt_over
>5b34	b3 54					.word xt_x3c
>5b36	f4 4e					.word xt_x28branch0x29
>5b38	40 5b					.word l_33
>5b3a	05 46					.word xt_x28literalx29
>5b3c	07 00					.word 7
>5b3e	4c 4a					.word xt_x2b
.5b40					l_33:
>5b40	05 46					.word xt_x28literalx29
>5b42	30 00					.word 48
>5b44	4c 4a					.word xt_x2b
>5b46	fd 5a					.word xt_hold
>5b48	db 42					.word xt_exit
.5b4a					w_x23s:
>5b4a	02					.byte $02
>5b4b	23 73					.text '#s'
>5b4d	00 00 00 00 00 00 00 00			.fill 14,0
>5b55	00 00 00 00 00 00
>5b5b	0e 5b					.word w_x23
.5b5d					xt_x23s:
.5b5d	4c f7 42	jmp $42f7		jmp xt_enter
.5b60					l_34:
>5b60	21 5b					.word xt_x23
>5b62	2b 47					.word xt_over
>5b64	2b 47					.word xt_over
>5b66	5f 4d					.word xt_or
>5b68	f0 4d					.word xt_0x3d
>5b6a	f4 4e					.word xt_x28branch0x29
>5b6c	60 5b					.word l_34
.5b6e					l_35:
>5b6e	db 42					.word xt_exit
.5b70					w_sign:
>5b70	04					.byte $04
>5b71	73 69 67 6e				.text 'sign'
>5b75	00 00 00 00 00 00 00 00			.fill 12,0
>5b7d	00 00 00 00
>5b81	4a 5b					.word w_x23s
.5b83					xt_sign:
.5b83	4c f7 42	jmp $42f7		jmp xt_enter
>5b86	5b 54					.word xt_rot
>5b88	c9 4d					.word xt_0x3c
>5b8a	f4 4e					.word xt_x28branch0x29
>5b8c	94 5b					.word l_36
>5b8e	05 46					.word xt_x28literalx29
>5b90	2d 00					.word 45
>5b92	fd 5a					.word xt_hold
.5b94					l_36:
>5b94	db 42					.word xt_exit
.5b96					w_x23x3e:
>5b96	02					.byte $02
>5b97	23 3e					.text '#>'
>5b99	00 00 00 00 00 00 00 00			.fill 14,0
>5ba1	00 00 00 00 00 00
>5ba7	70 5b					.word w_sign
.5ba9					xt_x23x3e:
.5ba9	4c f7 42	jmp $42f7		jmp xt_enter
>5bac	97 54					.word xt_2drop
>5bae	93 53					.word xt_hld
>5bb0	14 48					.word xt_x40
>5bb2	db 53					.word xt_pad
>5bb4	2b 47					.word xt_over
>5bb6	d7 4a					.word xt_x2d
>5bb8	db 42					.word xt_exit
.5bba					w_dx2er:
>5bba	03					.byte $03
>5bbb	64 2e 72				.text 'd.r'
>5bbe	00 00 00 00 00 00 00 00			.fill 13,0
>5bc6	00 00 00 00 00
>5bcb	96 5b					.word w_x23x3e
.5bcd					xt_dx2er:
.5bcd	4c f7 42	jmp $42f7		jmp xt_enter
>5bd0	75 47					.word xt_x3er
>5bd2	2b 47					.word xt_over
>5bd4	c7 46					.word xt_swap
>5bd6	4b 55					.word xt_dabs
>5bd8	df 5a					.word xt_x3cx23
>5bda	5d 5b					.word xt_x23s
>5bdc	83 5b					.word xt_sign
>5bde	a9 5b					.word xt_x23x3e
>5be0	93 47					.word xt_rx3e
>5be2	2b 47					.word xt_over
>5be4	d7 4a					.word xt_x2d
>5be6	ef 57					.word xt_spaces
>5be8	67 57					.word xt_type
>5bea	db 42					.word xt_exit
.5bec					w_dx2e:
>5bec	02					.byte $02
>5bed	64 2e					.text 'd.'
>5bef	00 00 00 00 00 00 00 00			.fill 14,0
>5bf7	00 00 00 00 00 00
>5bfd	ba 5b					.word w_dx2er
.5bff					xt_dx2e:
.5bff	4c f7 42	jmp $42f7		jmp xt_enter
>5c02	71 45					.word xt_0
>5c04	cd 5b					.word xt_dx2er
>5c06	db 42					.word xt_exit
.5c08					w_x2er:
>5c08	02					.byte $02
>5c09	2e 72					.text '.r'
>5c0b	00 00 00 00 00 00 00 00			.fill 14,0
>5c13	00 00 00 00 00 00
>5c19	ec 5b					.word w_dx2e
.5c1b					xt_x2er:
.5c1b	4c f7 42	jmp $42f7		jmp xt_enter
>5c1e	75 47					.word xt_x3er
>5c20	8c 4c					.word xt_sx3ed
>5c22	93 47					.word xt_rx3e
>5c24	cd 5b					.word xt_dx2er
>5c26	db 42					.word xt_exit
.5c28					w_x3f:
>5c28	01					.byte $01
>5c29	3f					.text '?'
>5c2a	00 00 00 00 00 00 00 00			.fill 15,0
>5c32	00 00 00 00 00 00 00
>5c39	08 5c					.word w_x2er
.5c3b					xt_x3f:
.5c3b	4c f7 42	jmp $42f7		jmp xt_enter
>5c3e	14 48					.word xt_x40
>5c40	e3 59					.word xt_x2e
>5c42	db 42					.word xt_exit
.5c44					w_dump:
>5c44	04					.byte $04
>5c45	64 75 6d 70				.text 'dump'
>5c49	00 00 00 00 00 00 00 00			.fill 12,0
>5c51	00 00 00 00
>5c55	28 5c					.word w_x3f
.5c57					xt_dump:
.5c57	4c f7 42	jmp $42f7		jmp xt_enter
>5c5a	71 45					.word xt_0
>5c5c	31 4f					.word xt_x28dox29
.5c5e					l_37:
>5c5e	54 45					.word xt_cr
>5c60	a7 46					.word xt_dup
>5c62	71 45					.word xt_0
>5c64	c7 46					.word xt_swap
>5c66	05 46					.word xt_x28literalx29
>5c68	05 00					.word 5
>5c6a	cd 5b					.word xt_dx2er
>5c6c	05 46					.word xt_x28literalx29
>5c6e	3a 00					.word 58
>5c70	e5 44					.word xt_emit
>5c72	05 46					.word xt_x28literalx29
>5c74	08 00					.word 8
>5c76	71 45					.word xt_0
>5c78	31 4f					.word xt_x28dox29
.5c7a					l_39:
>5c7a	a7 46					.word xt_dup
>5c7c	14 48					.word xt_x40
>5c7e	71 45					.word xt_0
>5c80	c7 46					.word xt_swap
>5c82	05 46					.word xt_x28literalx29
>5c84	05 00					.word 5
>5c86	cd 5b					.word xt_dx2er
>5c88	d7 4c					.word xt_2x2b
>5c8a	ae 4f					.word xt_x28loopx29
>5c8c	7a 5c					.word l_39
.5c8e					l_40:
>5c8e	05 46					.word xt_x28literalx29
>5c90	08 00					.word 8
>5c92	0f 50					.word xt_x28x2bloopx29
>5c94	5e 5c					.word l_37
.5c96					l_38:
>5c96	8f 46					.word xt_drop
>5c98	db 42					.word xt_exit
.5c9a					w_interpret:
>5c9a	09					.byte $09
>5c9b	69 6e 74 65 72 70 72 65			.text 'interpret'
>5ca3	74
>5ca4	00 00 00 00 00 00 00			.fill 7,0
>5cab	44 5c					.word w_dump
.5cad					xt_interpret:
.5cad	4c f7 42	jmp $42f7		jmp xt_enter
.5cb0					l_51:
>5cb0	33 53					.word xt_tib
>5cb2	14 48					.word xt_x40
>5cb4	1b 53					.word xt_x3ein
>5cb6	14 48					.word xt_x40
>5cb8	4c 4a					.word xt_x2b
>5cba	5a 48					.word xt_cx40
>5cbc	f4 4e					.word xt_x28branch0x29
>5cbe	fc 5c					.word l_52
>5cc0	4d 59					.word xt_x2dfind
>5cc2	f4 4e					.word xt_x28branch0x29
>5cc4	e0 5c					.word l_53
>5cc6	bb 52					.word xt_state
>5cc8	14 48					.word xt_x40
>5cca	b3 54					.word xt_x3c
>5ccc	f4 4e					.word xt_x28branch0x29
>5cce	d8 5c					.word l_54
>5cd0	37 56					.word xt_cfa
>5cd2	c9 56					.word xt_x2c
>5cd4	d0 4e					.word xt_x28branchx29
>5cd6	dc 5c					.word l_55
.5cd8					l_54:
>5cd8	37 56					.word xt_cfa
>5cda	f0 50					.word xt_execute
.5cdc					l_55:
>5cdc	d0 4e					.word xt_x28branchx29
>5cde	f8 5c					.word l_56
.5ce0					l_53:
>5ce0	91 56					.word xt_here
>5ce2	65 5a					.word xt_number
>5ce4	c7 46					.word xt_swap
>5ce6	8f 46					.word xt_drop
>5ce8	bb 52					.word xt_state
>5cea	14 48					.word xt_x40
>5cec	f4 4e					.word xt_x28branch0x29
>5cee	f8 5c					.word l_57
>5cf0	05 46					.word xt_x28literalx29
>5cf2	05 46					.word xt_x28literalx29
>5cf4	c9 56					.word xt_x2c
>5cf6	c9 56					.word xt_x2c
.5cf8					l_57:
.5cf8					l_56:
>5cf8	d0 4e					.word xt_x28branchx29
>5cfa	b0 5c					.word l_51
.5cfc					l_52:
>5cfc	db 42					.word xt_exit
.5cfe					w_catch:
>5cfe	05					.byte $05
>5cff	63 61 74 63 68				.text 'catch'
>5d04	00 00 00 00 00 00 00 00			.fill 11,0
>5d0c	00 00 00
>5d0f	9a 5c					.word w_interpret
.5d11					xt_catch:
.5d11	4c f7 42	jmp $42f7		jmp xt_enter
>5d14	ad 44					.word xt_spx40
>5d16	75 47					.word xt_x3er
>5d18	ab 53					.word xt_handler
>5d1a	14 48					.word xt_x40
>5d1c	75 47					.word xt_x3er
>5d1e	66 44					.word xt_rpx40
>5d20	ab 53					.word xt_handler
>5d22	e8 47					.word xt_x21
>5d24	f0 50					.word xt_execute
>5d26	93 47					.word xt_rx3e
>5d28	ab 53					.word xt_handler
>5d2a	e8 47					.word xt_x21
>5d2c	93 47					.word xt_rx3e
>5d2e	8f 46					.word xt_drop
>5d30	71 45					.word xt_0
>5d32	db 42					.word xt_exit
.5d34					w_throw:
>5d34	05					.byte $05
>5d35	74 68 72 6f 77				.text 'throw'
>5d3a	00 00 00 00 00 00 00 00			.fill 11,0
>5d42	00 00 00
>5d45	fe 5c					.word w_catch
.5d47					xt_throw:
.5d47	4c f7 42	jmp $42f7		jmp xt_enter
>5d4a	3b 54					.word xt_x3fdup
>5d4c	f4 4e					.word xt_x28branch0x29
>5d4e	68 5d					.word l_41
>5d50	ab 53					.word xt_handler
>5d52	14 48					.word xt_x40
>5d54	8d 44					.word xt_rpx21
>5d56	93 47					.word xt_rx3e
>5d58	ab 53					.word xt_handler
>5d5a	e8 47					.word xt_x21
>5d5c	93 47					.word xt_rx3e
>5d5e	c7 46					.word xt_swap
>5d60	75 47					.word xt_x3er
>5d62	cc 44					.word xt_spx21
>5d64	8f 46					.word xt_drop
>5d66	93 47					.word xt_rx3e
.5d68					l_41:
>5d68	db 42					.word xt_exit
.5d6a					w_quit:
>5d6a	04					.byte $04
>5d6b	71 75 69 74				.text 'quit'
>5d6f	00 00 00 00 00 00 00 00			.fill 12,0
>5d77	00 00 00 00
>5d7b	34 5d					.word w_throw
.5d7d					xt_quit:
.5d7d	4c f7 42	jmp $42f7		jmp xt_enter
>5d80	42 51					.word xt_forth
>5d82	09 57					.word xt_definitions
>5d84	71 45					.word xt_0
>5d86	bb 52					.word xt_state
>5d88	e8 47					.word xt_x21
.5d8a					l_42:
>5d8a	54 45					.word xt_cr
>5d8c	bb 52					.word xt_state
>5d8e	14 48					.word xt_x40
>5d90	f0 4d					.word xt_0x3d
>5d92	f4 4e					.word xt_x28branch0x29
>5d94	a2 5d					.word l_44
>5d96	54 45					.word xt_cr
>5d98	05 46					.word xt_x28literalx29
>5d9a	3e 00					.word 62
>5d9c	e5 44					.word xt_emit
>5d9e	5b 52					.word xt_bl
>5da0	e5 44					.word xt_emit
.5da2					l_44:
>5da2	9d 58					.word xt_query
>5da4	54 45					.word xt_cr
>5da6	ad 5c					.word xt_interpret
>5da8	d0 4e					.word xt_x28branchx29
>5daa	8a 5d					.word l_42
.5dac					l_43:
>5dac	db 42					.word xt_exit
.5dae					w_error:
>5dae	05					.byte $05
>5daf	65 72 72 6f 72				.text 'error'
>5db4	00 00 00 00 00 00 00 00			.fill 11,0
>5dbc	00 00 00
>5dbf	6a 5d					.word w_quit
.5dc1					xt_error:
.5dc1	4c f7 42	jmp $42f7		jmp xt_enter
>5dc4	a7 46					.word xt_dup
>5dc6	f0 4d					.word xt_0x3d
>5dc8	a7 4d					.word xt_not
>5dca	f4 4e					.word xt_x28branch0x29
>5dcc	df 5d					.word l_45
>5dce	91 56					.word xt_here
>5dd0	47 57					.word xt_count
>5dd2	67 57					.word xt_type
>5dd4	a9 57					.word xt_x28x2ex22x29
>5dd6	06 3f 20 4d 53 47 23			.ptext "? MSG#"
>5ddd	e3 59					.word xt_x2e
.5ddf					l_45:
>5ddf	7d 5d					.word xt_quit
>5de1	db 42					.word xt_exit
.5de3					w_x3fcsp:
>5de3	04					.byte $04
>5de4	3f 63 73 70				.text '?csp'
>5de8	00 00 00 00 00 00 00 00			.fill 12,0
>5df0	00 00 00 00
>5df4	ae 5d					.word w_error
.5df6					xt_x3fcsp:
.5df6	4c f7 42	jmp $42f7		jmp xt_enter
>5df9	c3 53					.word xt_csp
>5dfb	14 48					.word xt_x40
>5dfd	ad 44					.word xt_spx40
>5dff	d7 4a					.word xt_x2d
>5e01	f4 4e					.word xt_x28branch0x29
>5e03	0f 5e					.word l_50
>5e05	71 45					.word xt_0
>5e07	05 46					.word xt_x28literalx29
>5e09	19 00					.word 25
>5e0b	d7 4a					.word xt_x2d
>5e0d	c1 5d					.word xt_error
.5e0f					l_50:
>5e0f	db 42					.word xt_exit
.5e11					w_create:
>5e11	06					.byte $06
>5e12	63 72 65 61 74 65			.text 'create'
>5e18	00 00 00 00 00 00 00 00			.fill 10,0
>5e20	00 00
>5e22	e3 5d					.word w_x3fcsp
.5e24					xt_create:
.5e24	4c f7 42	jmp $42f7		jmp xt_enter
>5e27	91 56					.word xt_here
>5e29	5b 52					.word xt_bl
>5e2b	fd 58					.word xt_word
>5e2d	05 46					.word xt_x28literalx29
>5e2f	11 00					.word 17
>5e31	ad 56					.word xt_allot
>5e33	29 57					.word xt_latest
>5e35	c9 56					.word xt_x2c
>5e37	eb 52					.word xt_current
>5e39	14 48					.word xt_x40
>5e3b	e8 47					.word xt_x21
>5e3d	db 42					.word xt_exit
.5e3f					w_x3a:
>5e3f	01					.byte $01
>5e40	3a					.text ':'
>5e41	00 00 00 00 00 00 00 00			.fill 15,0
>5e49	00 00 00 00 00 00 00
>5e50	11 5e					.word w_create
.5e52					xt_x3a:
.5e52	4c f7 42	jmp $42f7		jmp xt_enter
>5e55	eb 52					.word xt_current
>5e57	14 48					.word xt_x40
>5e59	d3 52					.word xt_context
>5e5b	e8 47					.word xt_x21
>5e5d	24 5e					.word xt_create
>5e5f	1b 54					.word xt_x5d
>5e61	05 46					.word xt_x28literalx29
>5e63	4c 00					.word 76
>5e65	e9 56					.word xt_cx2c
>5e67	05 46					.word xt_x28literalx29
>5e69	f7 42					.word xt_enter
>5e6b	c9 56					.word xt_x2c
>5e6d	db 42					.word xt_exit
.5e6f					w_x3b:
>5e6f	c1					.byte $C1
>5e70	3b					.text ';'
>5e71	00 00 00 00 00 00 00 00			.fill 15,0
>5e79	00 00 00 00 00 00 00
>5e80	3f 5e					.word w_x3a
.5e82					xt_x3b:
.5e82	4c f7 42	jmp $42f7		jmp xt_enter
>5e85	05 46					.word xt_x28literalx29
>5e87	db 42					.word xt_exit
>5e89	c9 56					.word xt_x2c
>5e8b	fd 53					.word xt_x5b
>5e8d	db 42					.word xt_exit
.5e8f					w_initrandom:
>5e8f	0a					.byte $0A
>5e90	69 6e 69 74 72 61 6e 64			.text 'initrandom'
>5e98	6f 6d
>5e9a	00 00 00 00 00 00			.fill 6,0
>5ea0	6f 5e					.word w_x3b
.5ea2					xt_initrandom:
.5ea2	4c f7 42	jmp $42f7		jmp xt_enter
>5ea5	8d 45					.word xt_1
>5ea7	05 46					.word xt_x28literalx29
>5ea9	a6 d6					.word 54950
>5eab	3c 48					.word xt_cx21
>5ead	db 42					.word xt_exit
.5eaf					w_random:
>5eaf	06					.byte $06
>5eb0	72 61 6e 64 6f 6d			.text 'random'
>5eb6	00 00 00 00 00 00 00 00			.fill 10,0
>5ebe	00 00
>5ec0	8f 5e					.word w_initrandom
.5ec2					xt_random:
.5ec2	4c f7 42	jmp $42f7		jmp xt_enter
>5ec5	05 46					.word xt_x28literalx29
>5ec7	a4 d6					.word 54948
>5ec9	14 48					.word xt_x40
>5ecb	db 42					.word xt_exit
.5ecd					w_iox2dpage:
>5ecd	07					.byte $07
>5ece	69 6f 2d 70 61 67 65			.text 'io-page'
>5ed5	00 00 00 00 00 00 00 00			.fill 9,0
>5edd	00
>5ede	af 5e					.word w_random
.5ee0					xt_iox2dpage:
.5ee0	4c 6d 4e	jmp $4e6d		jmp xt_x28constantx29
>5ee3	01 00					.word 0001
.5ee5					w_setx2diox2dtext:
>5ee5	0b					.byte $0B
>5ee6	73 65 74 2d 69 6f 2d 74			.text 'set-io-text'
>5eee	65 78 74
>5ef1	00 00 00 00 00				.fill 5,0
>5ef6	cd 5e					.word w_iox2dpage
.5ef8					xt_setx2diox2dtext:
.5ef8	4c f7 42	jmp $42f7		jmp xt_enter
>5efb	ab 45					.word xt_2
>5efd	e0 5e					.word xt_iox2dpage
>5eff	3c 48					.word xt_cx21
>5f01	db 42					.word xt_exit
.5f03					w_setx2diox2dcolor:
>5f03	0c					.byte $0C
>5f04	73 65 74 2d 69 6f 2d 63			.text 'set-io-color'
>5f0c	6f 6c 6f 72
>5f10	00 00 00 00				.fill 4,0
>5f14	e5 5e					.word w_setx2diox2dtext
.5f16					xt_setx2diox2dcolor:
.5f16	4c f7 42	jmp $42f7		jmp xt_enter
>5f19	05 46					.word xt_x28literalx29
>5f1b	03 00					.word 3
>5f1d	e0 5e					.word xt_iox2dpage
>5f1f	3c 48					.word xt_cx21
>5f21	db 42					.word xt_exit
.5f23					w_defx2dtextx2dfgx2dcolor:
>5f23	10					.byte $10
>5f24	64 65 66 2d 74 65 78 74			.text 'def-text-fg-colo'
>5f2c	2d 66 67 2d 63 6f 6c 6f
>5f34						.fill 0,0
>5f34	03 5f					.word w_setx2diox2dcolor
.5f36					xt_defx2dtextx2dfgx2dcolor:
.5f36	4c f7 42	jmp $42f7		jmp xt_enter
>5f39	05 46					.word xt_x28literalx29
>5f3b	0f 00					.word 15
>5f3d	3b 4d					.word xt_and
>5f3f	e0 5e					.word xt_iox2dpage
>5f41	5a 48					.word xt_cx40
>5f43	75 47					.word xt_x3er
>5f45	71 45					.word xt_0
>5f47	e0 5e					.word xt_iox2dpage
>5f49	3c 48					.word xt_cx21
>5f4b	05 46					.word xt_x28literalx29
>5f4d	04 00					.word 4
>5f4f	34 4b					.word xt_x2a
>5f51	05 46					.word xt_x28literalx29
>5f53	00 d8					.word 55296
>5f55	4c 4a					.word xt_x2b
>5f57	a7 46					.word xt_dup
>5f59	05 46					.word xt_x28literalx29
>5f5b	03 00					.word 3
>5f5d	4c 4a					.word xt_x2b
>5f5f	c7 46					.word xt_swap
>5f61	31 4f					.word xt_x28dox29
.5f63					l_58:
>5f63	83 50					.word xt_i
>5f65	3c 48					.word xt_cx21
>5f67	ae 4f					.word xt_x28loopx29
>5f69	63 5f					.word l_58
.5f6b					l_59:
>5f6b	93 47					.word xt_rx3e
>5f6d	e0 5e					.word xt_iox2dpage
>5f6f	3c 48					.word xt_cx21
>5f71	db 42					.word xt_exit
.5f73					w_defx2dtextx2dbgx2dcolor:
>5f73	10					.byte $10
>5f74	64 65 66 2d 74 65 78 74			.text 'def-text-bg-colo'
>5f7c	2d 62 67 2d 63 6f 6c 6f
>5f84						.fill 0,0
>5f84	23 5f					.word w_defx2dtextx2dfgx2dcolor
.5f86					xt_defx2dtextx2dbgx2dcolor:
.5f86	4c f7 42	jmp $42f7		jmp xt_enter
>5f89	05 46					.word xt_x28literalx29
>5f8b	0f 00					.word 15
>5f8d	3b 4d					.word xt_and
>5f8f	e0 5e					.word xt_iox2dpage
>5f91	5a 48					.word xt_cx40
>5f93	75 47					.word xt_x3er
>5f95	71 45					.word xt_0
>5f97	e0 5e					.word xt_iox2dpage
>5f99	3c 48					.word xt_cx21
>5f9b	05 46					.word xt_x28literalx29
>5f9d	04 00					.word 4
>5f9f	34 4b					.word xt_x2a
>5fa1	05 46					.word xt_x28literalx29
>5fa3	40 d8					.word 55360
>5fa5	4c 4a					.word xt_x2b
>5fa7	a7 46					.word xt_dup
>5fa9	05 46					.word xt_x28literalx29
>5fab	03 00					.word 3
>5fad	4c 4a					.word xt_x2b
>5faf	c7 46					.word xt_swap
>5fb1	31 4f					.word xt_x28dox29
.5fb3					l_60:
>5fb3	83 50					.word xt_i
>5fb5	3c 48					.word xt_cx21
>5fb7	ae 4f					.word xt_x28loopx29
>5fb9	b3 5f					.word l_60
.5fbb					l_61:
>5fbb	93 47					.word xt_rx3e
>5fbd	e0 5e					.word xt_iox2dpage
>5fbf	3c 48					.word xt_cx21
>5fc1	db 42					.word xt_exit
.5fc3					w_setx2dborderx2dcolor:
>5fc3	10					.byte $10
>5fc4	73 65 74 2d 62 6f 72 64			.text 'set-border-color'
>5fcc	65 72 2d 63 6f 6c 6f 72
>5fd4						.fill 0,0
>5fd4	73 5f					.word w_defx2dtextx2dbgx2dcolor
.5fd6					xt_setx2dborderx2dcolor:
.5fd6	4c f7 42	jmp $42f7		jmp xt_enter
>5fd9	e0 5e					.word xt_iox2dpage
>5fdb	5a 48					.word xt_cx40
>5fdd	75 47					.word xt_x3er
>5fdf	71 45					.word xt_0
>5fe1	e0 5e					.word xt_iox2dpage
>5fe3	3c 48					.word xt_cx21
>5fe5	05 46					.word xt_x28literalx29
>5fe7	05 d0					.word 53253
>5fe9	3c 48					.word xt_cx21
>5feb	05 46					.word xt_x28literalx29
>5fed	06 d0					.word 53254
>5fef	3c 48					.word xt_cx21
>5ff1	05 46					.word xt_x28literalx29
>5ff3	07 d0					.word 53255
>5ff5	3c 48					.word xt_cx21
>5ff7	93 47					.word xt_rx3e
>5ff9	e0 5e					.word xt_iox2dpage
>5ffb	3c 48					.word xt_cx21
>5ffd	db 42					.word xt_exit
.5fff					w_setx2dborderx2dsize:
>5fff	0f					.byte $0F
>6000	73 65 74 2d 62 6f 72 64			.text 'set-border-size'
>6008	65 72 2d 73 69 7a 65
>600f	00					.fill 1,0
>6010	c3 5f					.word w_setx2dborderx2dcolor
.6012					xt_setx2dborderx2dsize:
.6012	4c f7 42	jmp $42f7		jmp xt_enter
>6015	e0 5e					.word xt_iox2dpage
>6017	5a 48					.word xt_cx40
>6019	75 47					.word xt_x3er
>601b	71 45					.word xt_0
>601d	e0 5e					.word xt_iox2dpage
>601f	3c 48					.word xt_cx21
>6021	2b 47					.word xt_over
>6023	2b 47					.word xt_over
>6025	5f 4d					.word xt_or
>6027	f4 4e					.word xt_x28branch0x29
>6029	59 60					.word l_62
>602b	05 46					.word xt_x28literalx29
>602d	1f 00					.word 31
>602f	3b 4d					.word xt_and
>6031	05 46					.word xt_x28literalx29
>6033	09 d0					.word 53257
>6035	3c 48					.word xt_cx21
>6037	05 46					.word xt_x28literalx29
>6039	1f 00					.word 31
>603b	3b 4d					.word xt_and
>603d	05 46					.word xt_x28literalx29
>603f	08 d0					.word 53256
>6041	3c 48					.word xt_cx21
>6043	05 46					.word xt_x28literalx29
>6045	04 d0					.word 53252
>6047	5a 48					.word xt_cx40
>6049	05 46					.word xt_x28literalx29
>604b	01 00					.word 1
>604d	5f 4d					.word xt_or
>604f	05 46					.word xt_x28literalx29
>6051	04 d0					.word 53252
>6053	3c 48					.word xt_cx21
>6055	d0 4e					.word xt_x28branchx29
>6057	6d 60					.word l_63
.6059					l_62:
>6059	05 46					.word xt_x28literalx29
>605b	04 d0					.word 53252
>605d	5a 48					.word xt_cx40
>605f	05 46					.word xt_x28literalx29
>6061	fe 00					.word 254
>6063	3b 4d					.word xt_and
>6065	05 46					.word xt_x28literalx29
>6067	04 d0					.word 53252
>6069	3c 48					.word xt_cx21
>606b	97 54					.word xt_2drop
.606d					l_63:
>606d	93 47					.word xt_rx3e
>606f	e0 5e					.word xt_iox2dpage
>6071	3c 48					.word xt_cx21
>6073	db 42					.word xt_exit
.6075					w_maze:
>6075	04					.byte $04
>6076	6d 61 7a 65				.text 'maze'
>607a	00 00 00 00 00 00 00 00			.fill 12,0
>6082	00 00 00 00
>6086	ff 5f					.word w_setx2dborderx2dsize
.6088					xt_maze:
.6088	4c f7 42	jmp $42f7		jmp xt_enter
>608b	a2 5e					.word xt_initrandom
.608d					l_64:
>608d	c2 5e					.word xt_random
>608f	8d 45					.word xt_1
>6091	3b 4d					.word xt_and
>6093	05 46					.word xt_x28literalx29
>6095	ba 00					.word 186
>6097	4c 4a					.word xt_x2b
>6099	e5 44					.word xt_emit
>609b	d0 4e					.word xt_x28branchx29
>609d	8d 60					.word l_64
.609f					l_65:
>609f	db 42					.word xt_exit
.60a1					w_cold:
>60a1	04					.byte $04
>60a2	63 6f 6c 64				.text 'cold'
>60a6	00 00 00 00 00 00 00 00			.fill 12,0
>60ae	00 00 00 00
>60b2	75 60					.word w_maze
.60b4					xt_cold:
.60b4	4c f7 42	jmp $42f7		jmp xt_enter
>60b7	42 51					.word xt_forth
>60b9	09 57					.word xt_definitions
>60bb	73 52					.word xt_s0
>60bd	14 48					.word xt_x40
>60bf	cc 44					.word xt_spx21
>60c1	8b 52					.word xt_r0
>60c3	14 48					.word xt_x40
>60c5	8d 44					.word xt_rpx21
>60c7	71 45					.word xt_0
>60c9	63 53					.word xt_blk
>60cb	e8 47					.word xt_x21
>60cd	05 46					.word xt_x28literalx29
>60cf	00 08					.word 2048
>60d1	03 53					.word xt_dp
>60d3	e8 47					.word xt_x21
>60d5	83 59					.word xt_decimal
>60d7	a9 57					.word xt_x28x2ex22x29
>60d9	1e 57 65 6c 63 6f 6d 65			.ptext "Welcome to MetaForth v00.00.00"
>60e1	20 74 6f 20 4d 65 74 61 46 6f 72 74 68 20 76 30
>60f1	30 2e 30 30 2e 30 30
>60f8	54 45					.word xt_cr
>60fa	7d 5d					.word xt_quit
>60fc	db 42					.word xt_exit

;******  Processing file: mf_post_65c02.asm

.60fe					endcode:

;******  Return to file: forth.asm


;******  End of listing
