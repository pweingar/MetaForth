
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass --mw65c02 --intel-hex -o forth.hex --list=forth.lst forth.asm
; Thu Mar 30 15:31:04 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: forth.asm


;******  Processing file: mf_pre_65c02.asm

=$0000					pstack = $0000          ; Location of the "bottom" of the parameter stack
=$0100					rstack = $0100          ; Location of the "bottom" of the return stack
=$1000					USERAREA = $1000        ; Area for user variables
=9					CHAR_TAB = 9

;******  Processing file: sections.asm


;******  Return to file: mf_pre_65c02.asm

>0020					ip      .word ?         ; Instruction pointer
>0022					wp      .word ?         ; Word pointer
>0024					up      .word ?         ; User pointer
>0026					donep   .word ?         ; Pointer to the code to take over when the interpreter quits
>0028					test    .word ?         ; Pointer to the current test name
>002a					tmp     .fill 4
>002e					savex   .byte ?
>002f					counter .byte ?         ; A counter used for some code
>0030					sign    .byte ?         ; A scratch byte to keep track of the sign of a number
.4000					coldstart:
.4000	20 4a 40	jsr $404a	        jsr ioinit
.4003	4c 22 40	jmp $4022	        jmp start
.4006					init_user:
>4006	6e 00				        .word $006e     ; Initial PSP (S0)
>4008	ff 00				        .word $00ff     ; Initial RSP (R0)
>400a	0a 00				        .word 10        ; Initial BASE
>400c	00 00				        .word 0         ; Initial STATE
>400e	00 00				        .word 0         ; Initial CONTEXT
>4010	00 00				        .word 0         ; Initial CURRENT
>4012	00 10				        .word $1000     ; Initial DP
>4014	00 00				        .word 0         ; Initial >IN
>4016	00 3f				        .word $3f00     ; Initial TIB
>4018	00 00				        .word 0         ; Initial SOURCE-ID
>401a	00 00				        .word 0         ; Initial BLK
>401c	ff ff				        .word $ffff     ; Initial DPL
>401e	00 00				        .word 0         ; Initial HLD
>4020	00 00				        .word 0         ; Initial HANDLER
.4022					init_user_end:
=0					user_s0 = 0
=2					user_r0 = 2
=4					user_base = 4
=6					user_state = 6
=8					user_context = 8
=10					user_current = 10
=12					user_dp = 12
=14					user_in = 14
=16					user_tib = 16
=18					user_source_id = 18
=20					user_blk = 20
=22					user_dpl = 22
=24					user_hld = 24
=26					user_handler = 26
.4022	a2 6e		ldx #$6e	start   ldx #$6e        ; Initialize the PSP
.4024	a9 43		lda #$43	        lda #<vstart
.4026	85 20		sta $20		        sta ip
.4028	a9 40		lda #$40	        lda #>vstart
.402a	85 21		sta $21		        sta ip+1
.402c	a9 00		lda #$00	        lda #<USERAREA
.402e	85 24		sta $24		        sta up
.4030	a9 10		lda #$10	        lda #>USERAREA
.4032	85 25		sta $25		        sta up+1
.4034	a0 00		ldy #$00	        ldy #0
.4036					init_user_loop:
.4036	b9 06 40	lda $4006,y	        lda init_user,y
.4039	91 24		sta ($24),y	        sta (up),y
.403b	c8		iny		        iny
.403c	c0 1c		cpy #$1c	        cpy #(init_user_end - init_user)
.403e	d0 f6		bne $4036	        bne init_user_loop
.4040	4c c1 42	jmp $42c1	        jmp xt_next
>4043	6b 64				vstart  .word xt_cold
>4045	12 44				        .word xt_halt
.4047	6c 26 00	jmp ($0026)	done    jmp (donep)     ; Quit the interpreter by going to the code at donep

;******  Processing file: io.asm


;******  Processing file: io_f256.asm

=$0000					MMU_MEM_CTRL = $0000
=$0001					MMU_IO_CTRL = $0001
=$00					MMU_IO_PAGE_0 = $00
=$01					MMU_IO_PAGE_1 = $01
=$02					MMU_IO_PAGE_TEXT = $02
=$03					MMU_IO_PAGE_COLOR = $03
=$d000					VKY_MST_CTRL_0 = $d000
=$01					VKY_MST_TEXT = $01
=$02					VKY_MST_OVLY = $02
=$04					VKY_MST_GRAPHICS = $04
=$08					VKY_MST_BITMAP = $08
=$10					VKY_MST_TILE = $10
=$20					VKY_MST_SPRITE = $20
=$40					VKY_MST_GAMMA = $40
=$d001					VKY_MST_CTRL_1 = $d001
=$01					VKY_MST_RES_400 = $01
=$02					VKY_MST_DBL_X = $02
=$04					VKY_MST_DBL_Y = $04
=$08					VKY_MST_SLEEP = $08
=$10					VKY_MST_OVLY_TRANS = $10
=$d004					VKY_BRD_CTRL = $d004
=$d005					VKY_BRD_BLUE = $d005
=$d006					VKY_BRD_GREEN = $d006
=$d007					VKY_BRD_RED = $d007
=$d008					VKY_BRD_SIZE_X = $d008
=$d009					VKY_BRD_SIZE_Y = $d009
=$d010					VKY_CURS_CTRL = $d010
=$01					VKY_CURS_ENABLE = $01
=$08					VKY_CURS_FLASH_1S = $08
=$0a					VKY_CURS_FLASH_0_5S = $0a
=$0c					VKY_CURS_FLASH_0_25S = $0c
=$0d					VKY_CURS_FLASH_0_125S = $0d
=$d012					VKY_CURS_CHAR = $d012
=$d014					VKY_CURS_X = $d014
=$d016					VKY_CURS_Y = $d016
=$c000					VKY_TEXT_MATRIX = $c000
=$d800					VKY_TEXT_FG_LUT = $d800
=$d840					VKY_TEXT_BG_LUT = $d840
=$c000					VKY_TEXT_FONT = $c000
=$d66c					INT_MASK_0 = $D66C
=$d660					INT_PEND_0 = $D660
=$d66d					INT_MASK_1 = $D66D
=$d661					INT_PEND_1 = $D661
=$04					INT_PS2_KBD = $04

;******  Return to file: io.asm


;******  Processing file: api.asm

>ff00					NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04					ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08					ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c					Yield       .fill   4   ; Give unused time to the kernel.
>ff10					Putch       .fill   4   ; deprecated
>ff14					RunBlock    .fill   4   ; Chain to resident program by block ID.
>ff18					RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c					            .fill   4   ; reserved
>ff20					List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24					GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28					GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c					Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30					Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34					Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38					Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c					List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40					GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44					MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48					CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c					Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50					Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54					ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58					WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c					Open        .fill   4   ; Open the given file for read, create, or append.
>ff60					Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64					Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68					Close       .fill   4   ; Close an open file.
>ff6c					Rename      .fill   4   ; Rename a closed file.
>ff70					Delete      .fill   4   ; Delete a closed file.
>ff74					Open        .fill   4   ; Open a directory for reading.
>ff78					Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff7c					Close       .fill   4   ; Close a directory once finished reading.
>ff80					MkDir       .fill   4
>ff84					RmDir       .fill   4
>ff88					            .fill   4   ; call gate
>ff8c					GetIP       .fill   4   ; Get the local IP address.
>ff90					SetIP       .fill   4   ; Set the local IP address.
>ff94					GetDNS      .fill   4   ; Get the configured DNS IP address.
>ff98					SetDNS      .fill   4   ; Set the configured DNS IP address.
>ff9c					SendICMP    .fill   4
>ffa0					Match       .fill   4
>ffa4					Init        .fill   4
>ffa8					Send        .fill   4
>ffac					Recv        .fill   4
>ffb0					Open        .fill   4
>ffb4					Accept      .fill   4
>ffb8					Reject      .fill   4
>ffbc					Send        .fill   4
>ffc0					Recv        .fill   4
>ffc4					Close       .fill   4
>ffc8					Reset       .fill   4   ; Re-init the display
>ffcc					GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ffd0					DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ffd4					DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ffd8					GetTime     .fill   4
>ffdc					SetTime     .fill   4
>ffe0					GetSysInfo  .fill   4
>ffe4					SetBPS      .fill   4   ; Set the serial BPS (should match the SLIP router's speed).
.00f0					args
.00f0					events
>00f0					dest        .word       ?   ; GetNextEvent copies event data here
>00f2					pending     .byte       ?   ; Negative count of pending events
.00f3					end
.00f3					run
>00f3					block_id    .byte   ?
.00f3					recv
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.00f3					fs
.00f3					format
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.00f3					mkfs
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.00f3					file
.00f3					open
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>00f5					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.00f3					read
>00f3					stream      .byte       ?
>00f4					buflen      .byte       ?
.00f3					write
>00f3					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.00f3					close
>00f3					stream      .byte       ?
.00f3					rename
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.00f3					delete
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>00f5					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.00f3					directory
.00f3					open
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.00f3					read
>00f3					stream      .byte       ?
>00f4					buflen      .byte       ?
.00f3					close
>00f3					stream      .byte       ?
.00f3					display
>00f3					x           .byte       ?   ; coordinate or size
>00f4					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.00f3					net
=$fb					socket      = args.buf
>00f3					src_port    .word       ?
>00f5					dest_port   .word       ?
>00f7					dest_ip     .fill       4
>00f3					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
=$f8					ext         = $f8
=$fa					extlen      = $fa
=$fb					buf         = $fb
=$fd					buflen      = $fd
=$fe					ptr         = $fe
.0000					args_t
.0000					events
>0000					dest        .word       ?   ; GetNextEvent copies event data here
>0002					pending     .byte       ?   ; Negative count of pending events
.0003					end
.0003					run
>0003					block_id    .byte   ?
.0003					recv
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0003					fs
.0003					format
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0003					mkfs
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0003					file
.0003					open
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0005					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0003					read
>0003					stream      .byte       ?
>0004					buflen      .byte       ?
.0003					write
>0003					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0003					close
>0003					stream      .byte       ?
.0003					rename
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0003					delete
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0005					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0003					directory
.0003					open
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0003					read
>0003					stream      .byte       ?
>0004					buflen      .byte       ?
.0003					close
>0003					stream      .byte       ?
.0003					display
>0003					x           .byte       ?   ; coordinate or size
>0004					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.0003					net
=$fb					socket      = args.buf
>0003					src_port    .word       ?
>0005					dest_port   .word       ?
>0007					dest_ip     .fill       4
>0003					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
=$f8					ext         = $f8
=$fa					extlen      = $fa
=$fb					buf         = $fb
=$fd					buflen      = $fd
=$fe					ptr         = $fe
.0000					event_t
>0000					dest        .word       ?   ; GetNextEvent copies event data here
>0002					pending     .byte       ?   ; Negative count of pending events
.0003					end
.0000					recv_t
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0000					run_t
>0000					block_id    .byte   ?
.0000					fs_t
.0000					format
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					mkfs
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					fs_mkfs_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					file_t
.0000					open
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0000					read
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					write
>0000					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0000					close
>0000					stream      .byte       ?
.0000					rename
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0000					delete
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0000					fs_open_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0000					fs_read_t
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					fs_write_t
>0000					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0000					fs_close_t
>0000					stream      .byte       ?
.0000					fs_rename_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0000					fs_delete_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fnane       = args.buf
=$fd					fname_len   = args.buflen
.0000					dir_t
.0000					open
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0000					read
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					close
>0000					stream      .byte       ?
.0000					dir_open_t
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0000					dir_read_t
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					dir_close_t
>0000					stream      .byte       ?
.0000					display_t
>0000					x           .byte       ?   ; coordinate or size
>0001					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.0000					net_t
=$fb					socket      = args.buf
>0000					src_port    .word       ?
>0002					dest_port   .word       ?
>0004					dest_ip     .fill       4
>0000					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
>0000					            .word   ?   ; Reserved
>0002					            .word   ?   ; Deprecated
>0004					JOYSTICK    .word   ?   ; Game Controller changes.
>0006					DEVICE      .word   ?   ; Device added/removed.
>0008					PRESSED     .word   ?   ; Key pressed
>000a					RELEASED    .word   ?   ; Key released.
>000c					DELTA       .word   ?   ; Regular mouse move and button state
>000e					CLICKS      .word   ?   ; Click counts
>0010					NAME        .word   ?
>0012					SIZE        .word   ?
>0014					DATA        .word   ?   ; The read request has succeeded.
>0016					WROTE       .word   ?   ; The write request has completed.
>0018					FORMATTED   .word   ?   ; The low-level format has completed.
>001a					ERROR       .word   ?
>001c					SIZE        .word   ?
>001e					CREATED     .word   ?
>0020					CHECKED     .word   ?
>0022					DATA        .word   ?   ; The read request has succeeded.
>0024					WROTE       .word   ?   ; The write request has completed.
>0026					ERROR       .word   ?
>0028					NOT_FOUND   .word   ?   ; The file file was not found.
>002a					OPENED      .word   ?   ; The file was successfully opened.
>002c					DATA        .word   ?   ; The read request has succeeded.
>002e					WROTE       .word   ?   ; The write request has completed.
>0030					EOF         .word   ?   ; All file data has been read.
>0032					CLOSED      .word   ?   ; The close request has completed.
>0034					RENAMED     .word   ?   ; The rename request has completed.
>0036					DELETED     .word   ?   ; The delete request has completed.
>0038					ERROR       .word   ?   ; An error occured; close the file if opened.
>003a					OPENED      .word   ?   ; The directory open request succeeded.
>003c					VOLUME      .word   ?   ; A volume record was found.
>003e					FILE        .word   ?   ; A file record was found.
>0040					FREE        .word   ?   ; A file-system free-space record was found.
>0042					EOF         .word   ?   ; All data has been read.
>0044					CLOSED      .word   ?   ; The directory file has been closed.
>0046					ERROR       .word   ?   ; An error occured; user should close.
>0048					TCP         .word   ?
>004a					UDP         .word   ?
.0000					event_t
>0000					type        .byte   ?   ; Enum above
>0001					buf         .byte   ?   ; page id or zero
>0002					ext         .byte   ?   ; page id or zero
.0003					key
>0003					keyboard    .byte   ?   ; Keyboard ID
>0004					raw         .byte   ?   ; Raw key ID
>0005					ascii       .byte   ?   ; ASCII value
>0006					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0003					mouse
.0003					delta
>0003					x           .byte   ?
>0004					y           .byte   ?
>0005					z           .byte   ?
>0006					buttons     .byte   ?
.0003					clicks
>0003					inner       .byte   ?
>0004					middle      .byte   ?
>0005					outer       .byte   ?
.0003					joystick
>0003					joy0        .byte   ?
>0004					joy1        .byte   ?
.0003					udp
>0003					token       .byte   ?   ; TODO: break out into fields
.0003					tcp
>0003					len         .byte   ?   ; Raw packet length.
.0003					file
>0003					stream      .byte   ?
>0004					cookie      .byte   ?
.0005					data
>0005					requested   .byte   ?   ; Requested number of bytes to read
>0006					read        .byte   ?   ; Number of bytes actually read
.0005					wrote
>0005					requested   .byte   ?   ; Requested number of bytes to read
>0006					wrote       .byte   ?   ; Number of bytes actually read
.0003					directory
>0003					stream      .byte   ?
>0004					cookie      .byte   ?
.0005					volume
>0005					len         .byte   ?   ; Length of volname (in buf)
>0006					flags       .byte   ?   ; block size, text encoding
.0005					file
>0005					len         .byte   ?
>0006					flags       .byte   ?   ; block scale, text encoding, approx size
.0005					free
>0005					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					key_t
>0000					keyboard    .byte   ?   ; Keyboard ID
>0001					raw         .byte   ?   ; Raw key ID
>0002					ascii       .byte   ?   ; ASCII value
>0003					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0000					mouse_t
.0000					delta
>0000					x           .byte   ?
>0001					y           .byte   ?
>0002					z           .byte   ?
>0003					buttons     .byte   ?
.0000					clicks
>0000					inner       .byte   ?
>0001					middle      .byte   ?
>0002					outer       .byte   ?
.0000					m_delta_t
>0000					x           .byte   ?
>0001					y           .byte   ?
>0002					z           .byte   ?
>0003					buttons     .byte   ?
.0000					m_clicks_t
>0000					inner       .byte   ?
>0001					middle      .byte   ?
>0002					outer       .byte   ?
.0000					joystick_t
>0000					joy0        .byte   ?
>0001					joy1        .byte   ?
.0000					file_t
>0000					stream      .byte   ?
>0001					cookie      .byte   ?
.0002					data
>0002					requested   .byte   ?   ; Requested number of bytes to read
>0003					read        .byte   ?   ; Number of bytes actually read
.0002					wrote
>0002					requested   .byte   ?   ; Requested number of bytes to read
>0003					wrote       .byte   ?   ; Number of bytes actually read
.0000					fs_data_t
>0000					requested   .byte   ?   ; Requested number of bytes to read
>0001					read        .byte   ?   ; Number of bytes actually read
.0000					fs_wrote_t
>0000					requested   .byte   ?   ; Requested number of bytes to read
>0001					wrote       .byte   ?   ; Number of bytes actually read
.0000					dir_t
>0000					stream      .byte   ?
>0001					cookie      .byte   ?
.0002					volume
>0002					len         .byte   ?   ; Length of volname (in buf)
>0003					flags       .byte   ?   ; block size, text encoding
.0002					file
>0002					len         .byte   ?
>0003					flags       .byte   ?   ; block scale, text encoding, approx size
.0002					free
>0002					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					dir_vol_t
>0000					len         .byte   ?   ; Length of volname (in buf)
>0001					flags       .byte   ?   ; block size, text encoding
.0000					dir_file_t
>0000					len         .byte   ?
>0001					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					dir_free_t
>0000					flags       .byte   ?   ; block scale, text encoding, approx size
.0000					dir_ext_t
>0000					free        .fill   6   ; blocks used/free
.0000					udp_t
>0000					token       .byte   ?   ; TODO: break out into fields
.0000					tcp_t
>0000					len         .byte   ?   ; Raw packet length.

;******  Return to file: io.asm

=8					CHAR_BS = 8                         ; Backspace
=12					CHAR_FF = 12                        ; Form feed character
=13					CHAR_NL = 13                        ; Newline character
=$f4					DEF_COLOR = $f4                     ; Default color
>0031					cur_line    .word ?                 ; Address of the current line on the text screen
>0033					src_ptr     .word ?                 ; General pointer for the source of something in memory
>0035					dst_ptr     .word ?                 ; General pointer for the destination of something in memory
.0200					event
>0200					type        .byte   ?   ; Enum above
>0201					buf         .byte   ?   ; page id or zero
>0202					ext         .byte   ?   ; page id or zero
.0203					key
>0203					keyboard    .byte   ?   ; Keyboard ID
>0204					raw         .byte   ?   ; Raw key ID
>0205					ascii       .byte   ?   ; ASCII value
>0206					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0203					mouse
.0203					delta
>0203					x           .byte   ?
>0204					y           .byte   ?
>0205					z           .byte   ?
>0206					buttons     .byte   ?
.0203					clicks
>0203					inner       .byte   ?
>0204					middle      .byte   ?
>0205					outer       .byte   ?
.0203					joystick
>0203					joy0        .byte   ?
>0204					joy1        .byte   ?
.0203					udp
>0203					token       .byte   ?   ; TODO: break out into fields
.0203					tcp
>0203					len         .byte   ?   ; Raw packet length.
.0203					file
>0203					stream      .byte   ?
>0204					cookie      .byte   ?
.0205					data
>0205					requested   .byte   ?   ; Requested number of bytes to read
>0206					read        .byte   ?   ; Number of bytes actually read
.0205					wrote
>0205					requested   .byte   ?   ; Requested number of bytes to read
>0206					wrote       .byte   ?   ; Number of bytes actually read
.0203					directory
>0203					stream      .byte   ?
>0204					cookie      .byte   ?
.0205					volume
>0205					len         .byte   ?   ; Length of volname (in buf)
>0206					flags       .byte   ?   ; block size, text encoding
.0205					file
>0205					len         .byte   ?
>0206					flags       .byte   ?   ; block scale, text encoding, approx size
.0205					free
>0205					flags       .byte   ?   ; block scale, text encoding, approx size
>0207					curs_color  .byte ?                 ; Current color for printing
>0208					curs_x      .byte ?                 ; Current column for the text cursor
>0209					curs_y      .byte ?                 ; Current row for the text cursor
>020a					old_y       .byte ?                 ; Previous cursor row
>020b					curs_width  .byte ?                 ; Width of the screen in text columns
>020c					curs_height .byte ?                 ; Height of the screen in text columns
.404a					ioinit:
.404a	a9 00		lda #$00	            lda #<event                     ; Point to our event record
.404c	85 f0		sta $f0				    sta kernel.args.events+0
.404e	a9 02		lda #$02			    lda #>event
.4050	85 f1		sta $f1				    sta kernel.args.events+1
.4052	20 6d 40	jsr $406d	            jsr initlut                     ; Initialize the CLUT
.4055	a9 f4		lda #$f4	            lda #DEF_COLOR                  ; Set the default color (will be defined with the LUT)
.4057	8d 07 02	sta $0207	            sta curs_color
.405a	a9 ff		lda #$ff	            lda #$ff                        ; Set old_y to something silly
.405c	8d 0a 02	sta $020a	            sta old_y
.405f	a9 50		lda #$50	            lda #80
.4061	8d 0b 02	sta $020b	            sta curs_width
.4064	a9 3c		lda #$3c	            lda #60
.4066	8d 0c 02	sta $020c	            sta curs_height
.4069	20 df 40	jsr $40df	            jsr consclr                     ; Clear the text screen and home the cursor
.406c	60		rts		            rts
.406d					initlut:
.406d	48		pha		            pha
.406e	5a		phy		            phy
.406f	a5 01		lda $01		            lda MMU_IO_CTRL             ; Save the current I/O page
.4071	48		pha		            pha
.4072	a9 00		lda #$00	            lda #MMU_IO_PAGE_0          ; Make sure we're on I/O page #0
.4074	85 01		sta $01		            sta MMU_IO_CTRL
.4076	a0 00		ldy #$00	            ldy #0
.4078	b9 8c 40	lda $408c,y	loop:       lda text_lut,y              ; Get a color component
.407b	99 00 d8	sta $d800,y	            sta VKY_TEXT_FG_LUT,y       ; Write it to the text foreground CLUT
.407e	99 40 d8	sta $d840,y	            sta VKY_TEXT_BG_LUT,y       ; And then to the text background CLUT
.4081	c8		iny		            iny
.4082	c0 40		cpy #$40	            cpy #4*16                   ; Have we copied all 16 colors (4 components)
.4084	d0 f2		bne $4078	            bne loop                    ; No: copy the next one
.4086	68		pla		            pla
.4087	85 01		sta $01		            sta MMU_IO_CTRL             ; Restore the current I/O page
.4089	7a		ply		            ply
.408a	68		pla		            pla
.408b	60		rts		            rts
>408c	00 00 00 00			text_lut:   .byte $00, $00, $00, $00    ; Black
>4090	00 00 80 00			            .byte $00, $00, $80, $00    ; Red
>4094	00 80 00 00			            .byte $00, $80, $00, $00    ; Green
>4098	00 80 80 00			            .byte $00, $80, $80, $00    ; Yellow
>409c	80 00 00 00			            .byte $80, $00, $00, $00    ; Blue
>40a0	80 00 80 00			            .byte $80, $00, $80, $00    ; Magenta
>40a4	80 80 00 00			            .byte $80, $80, $00, $00    ; Cyan
>40a8	8c 8c 8c 00			            .byte $8c, $8c, $8c, $00    ; White
>40ac	80 80 80 00			            .byte $80, $80, $80, $00    ; Bright Black
>40b0	00 00 ff 00			            .byte $00, $00, $ff, $00    ; Bright Red
>40b4	00 ff 00 00			            .byte $00, $ff, $00, $00    ; Bright Green
>40b8	00 ff ff 00			            .byte $00, $ff, $ff, $00    ; Bright Yellow
>40bc	ff 00 00 00			            .byte $ff, $00, $00, $00    ; Bright Blue
>40c0	ff 00 ff 00			            .byte $ff, $00, $ff, $00    ; Bright Magenta
>40c4	ff ff 00 00			            .byte $ff, $ff, $00, $00    ; Bright Cyan
>40c8	ff ff ff 00			            .byte $ff, $ff, $ff, $00    ; Bright White
.40cc					constat:
.40cc	a9 00		lda #$00	            lda #0
.40ce	60		rts		            rts
.40cf					conin:
.40cf	20 00 ff	jsr $ff00	            jsr kernel.NextEvent            ; Grab the event
.40d2	b0 fb		bcs $40cf	            bcs conin
.40d4	ad 00 02	lda $0200	            lda event.type                  ; Check the event type
.40d7	c9 08		cmp #$08	            cmp #kernel.event.key.PRESSED
.40d9	d0 f4		bne $40cf	            bne conin
.40db	ad 05 02	lda $0205	            lda event.key.ascii             ; Get the ASCII code of the key pressed
.40de	60		rts		            rts
.40df					consclr:
.40df	48		pha		            pha
.40e0	da		phx		            phx
.40e1	a9 00		lda #$00	            lda #<VKY_TEXT_MATRIX   ; Move the current line to the first line
.40e3	85 31		sta $31		            sta cur_line
.40e5	a9 c0		lda #$c0	            lda #>VKY_TEXT_MATRIX
.40e7	85 32		sta $32		            sta cur_line+1
.40e9	a0 00		ldy #$00	            ldy #0
.40eb	20 e6 41	jsr $41e6	loop:       jsr clrline             ; Clear the current line
.40ee	c8		iny		            iny                     ; Move to the next line
.40ef	cc 0c 02	cpy $020c	            cpy curs_height
.40f2	f0 10		beq $4104	            beq home                ; If we've done the last line, home the cursor
.40f4	18		clc		            clc                     ; Advance cur_line to the next line in the matrix
.40f5	a5 31		lda $31		            lda cur_line
.40f7	6d 0b 02	adc $020b	            adc curs_width
.40fa	85 31		sta $31		            sta cur_line
.40fc	a5 32		lda $32		            lda cur_line+1
.40fe	69 00		adc #$00	            adc #0
.4100	85 32		sta $32		            sta cur_line+1
.4102	80 e7		bra $40eb	            bra loop                ; And go back to clear it too
.4104	9c 08 02	stz $0208	home:       stz curs_x              ; Set the cursor to (0, 0)
.4107	9c 09 02	stz $0209	            stz curs_y
.410a	20 10 41	jsr $4110	            jsr cursset
.410d	fa		plx		            plx
.410e	68		pla		            pla
.410f	60		rts		            rts
.4110					cursset:
.4110	48		pha		            pha
.4111	5a		phy		            phy
.4112	ad 08 02	lda $0208	            lda curs_x              ; Where is the cursor column pointing
.4115	cd 0b 02	cmp $020b	            cmp curs_width
.4118	90 06		bcc $4120	            blt chk_row             ; If on screen, let's check the row
.411a	9c 08 02	stz $0208	            stz curs_x              ; If not on screen, move it to the left and down
.411d	ee 09 02	inc $0209	            inc curs_y
.4120					chk_row:
.4120	ad 09 02	lda $0209	            lda curs_y              ; Where is the cursor row pointing
.4123	cd 0c 02	cmp $020c	            cmp curs_height
.4126	90 0a		bcc $4132	            blt set_hw              ; If on screen, set the hardware registers
.4128	ad 0c 02	lda $020c	            lda curs_height         ; Otherwise: Move the last visible row
.412b	3a		dec a		            dec a
.412c	8d 09 02	sta $0209	            sta curs_y
.412f	20 70 41	jsr $4170	            jsr consscroll          ; And we need to scroll the screen
.4132	ad 08 02	lda $0208	set_hw:     lda curs_x              ; Set the hardware cursor column
.4135	8d 14 d0	sta $d014	            sta VKY_CURS_X
.4138	9c 15 d0	stz $d015	            stz VKY_CURS_X+1
.413b	ad 09 02	lda $0209	            lda curs_y              ; Set the hardware cursor row
.413e	8d 16 d0	sta $d016	            sta VKY_CURS_Y
.4141	9c 17 d0	stz $d017	            stz VKY_CURS_Y+1
.4144	ad 0a 02	lda $020a	            lda old_y               ; Is old_y == curs_y
.4147	cd 09 02	cmp $0209	            cmp curs_y
.414a	f0 21		beq $416d	            beq done                ; Yes: we are done
.414c	a9 00		lda #$00	            lda #<VKY_TEXT_MATRIX   ; Start on the first line
.414e	85 31		sta $31		            sta cur_line
.4150	a9 c0		lda #$c0	            lda #>VKY_TEXT_MATRIX
.4152	85 32		sta $32		            sta cur_line+1
.4154	ac 09 02	ldy $0209	            ldy curs_y              ; Get the desired row
.4157	8c 0a 02	sty $020a	            sty old_y               ; And mark that it will be our old row from now on
.415a	f0 11		beq $416d	            beq done                ; If it's zero, we are done
.415c	18		clc		loop:       clc                     ; Move cur_line to the next line
.415d	a5 31		lda $31		            lda cur_line
.415f	6d 0b 02	adc $020b	            adc curs_width
.4162	85 31		sta $31		            sta cur_line
.4164	a5 32		lda $32		            lda cur_line+1
.4166	69 00		adc #$00	            adc #0
.4168	85 32		sta $32		            sta cur_line+1
.416a	88		dey		            dey                     ; Decrement line counter
.416b	d0 ef		bne $415c	            bne loop                ; If not zero, keep moving down a line
.416d	7a		ply		done:       ply
.416e	68		pla		            pla
.416f	60		rts		            rts
.4170					consscroll:
.4170	48		pha		            pha
.4171	da		phx		            phx
.4172	a5 32		lda $32		            lda cur_line+1          ; Save the current line
.4174	48		pha		            pha
.4175	a5 31		lda $31		            lda cur_line
.4177	48		pha		            pha
.4178	a5 01		lda $01		            lda MMU_IO_CTRL         ; Save the current I/O page
.417a	48		pha		            pha
.417b	a9 00		lda #$00	            lda #<VKY_TEXT_MATRIX   ; Destination pointer is the first line
.417d	85 35		sta $35		            sta dst_ptr
.417f	a9 c0		lda #$c0	            lda #>VKY_TEXT_MATRIX
.4181	85 36		sta $36		            sta dst_ptr+1
.4183	18		clc		            clc                     ; src_ptr is the second line
.4184	a5 35		lda $35		            lda dst_ptr
.4186	6d 0b 02	adc $020b	            adc curs_width
.4189	85 33		sta $33		            sta src_ptr
.418b	a5 36		lda $36		            lda dst_ptr+1
.418d	69 00		adc #$00	            adc #0
.418f	85 34		sta $34		            sta src_ptr+1
.4191	a2 01		ldx #$01	            ldx #1                  ; X will be our source row number
.4193	a9 02		lda #$02	copy_text:  lda #MMU_IO_PAGE_TEXT   ; Move to the text page
.4195	85 01		sta $01		            sta MMU_IO_CTRL
.4197	a0 00		ldy #$00	            ldy #0                  ; Copy a text line from src to dst
.4199	b1 33		lda ($33),y	loop1:      lda (src_ptr),y
.419b	91 35		sta ($35),y	            sta (dst_ptr),y
.419d	c8		iny		            iny
.419e	cc 0b 02	cpy $020b	            cpy curs_width
.41a1	d0 f6		bne $4199	            bne loop1
.41a3	a9 03		lda #$03	            lda #MMU_IO_PAGE_COLOR  ; Move to the text color page
.41a5	85 01		sta $01		            sta MMU_IO_CTRL
.41a7	a0 00		ldy #$00	            ldy #0                  ; Copy a color line from src to dst
.41a9	b1 33		lda ($33),y	loop2:      lda (src_ptr),y
.41ab	91 35		sta ($35),y	            sta (dst_ptr),y
.41ad	c8		iny		            iny
.41ae	cc 0b 02	cpy $020b	            cpy curs_width
.41b1	d0 f6		bne $41a9	            bne loop2
.41b3	a5 33		lda $33		            lda src_ptr             ; Move dst_ptr to the next line
.41b5	85 35		sta $35		            sta dst_ptr
.41b7	a5 34		lda $34		            lda src_ptr+1
.41b9	85 36		sta $36		            sta dst_ptr+1
.41bb	18		clc		            clc                     ; Move src_ptr to the next line
.41bc	a5 33		lda $33		            lda src_ptr
.41be	6d 0b 02	adc $020b	            adc curs_width
.41c1	85 33		sta $33		            sta src_ptr
.41c3	a5 34		lda $34		            lda src_ptr+1
.41c5	69 00		adc #$00	            adc #0
.41c7	85 34		sta $34		            sta src_ptr+1
.41c9	e8		inx		            inx                     ; Move src line number to the next row
.41ca	ec 0c 02	cpx $020c	            cpx curs_height         ; Have we copied the last row?
.41cd	d0 c4		bne $4193	            bne copy_text           ; No: copy the line
.41cf	a5 35		lda $35		            lda dst_ptr             ; Clear the destination line
.41d1	85 31		sta $31		            sta cur_line
.41d3	a5 36		lda $36		            lda dst_ptr+1
.41d5	85 32		sta $32		            sta cur_line+1
.41d7	20 e6 41	jsr $41e6	            jsr clrline
.41da	68		pla		            pla                     ; Restore the original I/O page
.41db	85 01		sta $01		            sta MMU_IO_CTRL
.41dd	68		pla		            pla                     ; Restore the current line
.41de	85 31		sta $31		            sta cur_line
.41e0	68		pla		            pla
.41e1	85 32		sta $32		            sta cur_line+1
.41e3	fa		plx		            plx
.41e4	68		pla		            pla
.41e5	60		rts		            rts
.41e6					clrline:
.41e6	48		pha		            pha
.41e7	5a		phy		            phy
.41e8	a5 01		lda $01		            lda MMU_IO_CTRL         ; Save the current I/O page
.41ea	48		pha		            pha
.41eb	a9 02		lda #$02	            lda #MMU_IO_PAGE_TEXT   ; Move to the text page
.41ed	85 01		sta $01		            sta MMU_IO_CTRL
.41ef	a0 00		ldy #$00	            ldy #0                  ; Fill the text matrix line with blanks
.41f1	a9 20		lda #$20	            lda #' '
.41f3	91 31		sta ($31),y	loop1:      sta (cur_line),y
.41f5	c8		iny		            iny
.41f6	cc 0b 02	cpy $020b	            cpy curs_width
.41f9	d0 f8		bne $41f3	            bne loop1
.41fb	a9 03		lda #$03	            lda #MMU_IO_PAGE_COLOR  ; Move to the text color page
.41fd	85 01		sta $01		            sta MMU_IO_CTRL
.41ff	a0 00		ldy #$00	            ldy #0                  ; Fill the color matrix line with the current color
.4201	ad 07 02	lda $0207	            lda curs_color
.4204	91 31		sta ($31),y	loop2:      sta (cur_line),y
.4206	c8		iny		            iny
.4207	cc 0b 02	cpy $020b	            cpy curs_width
.420a	d0 f8		bne $4204	            bne loop2
.420c	68		pla		            pla                     ; Restore the original I/O page
.420d	85 01		sta $01		            sta MMU_IO_CTRL
.420f	7a		ply		            ply
.4210	68		pla		            pla
.4211	60		rts		            rts
.4212					conout:
.4212	5a		phy		            phy
.4213	c9 0d		cmp #$0d	            cmp #CHAR_NL            ; Is it a carriage return?
.4215	d0 0b		bne $4222	            bne not_cr
.4217	9c 08 02	stz $0208	            stz curs_x              ; Yes: Do a carriage return
.421a	ee 09 02	inc $0209	            inc curs_y
.421d	20 10 41	jsr $4110	            jsr cursset
.4220	80 44		bra $4266	            bra done
.4222	c9 0c		cmp #$0c	not_cr:     cmp #CHAR_FF            ; Is it a FF character?
.4224	d0 05		bne $422b	            bne not_ff
.4226	20 df 40	jsr $40df	            jsr consclr             ; Yes: clear the screen
.4229	80 3b		bra $4266	            bra done
.422b	c9 08		cmp #$08	not_ff:     cmp #CHAR_BS            ; Is it a backspace character?
.422d	d0 15		bne $4244	            bne not_bs
.422f	ad 08 02	lda $0208	            lda curs_x              ; Yes: move the cursor back
.4232	f0 07		beq $423b	            beq bs_leftmost         ; Is it already on column 0?
.4234	3a		dec a		            dec a                   ; No: move it back one
.4235	8d 08 02	sta $0208	            sta curs_x
.4238	20 10 41	jsr $4110	            jsr cursset
.423b					bs_leftmost:
.423b	a9 20		lda #$20	            lda #' '                ; Clear the current character
.423d	ac 08 02	ldy $0208	            ldy curs_x              ; Get the index to the cursor
.4240	91 31		sta ($31),y	            sta (cur_line),y        ; Write the character to the screen
.4242	80 22		bra $4266	            bra done
.4244	85 2a		sta $2a		not_bs:     sta tmp                 ; Otherwise: save A in preparation for printing
.4246	a5 01		lda $01		            lda MMU_IO_CTRL         ; Save the current I/O page
.4248	48		pha		            pha
.4249	a9 02		lda #$02	            lda #MMU_IO_PAGE_TEXT   ; Move to the text page
.424b	85 01		sta $01		            sta MMU_IO_CTRL
.424d	a5 2a		lda $2a		            lda tmp                 ; Get A back
.424f	ac 08 02	ldy $0208	            ldy curs_x              ; Get the index to the cursor
.4252	91 31		sta ($31),y	            sta (cur_line),y        ; Write the character to the screen
.4254	a9 03		lda #$03	            lda #MMU_IO_PAGE_COLOR  ; Move to the color page
.4256	85 01		sta $01		            sta MMU_IO_CTRL
.4258	ad 07 02	lda $0207	            lda curs_color          ; Get the current color
.425b	91 31		sta ($31),y	            sta (cur_line),y        ; And set it on the screen
.425d	68		pla		            pla                     ; Restore the I/O page
.425e	85 01		sta $01		            sta MMU_IO_CTRL
.4260	ee 08 02	inc $0208	            inc curs_x              ; Move to the next column
.4263	20 10 41	jsr $4110	            jsr cursset
.4266	7a		ply		done:       ply
.4267	60		rts		            rts
.4268					printah:
.4268	da		phx		            phx
.4269	48		pha		            pha
.426a	4a		lsr a		            lsr a
.426b	4a		lsr a		            lsr a
.426c	4a		lsr a		            lsr a
.426d	4a		lsr a		            lsr a
.426e	29 0f		and #$0f	            and #$0f
.4270	aa		tax		            tax                     ; Convert it to an index
.4271	bd 8d 42	lda $428d,x	            lda hex_digits,x        ; Lookup the hex digit for that nibble
.4274	20 12 42	jsr $4212	            jsr conout              ; And print it
.4277	68		pla		            pla
.4278	29 0f		and #$0f	            and #$0f                ; Isolate the low nibble
.427a	aa		tax		            tax                     ; Convert it to an index
.427b	bd 8d 42	lda $428d,x	            lda hex_digits,x        ; Lookup the hex digit for that nibble
.427e	20 12 42	jsr $4212	            jsr conout              ; And print it
.4281	fa		plx		            plx
.4282	60		rts		            rts
.4283					printyah:
.4283	48		pha		            pha
.4284	98		tya		            tya
.4285	20 68 42	jsr $4268	            jsr printah
.4288	68		pla		            pla
.4289	20 68 42	jsr $4268	            jsr printah
.428c	60		rts		            rts
>428d	30 31 32 33 34 35 36 37		hex_digits: .text "0123456789ABCDEF"
>4295	38 39 41 42 43 44 45 46
.429d					prints:
.429d	48		pha		            pha
.429e	5a		phy		            phy
.429f	a0 00		ldy #$00	            ldy #0
.42a1	b1 33		lda ($33),y	loop:       lda (src_ptr),y
.42a3	f0 06		beq $42ab	            beq done
.42a5	20 12 42	jsr $4212	            jsr conout
.42a8	c8		iny		            iny
.42a9	d0 f6		bne $42a1	            bne loop
.42ab	7a		ply		done:       ply
.42ac	68		pla		            pla
.42ad	60		rts		            rts

;******  Return to file: mf_pre_65c02.asm


;******  Return to file: forth.asm

.42ae					w_next:
>42ae	04					.byte $04
>42af	6e 65 78 74				.text 'next'
>42b3	00 00 00 00 00 00 00 00			.fill 12,0
>42bb	00 00 00 00
>42bf	00 00					.word 0
.42c1					xt_next:
.42c1	a0 01		ldy #$01		ldy #1          ; wp := (ip)
.42c3	b2 20		lda ($20)		lda (ip)
.42c5	85 22		sta $22			sta wp
.42c7	b1 20		lda ($20),y		lda (ip),y
.42c9	85 23		sta $23			sta wp+1
.42cb	18		clc			clc             ; ip := ip + 2
.42cc	a5 20		lda $20			lda ip
.42ce	69 02		adc #$02		adc #2
.42d0	85 20		sta $20			sta ip
.42d2	a5 21		lda $21			lda ip+1
.42d4	69 00		adc #$00		adc #0
.42d6	85 21		sta $21			sta ip+1
.42d8	6c 22 00	jmp ($0022)		jmp (wp)        ; jmp (wp)
.42db					w_exit:
>42db	04					.byte $04
>42dc	65 78 69 74				.text 'exit'
>42e0	00 00 00 00 00 00 00 00			.fill 12,0
>42e8	00 00 00 00
>42ec	ae 42					.word w_next
.42ee					xt_exit:
.42ee	68		pla			pla             ; ip := pop()
.42ef	85 20		sta $20			sta ip
.42f1	68		pla			pla
.42f2	85 21		sta $21			sta ip+1
.42f4	4c c1 42	jmp $42c1		jmp xt_next
.42f7					w_enter:
>42f7	05					.byte $05
>42f8	65 6e 74 65 72				.text 'enter'
>42fd	00 00 00 00 00 00 00 00			.fill 11,0
>4305	00 00 00
>4308	db 42					.word w_exit
.430a					xt_enter:
.430a	a5 21		lda $21			lda ip+1        ; push(ip)
.430c	48		pha			pha
.430d	a5 20		lda $20			lda ip
.430f	48		pha			pha
.4310	18		clc			clc             ; ip := wp + 3
.4311	a5 22		lda $22			lda wp
.4313	69 03		adc #$03		adc #3
.4315	85 20		sta $20			sta ip
.4317	a5 23		lda $23			lda wp+1
.4319	69 00		adc #$00		adc #0
.431b	85 21		sta $21			sta ip+1
.431d	4c c1 42	jmp $42c1		jmp xt_next
.4320					w_dodoes:
>4320	06					.byte $06
>4321	64 6f 64 6f 65 73			.text 'dodoes'
>4327	00 00 00 00 00 00 00 00			.fill 10,0
>432f	00 00
>4331	f7 42					.word w_enter
.4333					xt_dodoes:
.4333	18		clc			clc             ; push PFA to parameter stack
.4334	a5 22		lda $22			lda wp
.4336	69 03		adc #$03		adc #3
.4338	95 00		sta $00,x		sta pstack,x
.433a	a5 23		lda $23			lda wp+1
.433c	69 00		adc #$00		adc #0
.433e	95 01		sta $01,x		sta pstack+1,x
.4340	ca		dex			dex
.4341	ca		dex			dex
.4342	18		clc			clc             ; Address of high level code into tmp
.4343	68		pla			pla
.4344	69 01		adc #$01		adc #1
.4346	85 2a		sta $2a			sta tmp
.4348	68		pla			pla
.4349	69 00		adc #$00		adc #0
.434b	85 2b		sta $2b			sta tmp+1
.434d	a5 21		lda $21			lda ip+1        ; push ip to return stack
.434f	48		pha			pha
.4350	a5 20		lda $20			lda ip
.4352	48		pha			pha
.4353	a5 2a		lda $2a			lda tmp         ; ip := tmp
.4355	85 20		sta $20			sta ip
.4357	a5 2b		lda $2b			lda tmp+1
.4359	85 21		sta $21			sta ip+1
.435b	4c c1 42	jmp $42c1		jmp xt_next
.435e					w_testname:
>435e	08					.byte $08
>435f	74 65 73 74 6e 61 6d 65			.text 'testname'
>4367	00 00 00 00 00 00 00 00			.fill 8,0
>436f	20 43					.word w_dodoes
.4371					xt_testname:
.4371	b5 02		lda $02,x		lda pstack+2,x
.4373	85 28		sta $28			sta test
.4375	b5 03		lda $03,x		lda pstack+3,x
.4377	85 29		sta $29			sta test+1
.4379	e8		inx			inx
.437a	e8		inx			inx
.437b	4c c1 42	jmp $42c1		jmp xt_next
.437e					w_assertx3d:
>437e	07					.byte $07
>437f	61 73 73 65 72 74 3d			.text 'assert='
>4386	00 00 00 00 00 00 00 00			.fill 9,0
>438e	00
>438f	5e 43					.word w_testname
.4391					xt_assertx3d:
.4391	b5 02		lda $02,x		lda pstack+2,x      ; Check to see if x1 and x2 are equal
.4393	d5 04		cmp $04,x		cmp pstack+4,x
.4395	d0 0e		bne $43a5		bne fail            ; If not, fail
.4397	b5 03		lda $03,x		lda pstack+3,x
.4399	d5 05		cmp $05,x		cmp pstack+5,x
.439b	d0 08		bne $43a5		bne fail
.439d	8a		txa			txa                 ; If so, clean up the stack
.439e	18		clc			clc
.439f	69 04		adc #$04		adc #4
.43a1	aa		tax			tax
.43a2	4c c1 42	jmp $42c1		jmp xt_next            ; And continue
.43a5						fail:
.43a5	a9 e2		lda #$e2		lda #<leadin        ; Print the failure message
.43a7	85 33		sta $33			sta src_ptr
.43a9	a9 43		lda #$43		lda #>leadin
.43ab	85 34		sta $34			sta src_ptr+1
.43ad	20 9d 42	jsr $429d		jsr prints
.43b0	a5 28		lda $28			lda test            ; Print the name of the test
.43b2	85 33		sta $33			sta src_ptr
.43b4	a5 29		lda $29			lda test+1
.43b6	85 34		sta $34			sta src_ptr+1
.43b8	20 9d 42	jsr $429d		jsr prints
.43bb	a9 f5		lda #$f5		lda #<actual        ; Print the "Actual" label
.43bd	85 33		sta $33			sta src_ptr
.43bf	a9 43		lda #$43		lda #>actual
.43c1	85 34		sta $34			sta src_ptr+1
.43c3	20 9d 42	jsr $429d		jsr prints
.43c6	b4 05		ldy $05,x		ldy pstack+5,x      ; Print the actual value computed
.43c8	b5 04		lda $04,x		lda pstack+4,x
.43ca	20 83 42	jsr $4283		jsr printyah
.43cd	a9 e9		lda #$e9		lda #<expected      ; Print the "Expected" label
.43cf	85 33		sta $33			sta src_ptr
.43d1	a9 43		lda #$43		lda #>expected
.43d3	85 34		sta $34			sta src_ptr+1
.43d5	20 9d 42	jsr $429d		jsr prints
.43d8	b4 03		ldy $03,x		ldy pstack+3,x      ; Print the expected value
.43da	b5 02		lda $02,x		lda pstack+2,x
.43dc	20 83 42	jsr $4283		jsr printyah
.43df						lock:
.43df	ea		nop			nop                 ; Lock up
.43e0	80 fd		bra $43df		bra lock
.43e2						leadin:
>43e2	46 41 49 4c 3a 20 00			.null "FAIL: "
.43e9						expected:
>43e9	20 45 58 50 45 43 54 45			.null " EXPECTED: "
>43f1	44 3a 20 00
.43f5						actual:
>43f5	20 41 43 54 55 41 4c 3a			.null " ACTUAL: "
>43fd	20 00
.43ff					w_halt:
>43ff	04					.byte $04
>4400	68 61 6c 74				.text 'halt'
>4404	00 00 00 00 00 00 00 00			.fill 12,0
>440c	00 00 00 00
>4410	7e 43					.word w_assertx3d
.4412					xt_halt:
.4412	a9 76		lda #$76		lda #<registers         ; Print register banner
.4414	85 33		sta $33			sta src_ptr
.4416	a9 44		lda #$44		lda #>registers
.4418	85 34		sta $34			sta src_ptr+1
.441a	20 9d 42	jsr $429d		jsr prints
.441d	a4 21		ldy $21			ldy ip+1                ; Print the IP
.441f	a5 20		lda $20			lda ip
.4421	20 83 42	jsr $4283		jsr printyah
.4424	a9 20		lda #$20		lda #' '
.4426	20 12 42	jsr $4212		jsr conout
.4429	a4 23		ldy $23			ldy wp+1                ; Print the WP
.442b	a5 22		lda $22			lda wp
.442d	20 83 42	jsr $4283		jsr printyah
.4430	a9 20		lda #$20		lda #' '
.4432	20 12 42	jsr $4212		jsr conout
.4435	86 2e		stx $2e			stx savex               ; Print the return stack pointer
.4437	a0 01		ldy #$01		ldy #$01
.4439	ba		tsx			tsx
.443a	8a		txa			txa
.443b	20 83 42	jsr $4283		jsr printyah
.443e	a6 2e		ldx $2e			ldx savex
.4440	a9 20		lda #$20		lda #' '
.4442	20 12 42	jsr $4212		jsr conout
.4445	a0 00		ldy #$00		ldy #0                  ; Print the parameter stack pointer
.4447	8a		txa			txa
.4448	20 83 42	jsr $4283		jsr printyah
.444b	a9 0d		lda #$0d		lda #13
.444d	20 12 42	jsr $4212		jsr conout
.4450	e0 6e		cpx #$6e		cpx #$6e                ; Check to see if there is anything on the parameter stack
.4452	b0 1f		bcs $4473		bge lock
.4454	a9 44		lda #$44		lda #>stackmsg          ; Yes: print the stack message and the stack contents
.4456	85 34		sta $34			sta src_ptr+1
.4458	a9 91		lda #$91		lda #<stackmsg
.445a	85 33		sta $33			sta src_ptr
.445c	20 9d 42	jsr $429d		jsr prints
.445f						loop:
.445f	e0 6e		cpx #$6e		cpx #$6e
.4461	b0 10		bcs $4473		bge lock
.4463	b4 03		ldy $03,x		ldy pstack+3,x
.4465	b5 02		lda $02,x		lda pstack+2,x
.4467	e8		inx			inx
.4468	e8		inx			inx
.4469	20 83 42	jsr $4283		jsr printyah
.446c	a9 20		lda #$20		lda #' '
.446e	20 12 42	jsr $4212		jsr conout
.4471	80 ec		bra $445f		bra loop
.4473						lock:
.4473						wait:
.4473	ea		nop			nop
.4474	80 fd		bra $4473		bra wait
>4476	0d 0d 7c 20 20 20 49 50			registers:  .text 13,13,"|   IP   WP  RSP  PSP",13
>447e	20 20 20 57 50 20 20 52 53 50 20 20 50 53 50 0d
>448e	7c 20 00				.null "| "
>4491	0d 50 61 72 61 6d 65 74			stackmsg:   .null 13,"Parameter Stack:",13
>4499	65 72 20 53 74 61 63 6b 3a 0d 00
.44a4					w_rpx40:
>44a4	03					.byte $03
>44a5	72 70 40				.text 'rp@'
>44a8	00 00 00 00 00 00 00 00			.fill 13,0
>44b0	00 00 00 00 00
>44b5	ff 43					.word w_halt
.44b7					xt_rpx40:
.44b7	86 2e		stx $2e			stx savex           ; Save the parameter stack pointer
.44b9	ba		tsx			tsx                 ; Get the return stack pointer
.44ba	85 2a		sta $2a			sta tmp             ; Save it for later
.44bc	a6 2e		ldx $2e			ldx savex           ; Recover the parameter stack pointer
.44be	a9 01		lda #$01		lda #$01            ; Get the high byte of the RSP
.44c0	95 01		sta $01,x		sta pstack+1,x      ; Save it to the parameter stack
.44c2	a5 2a		lda $2a			lda tmp             ; Get the low byte of the RSP
.44c4	95 00		sta $00,x		sta pstack,x        ; Save it to the parameter stack
.44c6	ca		dex			dex
.44c7	ca		dex			dex
.44c8	4c c1 42	jmp $42c1		jmp xt_next
.44cb					w_rpx21:
>44cb	03					.byte $03
>44cc	72 70 21				.text 'rp!'
>44cf	00 00 00 00 00 00 00 00			.fill 13,0
>44d7	00 00 00 00 00
>44dc	a4 44					.word w_rpx40
.44de					xt_rpx21:
.44de	86 2e		stx $2e			stx savex           ; Save the parameter stack pointer
.44e0	b5 02		lda $02,x		lda pstack+2,x      ; Get the new RSP from the parameter stack
.44e2	aa		tax			tax
.44e3	9a		txs			txs                 ; Set the RSP
.44e4	a6 2e		ldx $2e			ldx savex           ; Restore the parameter stack pointer
.44e6	e8		inx			inx
.44e7	e8		inx			inx
.44e8	4c c1 42	jmp $42c1		jmp xt_next
.44eb					w_spx40:
>44eb	03					.byte $03
>44ec	73 70 40				.text 'sp@'
>44ef	00 00 00 00 00 00 00 00			.fill 13,0
>44f7	00 00 00 00 00
>44fc	cb 44					.word w_rpx21
.44fe					xt_spx40:
.44fe	a9 00		lda #$00		lda #>pstack        ; Get the high byte of the stack address
.4500	95 01		sta $01,x		sta pstack+1,x      ; And push it to the stack
.4502	8a		txa			txa                 ; Get the low byte of the stack address
.4503	95 00		sta $00,x		sta pstack,x        ; And push it to the stack
.4505	ca		dex			dex
.4506	ca		dex			dex
.4507	4c c1 42	jmp $42c1		jmp xt_next
.450a					w_spx21:
>450a	03					.byte $03
>450b	73 70 21				.text 'sp!'
>450e	00 00 00 00 00 00 00 00			.fill 13,0
>4516	00 00 00 00 00
>451b	eb 44					.word w_spx40
.451d					xt_spx21:
.451d	b5 02		lda $02,x		lda pstack+2,x      ; Get the address from the stack
.451f	aa		tax			tax                 ; And set the stack pointer
.4520	4c c1 42	jmp $42c1		jmp xt_next
.4523					w_emit:
>4523	04					.byte $04
>4524	65 6d 69 74				.text 'emit'
>4528	00 00 00 00 00 00 00 00			.fill 12,0
>4530	00 00 00 00
>4534	0a 45					.word w_spx21
.4536					xt_emit:
.4536	b5 02		lda $02,x		lda pstack+2,x
.4538	da		phx			phx
.4539	20 12 42	jsr $4212		jsr conout
.453c	fa		plx			plx
.453d	e8		inx			inx
.453e	e8		inx			inx
.453f	4c c1 42	jmp $42c1		jmp xt_next
.4542					w_keyx3f:
>4542	04					.byte $04
>4543	6b 65 79 3f				.text 'key?'
>4547	00 00 00 00 00 00 00 00			.fill 12,0
>454f	00 00 00 00
>4553	23 45					.word w_emit
.4555					xt_keyx3f:
.4555	20 cc 40	jsr $40cc		jsr constat
.4558	29 01		and #$01		and #1
.455a	f0 06		beq $4562		beq waiting
.455c	74 00		stz $00,x		stz pstack,x
.455e	74 01		stz $01,x		stz pstack+1,x
.4560	80 06		bra $4568		bra done
.4562						waiting:
.4562	a9 ff		lda #$ff		lda #$ff
.4564	95 00		sta $00,x		sta pstack,x
.4566	95 01		sta $01,x		sta pstack+1,x
.4568						done:
.4568	ca		dex			dex
.4569	ca		dex			dex
.456a	4c c1 42	jmp $42c1		jmp xt_next
.456d					w_key:
>456d	03					.byte $03
>456e	6b 65 79				.text 'key'
>4571	00 00 00 00 00 00 00 00			.fill 13,0
>4579	00 00 00 00 00
>457e	42 45					.word w_keyx3f
.4580					xt_key:
.4580	da		phx			phx
.4581						wait:
.4581	20 cf 40	jsr $40cf		jsr conin
.4584	c9 00		cmp #$00		cmp #0
.4586	f0 f9		beq $4581		beq wait
.4588	fa		plx			plx
.4589	95 00		sta $00,x		sta pstack,x
.458b	74 01		stz $01,x		stz pstack+1,x
.458d	ca		dex			dex
.458e	ca		dex			dex
.458f	4c c1 42	jmp $42c1		jmp xt_next
.4592					w_cr:
>4592	02					.byte $02
>4593	63 72					.text 'cr'
>4595	00 00 00 00 00 00 00 00			.fill 14,0
>459d	00 00 00 00 00 00
>45a3	6d 45					.word w_key
.45a5					xt_cr:
.45a5	da		phx			phx
.45a6	a9 0d		lda #$0d		lda #$0d
.45a8	20 12 42	jsr $4212		jsr conout
.45ab	fa		plx			plx
.45ac	4c c1 42	jmp $42c1		jmp xt_next
.45af					w_0:
>45af	01					.byte $01
>45b0	30					.text '0'
>45b1	00 00 00 00 00 00 00 00			.fill 15,0
>45b9	00 00 00 00 00 00 00
>45c0	92 45					.word w_cr
.45c2					xt_0:
.45c2	74 01		stz $01,x		stz pstack+1,x
.45c4	74 00		stz $00,x		stz pstack,x
.45c6	ca		dex			dex
.45c7	ca		dex			dex
.45c8	4c c1 42	jmp $42c1		jmp xt_next
.45cb					w_1:
>45cb	01					.byte $01
>45cc	31					.text '1'
>45cd	00 00 00 00 00 00 00 00			.fill 15,0
>45d5	00 00 00 00 00 00 00
>45dc	af 45					.word w_0
.45de					xt_1:
.45de	74 01		stz $01,x		stz pstack+1,x
.45e0	a9 01		lda #$01		lda #1
.45e2	95 00		sta $00,x		sta pstack,x
.45e4	ca		dex			dex
.45e5	ca		dex			dex
.45e6	4c c1 42	jmp $42c1		jmp xt_next
.45e9					w_2:
>45e9	01					.byte $01
>45ea	32					.text '2'
>45eb	00 00 00 00 00 00 00 00			.fill 15,0
>45f3	00 00 00 00 00 00 00
>45fa	cb 45					.word w_1
.45fc					xt_2:
.45fc	74 01		stz $01,x		stz pstack+1,x
.45fe	a9 02		lda #$02		lda #2
.4600	95 00		sta $00,x		sta pstack,x
.4602	ca		dex			dex
.4603	ca		dex			dex
.4604	4c c1 42	jmp $42c1		jmp xt_next
.4607					w_x2d1:
>4607	02					.byte $02
>4608	2d 31					.text '-1'
>460a	00 00 00 00 00 00 00 00			.fill 14,0
>4612	00 00 00 00 00 00
>4618	e9 45					.word w_2
.461a					xt_x2d1:
.461a	a9 ff		lda #$ff		lda #$ff
.461c	95 01		sta $01,x		sta pstack+1,x
.461e	95 00		sta $00,x		sta pstack,x
.4620	ca		dex			dex
.4621	ca		dex			dex
.4622	4c c1 42	jmp $42c1		jmp xt_next
.4625					w_x2d2:
>4625	02					.byte $02
>4626	2d 32					.text '-2'
>4628	00 00 00 00 00 00 00 00			.fill 14,0
>4630	00 00 00 00 00 00
>4636	07 46					.word w_x2d1
.4638					xt_x2d2:
.4638	a9 fe		lda #$fe		lda #$fe
.463a	95 01		sta $01,x		sta pstack+1,x
.463c	95 00		sta $00,x		sta pstack,x
.463e	ca		dex			dex
.463f	ca		dex			dex
.4640	4c c1 42	jmp $42c1		jmp xt_next
.4643					w_x28literalx29:
>4643	09					.byte $09
>4644	28 6c 69 74 65 72 61 6c			.text '(literal)'
>464c	29
>464d	00 00 00 00 00 00 00			.fill 7,0
>4654	25 46					.word w_x2d2
.4656					xt_x28literalx29:
.4656	a0 01		ldy #$01		ldy #1
.4658	b2 20		lda ($20)		lda (ip)
.465a	95 00		sta $00,x		sta pstack,x
.465c	b1 20		lda ($20),y		lda (ip),y
.465e	95 01		sta $01,x		sta pstack+1,x
.4660	ca		dex			dex
.4661	ca		dex			dex
.4662	18		clc			clc
.4663	a5 20		lda $20			lda ip
.4665	69 02		adc #$02		adc #2
.4667	85 20		sta $20			sta ip
.4669	a5 21		lda $21			lda ip+1
.466b	69 00		adc #$00		adc #0
.466d	85 21		sta $21			sta ip+1
.466f	4c c1 42	jmp $42c1		jmp xt_next
.4672					w_x28dliteralx29:
>4672	0a					.byte $0A
>4673	28 64 6c 69 74 65 72 61			.text '(dliteral)'
>467b	6c 29
>467d	00 00 00 00 00 00			.fill 6,0
>4683	43 46					.word w_x28literalx29
.4685					xt_x28dliteralx29:
.4685	a0 01		ldy #$01		ldy #1
.4687	b2 20		lda ($20)		lda (ip)
.4689	95 00		sta $00,x		sta pstack,x
.468b	b1 20		lda ($20),y		lda (ip),y
.468d	95 01		sta $01,x		sta pstack+1,x
.468f	c8		iny			iny
.4690	95 02		sta $02,x		sta pstack+2,x
.4692	c8		iny			iny
.4693	95 03		sta $03,x		sta pstack+3,x
.4695	ca		dex			dex
.4696	ca		dex			dex
.4697	ca		dex			dex
.4698	ca		dex			dex
.4699	18		clc			clc
.469a	a5 20		lda $20			lda ip
.469c	69 02		adc #$02		adc #2
.469e	85 20		sta $20			sta ip
.46a0	a5 21		lda $21			lda ip+1
.46a2	69 00		adc #$00		adc #0
.46a4	85 21		sta $21			sta ip+1
.46a6	4c c1 42	jmp $42c1		jmp xt_next
.46a9					w_depth:
>46a9	05					.byte $05
>46aa	64 65 70 74 68				.text 'depth'
>46af	00 00 00 00 00 00 00 00			.fill 11,0
>46b7	00 00 00
>46ba	72 46					.word w_x28dliteralx29
.46bc					xt_depth:
.46bc	86 2a		stx $2a			stx tmp
.46be	38		sec			sec
.46bf	a9 6e		lda #$6e		lda #$6e
.46c1	e5 2a		sbc $2a			sbc tmp
.46c3	4a		lsr a			lsr a
.46c4	74 01		stz $01,x		stz pstack+1,x
.46c6	95 00		sta $00,x		sta pstack,x
.46c8	ca		dex			dex
.46c9	ca		dex			dex
.46ca	4c c1 42	jmp $42c1		jmp xt_next
.46cd					w_drop:
>46cd	04					.byte $04
>46ce	64 72 6f 70				.text 'drop'
>46d2	00 00 00 00 00 00 00 00			.fill 12,0
>46da	00 00 00 00
>46de	a9 46					.word w_depth
.46e0					xt_drop:
.46e0	e8		inx			inx
.46e1	e8		inx			inx
.46e2	4c c1 42	jmp $42c1		jmp xt_next
.46e5					w_dup:
>46e5	03					.byte $03
>46e6	64 75 70				.text 'dup'
>46e9	00 00 00 00 00 00 00 00			.fill 13,0
>46f1	00 00 00 00 00
>46f6	cd 46					.word w_drop
.46f8					xt_dup:
.46f8	b5 02		lda $02,x		lda pstack+2,x
.46fa	95 00		sta $00,x		sta pstack,x
.46fc	b5 03		lda $03,x		lda pstack+3,x
.46fe	95 01		sta $01,x		sta pstack+1,x
.4700	ca		dex			dex
.4701	ca		dex			dex
.4702	4c c1 42	jmp $42c1		jmp xt_next
.4705					w_swap:
>4705	04					.byte $04
>4706	73 77 61 70				.text 'swap'
>470a	00 00 00 00 00 00 00 00			.fill 12,0
>4712	00 00 00 00
>4716	e5 46					.word w_dup
.4718					xt_swap:
.4718	b5 02		lda $02,x		lda pstack+2,x
.471a	b4 04		ldy $04,x		ldy pstack+4,x
.471c	94 02		sty $02,x		sty pstack+2,x
.471e	95 04		sta $04,x		sta pstack+4,x
.4720	b5 03		lda $03,x		lda pstack+3,x
.4722	b4 05		ldy $05,x		ldy pstack+5,x
.4724	94 03		sty $03,x		sty pstack+3,x
.4726	95 05		sta $05,x		sta pstack+5,x
.4728	4c c1 42	jmp $42c1		jmp xt_next
.472b					w_2swap:
>472b	05					.byte $05
>472c	32 73 77 61 70				.text '2swap'
>4731	00 00 00 00 00 00 00 00			.fill 11,0
>4739	00 00 00
>473c	05 47					.word w_swap
.473e					xt_2swap:
.473e	b5 05		lda $05,x		lda pstack+5,x
.4740	48		pha			pha
.4741	b5 04		lda $04,x		lda pstack+4,x
.4743	48		pha			pha
.4744	b5 03		lda $03,x		lda pstack+3,x
.4746	48		pha			pha
.4747	b5 02		lda $02,x		lda pstack+2,x
.4749	48		pha			pha
.474a	b5 09		lda $09,x		lda pstack+9,x
.474c	95 05		sta $05,x		sta pstack+5,x
.474e	b5 08		lda $08,x		lda pstack+8,x
.4750	95 04		sta $04,x		sta pstack+4,x
.4752	b5 07		lda $07,x		lda pstack+7,x
.4754	95 03		sta $03,x		sta pstack+3,x
.4756	b5 06		lda $06,x		lda pstack+6,x
.4758	95 02		sta $02,x		sta pstack+2,x
.475a	68		pla			pla
.475b	95 06		sta $06,x		sta pstack+6,x
.475d	68		pla			pla
.475e	95 07		sta $07,x		sta pstack+7,x
.4760	68		pla			pla
.4761	95 08		sta $08,x		sta pstack+8,x
.4763	68		pla			pla
.4764	95 09		sta $09,x		sta pstack+9,x
.4766	4c c1 42	jmp $42c1		jmp xt_next
.4769					w_over:
>4769	04					.byte $04
>476a	6f 76 65 72				.text 'over'
>476e	00 00 00 00 00 00 00 00			.fill 12,0
>4776	00 00 00 00
>477a	2b 47					.word w_2swap
.477c					xt_over:
.477c	b5 04		lda $04,x		lda pstack+4,x
.477e	95 00		sta $00,x		sta pstack,x
.4780	b5 05		lda $05,x		lda pstack+5,x
.4782	95 01		sta $01,x		sta pstack+1,x
.4784	ca		dex			dex
.4785	ca		dex			dex
.4786	4c c1 42	jmp $42c1		jmp xt_next
.4789					w_2over:
>4789	05					.byte $05
>478a	32 6f 76 65 72				.text '2over'
>478f	00 00 00 00 00 00 00 00			.fill 11,0
>4797	00 00 00
>479a	69 47					.word w_over
.479c					xt_2over:
.479c	ca		dex			dex
.479d	ca		dex			dex
.479e	ca		dex			dex
.479f	ca		dex			dex
.47a0	b5 0d		lda $0d,x		lda pstack+13,x
.47a2	95 05		sta $05,x		sta pstack+5,x
.47a4	b5 0c		lda $0c,x		lda pstack+12,x
.47a6	95 04		sta $04,x		sta pstack+4,x
.47a8	b5 0b		lda $0b,x		lda pstack+11,x
.47aa	95 03		sta $03,x		sta pstack+3,x
.47ac	b5 0a		lda $0a,x		lda pstack+10,x
.47ae	95 02		sta $02,x		sta pstack+2,x
.47b0	4c c1 42	jmp $42c1		jmp xt_next
.47b3					w_x3er:
>47b3	02					.byte $02
>47b4	3e 72					.text '>r'
>47b6	00 00 00 00 00 00 00 00			.fill 14,0
>47be	00 00 00 00 00 00
>47c4	89 47					.word w_2over
.47c6					xt_x3er:
.47c6	b5 03		lda $03,x		lda pstack+3,x
.47c8	48		pha			pha
.47c9	b5 02		lda $02,x		lda pstack+2,x
.47cb	48		pha			pha
.47cc	e8		inx			inx
.47cd	e8		inx			inx
.47ce	4c c1 42	jmp $42c1		jmp xt_next
.47d1					w_rx3e:
>47d1	02					.byte $02
>47d2	72 3e					.text 'r>'
>47d4	00 00 00 00 00 00 00 00			.fill 14,0
>47dc	00 00 00 00 00 00
>47e2	b3 47					.word w_x3er
.47e4					xt_rx3e:
.47e4	68		pla			pla
.47e5	95 00		sta $00,x		sta pstack,x
.47e7	68		pla			pla
.47e8	95 01		sta $01,x		sta pstack+1,x
.47ea	ca		dex			dex
.47eb	ca		dex			dex
.47ec	4c c1 42	jmp $42c1		jmp xt_next
.47ef					w_r:
>47ef	01					.byte $01
>47f0	72					.text 'r'
>47f1	00 00 00 00 00 00 00 00			.fill 15,0
>47f9	00 00 00 00 00 00 00
>4800	d1 47					.word w_rx3e
.4802					xt_r:
.4802	68		pla			pla
.4803	95 00		sta $00,x		sta pstack,x
.4805	68		pla			pla
.4806	95 01		sta $01,x		sta pstack+1,x
.4808	48		pha			pha
.4809	b5 00		lda $00,x		lda pstack,x
.480b	48		pha			pha
.480c	ca		dex			dex
.480d	ca		dex			dex
.480e	4c c1 42	jmp $42c1		jmp xt_next
.4811					w_rdrop:
>4811	05					.byte $05
>4812	72 64 72 6f 70				.text 'rdrop'
>4817	00 00 00 00 00 00 00 00			.fill 11,0
>481f	00 00 00
>4822	ef 47					.word w_r
.4824					xt_rdrop:
.4824	68		pla			pla
.4825	68		pla			pla
.4826					w_x21:
>4826	01					.byte $01
>4827	21					.text '!'
>4828	00 00 00 00 00 00 00 00			.fill 15,0
>4830	00 00 00 00 00 00 00
>4837	11 48					.word w_rdrop
.4839					xt_x21:
.4839	b5 02		lda $02,x		lda pstack+2,x
.483b	85 2a		sta $2a			sta tmp
.483d	b5 03		lda $03,x		lda pstack+3,x
.483f	85 2b		sta $2b			sta tmp+1
.4841	a0 01		ldy #$01		ldy #1
.4843	b5 04		lda $04,x		lda pstack+4,x
.4845	92 2a		sta ($2a)		sta (tmp)
.4847	b5 05		lda $05,x		lda pstack+5,x
.4849	91 2a		sta ($2a),y		sta (tmp),y
.484b	e8		inx			inx
.484c	e8		inx			inx
.484d	e8		inx			inx
.484e	e8		inx			inx
.484f	4c c1 42	jmp $42c1		jmp xt_next
.4852					w_x40:
>4852	01					.byte $01
>4853	40					.text '@'
>4854	00 00 00 00 00 00 00 00			.fill 15,0
>485c	00 00 00 00 00 00 00
>4863	26 48					.word w_x21
.4865					xt_x40:
.4865	b5 02		lda $02,x		lda pstack+2,x
.4867	85 2a		sta $2a			sta tmp
.4869	b5 03		lda $03,x		lda pstack+3,x
.486b	85 2b		sta $2b			sta tmp+1
.486d	a0 01		ldy #$01		ldy #1
.486f	b2 2a		lda ($2a)		lda (tmp)
.4871	95 02		sta $02,x		sta pstack+2,x
.4873	b1 2a		lda ($2a),y		lda (tmp),y
.4875	95 03		sta $03,x		sta pstack+3,x
.4877	4c c1 42	jmp $42c1		jmp xt_next
.487a					w_cx21:
>487a	02					.byte $02
>487b	63 21					.text 'c!'
>487d	00 00 00 00 00 00 00 00			.fill 14,0
>4885	00 00 00 00 00 00
>488b	52 48					.word w_x40
.488d					xt_cx21:
.488d	b5 04		lda $04,x		lda pstack+4,x
.488f	81 02		sta ($02,x)		sta (pstack+2,x)
.4891	e8		inx			inx
.4892	e8		inx			inx
.4893	e8		inx			inx
.4894	e8		inx			inx
.4895	4c c1 42	jmp $42c1		jmp xt_next
.4898					w_cx40:
>4898	02					.byte $02
>4899	63 40					.text 'c@'
>489b	00 00 00 00 00 00 00 00			.fill 14,0
>48a3	00 00 00 00 00 00
>48a9	7a 48					.word w_cx21
.48ab					xt_cx40:
.48ab	a1 02		lda ($02,x)		lda (pstack+2,x)
.48ad	95 02		sta $02,x		sta pstack+2,x
.48af	74 03		stz $03,x		stz pstack+3,x
.48b1	4c c1 42	jmp $42c1		jmp xt_next
.48b4					w_fill:
>48b4	04					.byte $04
>48b5	66 69 6c 6c				.text 'fill'
>48b9	00 00 00 00 00 00 00 00			.fill 12,0
>48c1	00 00 00 00
>48c5	98 48					.word w_cx40
.48c7					xt_fill:
.48c7						loop:
.48c7	b5 03		lda $03,x		lda pstack+3,x          ; Check to see if the count is 0
.48c9	d0 04		bne $48cf		bne do_write
.48cb	b5 04		lda $04,x		lda pstack+4,x
.48cd	f0 19		beq $48e8		beq done                ; Yes: we're done...
.48cf						do_write:
.48cf	b5 01		lda $01,x		lda pstack+1,x          ; No:; get the byte to use for the fill
.48d1	81 05		sta ($05,x)		sta (pstack+5,x)        ; And store it in the indicated location
.48d3	f6 05		inc $05,x		inc pstack+5,x          ; Increment the address
.48d5	d0 02		bne $48d9		bne deccount
.48d7	f6 06		inc $06,x		inc pstack+6,x
.48d9						deccount:
.48d9	38		sec			sec                     ; Decrement the count
.48da	b5 03		lda $03,x		lda pstack+3,x
.48dc	e9 01		sbc #$01		sbc #1
.48de	95 03		sta $03,x		sta pstack+3,x
.48e0	b5 04		lda $04,x		lda pstack+4,x
.48e2	e9 00		sbc #$00		sbc #0
.48e4	95 04		sta $04,x		sta pstack+4,x
.48e6	80 df		bra $48c7		bra loop                ; And check again
.48e8						done:
.48e8	8a		txa			txa                     ; Clean up the parameter stack
.48e9	69 06		adc #$06		adc #6
.48eb	aa		tax			tax
.48ec	4c c1 42	jmp $42c1		jmp xt_next
.48ef					w_x2bx21:
>48ef	02					.byte $02
>48f0	2b 21					.text '+!'
>48f2	00 00 00 00 00 00 00 00			.fill 14,0
>48fa	00 00 00 00 00 00
>4900	b4 48					.word w_fill
.4902					xt_x2bx21:
.4902	b5 03		lda $03,x		lda pstack+3,x
.4904	85 2b		sta $2b			sta tmp+1
.4906	b5 02		lda $02,x		lda pstack+2,x
.4908	85 2a		sta $2a			sta tmp
.490a	18		clc			clc
.490b	a0 01		ldy #$01		ldy #1
.490d	b2 2a		lda ($2a)		lda (tmp)
.490f	75 04		adc $04,x		adc pstack+4,x
.4911	92 2a		sta ($2a)		sta (tmp)
.4913	b1 2a		lda ($2a),y		lda (tmp),y
.4915	75 05		adc $05,x		adc pstack+5,x
.4917	91 2a		sta ($2a),y		sta (tmp),y
.4919						done:
.4919	e8		inx			inx                     ; Clean up the stack
.491a	e8		inx			inx
.491b	e8		inx			inx
.491c	e8		inx			inx
.491d	4c c1 42	jmp $42c1		jmp xt_next
.4920					w_enclose:
>4920	07					.byte $07
>4921	65 6e 63 6c 6f 73 65			.text 'enclose'
>4928	00 00 00 00 00 00 00 00			.fill 9,0
>4930	00
>4931	ef 48					.word w_x2bx21
.4933					xt_enclose:
.4933	b5 05		lda $05,x		lda pstack+5,x          ; Copy the address
.4935	85 34		sta $34			sta src_ptr+1
.4937	b5 04		lda $04,x		lda pstack+4,x
.4939	85 33		sta $33			sta src_ptr
.493b	b5 02		lda $02,x		lda pstack+2,x          ; tmp := c
.493d	85 2a		sta $2a			sta tmp
.493f	8a		txa			txa
.4940	38		sec			sec
.4941	e9 04		sbc #$04		sbc #4
.4943	aa		tax			tax
.4944	74 07		stz $07,x		stz pstack+7,x          ; n1 ... offset to first character
.4946	74 06		stz $06,x		stz pstack+6,x
.4948	74 05		stz $05,x		stz pstack+5,x          ; n2 ... offset to first delimiter
.494a	74 04		stz $04,x		stz pstack+4,x
.494c	74 03		stz $03,x		stz pstack+3,x          ; n3 ... n2 + 1 or n2
.494e	74 02		stz $02,x		stz pstack+2,x
.4950	a0 00		ldy #$00		ldy #0
.4952						loop1:
.4952	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character
.4954	d0 03		bne $4959		bne chk_delim1          ; NUL? No:; check it against the delimiter
.4956						none:
.4956	4c c1 42	jmp $42c1		jmp xt_next                ; Yes: we want to return 0s
.4959						chk_delim1:
.4959	c5 2a		cmp $2a			cmp tmp                 ; Is it the delimiter?
.495b	f0 13		beq $4970		beq skip2               ; Yes: skip the character
.495d	a5 2a		lda $2a			lda tmp                 ; Check the delimiter
.495f	c9 20		cmp #$20		cmp #' '                ; Is it BL?
.4961	d0 0b		bne $496e		bne found               ; No: ok, we've found the first character;
.4963	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character back
.4965	c9 09		cmp #$09		cmp #CHAR_TAB           ; Is it a TAB?
.4967	d0 05		bne $496e		bne found               ; No: we found the first character
.4969	c8		iny			iny                     ; Move to the next character
.496a	f0 ea		beq $4956		beq none                ; If we've rolled over, we found nothing
.496c	80 e4		bra $4952		bra loop1               ; Otherwise: check the next character
.496e						found:
.496e	94 06		sty $06,x		sty pstack+6,x          ; Save the offset to it in n1
.4970						skip2:
.4970	c8		iny			iny                     ; Go to the next character
.4971	f0 1c		beq $498f		beq found_nul           ; If it rolls over, we've reached the end (NUL)
.4973						loop2:
.4973	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character
.4975	f0 18		beq $498f		beq found_nul           ; If it is NUL, we've reached the end (NUL)
.4977	c5 2a		cmp $2a			cmp tmp                 ; Check it against the delimiter
.4979	f0 0c		beq $4987		beq found_delim         ; If it's the delimiter, we've reached the end (with delimiter)
.497b	a5 2a		lda $2a			lda tmp                 ; Get the delimiter
.497d	c9 20		cmp #$20		cmp #' '                ; Is it space?
.497f	d0 ef		bne $4970		bne skip2               ; No: go to the next character
.4981	b1 33		lda ($33),y		lda (src_ptr),y         ; Get the character again
.4983	c9 09		cmp #$09		cmp #CHAR_TAB           ; Is it a tab?
.4985	d0 e9		bne $4970		bne skip2               ; No: go to the next character
.4987						found_delim:
.4987	94 04		sty $04,x		sty pstack+4,x          ; Save the offset of the delimiter in n2
.4989	c8		iny			iny
.498a	94 02		sty $02,x		sty pstack+2,x          ; And the offset +1 to n3
.498c	4c c1 42	jmp $42c1		jmp xt_next                ; And we're done
.498f						found_nul:
.498f	94 04		sty $04,x		sty pstack+4,x          ; Save the offset of the delimiter in n2
.4991	94 02		sty $02,x		sty pstack+2,x          ; And to n3
.4993	4c c1 42	jmp $42c1		jmp xt_next                ; And we're done
.4996					w_cmove:
>4996	05					.byte $05
>4997	63 6d 6f 76 65				.text 'cmove'
>499c	00 00 00 00 00 00 00 00			.fill 11,0
>49a4	00 00 00
>49a7	20 49					.word w_enclose
.49a9					xt_cmove:
.49a9	b5 03		lda $03,x		lda pstack+3,x          ; Pull count off the stack
.49ab	85 2b		sta $2b			sta tmp+1
.49ad	b5 02		lda $02,x		lda pstack+2,x
.49af	85 2a		sta $2a			sta tmp
.49b1	b5 05		lda $05,x		lda pstack+5,x          ; Pull the dst_ptr
.49b3	85 36		sta $36			sta dst_ptr+1
.49b5	b5 04		lda $04,x		lda pstack+4,x
.49b7	85 35		sta $35			sta dst_ptr
.49b9	b5 07		lda $07,x		lda pstack+7,x          ; Pull the src_ptr
.49bb	85 34		sta $34			sta src_ptr+1
.49bd	b5 06		lda $06,x		lda pstack+6,x
.49bf	85 33		sta $33			sta src_ptr
.49c1	8a		txa			txa                     ; Clean up the stack
.49c2	18		clc			clc
.49c3	69 06		adc #$06		adc #6
.49c5	85 2e		sta $2e			sta savex               ; And save it for later restoration
.49c7	a2 00		ldx #$00		ldx #0                  ; We'll use X for the high byte of the count
.49c9	a0 00		ldy #$00		ldy #0                  ; and Y for the low byte of the count
.49cb						loop:
.49cb	e4 2b		cpx $2b			cpx tmp+1               ; is tmp == X:Y?
.49cd	d0 04		bne $49d3		bne copy
.49cf	c4 2a		cpy $2a			cpy tmp
.49d1	f0 0e		beq $49e1		beq done                ; Yes: we're done
.49d3						copy:
.49d3	b1 33		lda ($33),y		lda (src_ptr),y         ; Copy the byte
.49d5	91 35		sta ($35),y		sta (dst_ptr),y
.49d7	c8		iny			iny                     ; Move to the next byte
.49d8	d0 f1		bne $49cb		bne loop                ; Repeat for 256 bytes
.49da	e8		inx			inx                     ; Move to the next block of 256
.49db	e6 34		inc $34			inc src_ptr+1
.49dd	e6 36		inc $36			inc dst_ptr+1
.49df	80 ea		bra $49cb		bra loop                ; And continue the loop
.49e1						done:
.49e1	a6 2e		ldx $2e			ldx savex
.49e3	4c c1 42	jmp $42c1		jmp xt_next
.49e6					w_move:
>49e6	04					.byte $04
>49e7	6d 6f 76 65				.text 'move'
>49eb	00 00 00 00 00 00 00 00			.fill 12,0
>49f3	00 00 00 00
>49f7	96 49					.word w_cmove
.49f9					xt_move:
.49f9	38		sec			sec                     ; Compare addr1 and addr2
.49fa	b5 06		lda $06,x		lda pstack+6,x
.49fc	f5 04		sbc $04,x		sbc pstack+4,x
.49fe	85 2a		sta $2a			sta tmp
.4a00	b5 07		lda $07,x		lda pstack+7,x
.4a02	f5 05		sbc $05,x		sbc pstack+5,x
.4a04	85 2b		sta $2b			sta tmp+1
.4a06	30 24		bmi $4a2c		bmi a1less
.4a08	f0 72		beq $4a7c		beq chklo
.4a0a						a1greater:
.4a0a	b5 02		lda $02,x		lda pstack+2,x          ; Is u = 0?
.4a0c	d0 50		bne $4a5e		bne docopy1
.4a0e	b5 03		lda $03,x		lda pstack+3,x
.4a10	f0 72		beq $4a84		beq done                ; Yes: we're done;
.4a12	a1 06		lda ($06,x)		lda (pstack+6,x)        ; Get the source byte
.4a14	81 04		sta ($04,x)		sta (pstack+4,x)        ; Write it to the destination
.4a16	f6 06		inc $06,x		inc pstack+6,x          ; addr1 := addr1 + 1
.4a18	d0 02		bne $4a1c		bne inc2
.4a1a	f6 07		inc $07,x		inc pstack+7,x
.4a1c						inc2:
.4a1c	f6 04		inc $04,x		inc pstack+4,x          ; addr2 := addr2 + 1
.4a1e	d0 02		bne $4a22		bne dec_count
.4a20	f6 03		inc $03,x		inc pstack+3,x
.4a22						dec_count:
.4a22	b5 02		lda $02,x		lda pstack+2,x          ; Decrement counter
.4a24	d0 02		bne $4a28		bne l1
.4a26	d6 03		dec $03,x		dec pstack+3,x
.4a28						l1:
.4a28	d6 02		dec $02,x		dec pstack+2,x
.4a2a	80 de		bra $4a0a		bra a1greater
.4a2c						a1less:
.4a2c	b5 04		lda $04,x		lda pstack+4,x          ; Decrement addr2
.4a2e	d0 02		bne $4a32		bne l2
.4a30	d6 05		dec $05,x		dec pstack+5,x
.4a32						l2:
.4a32	d6 04		dec $04,x		dec pstack+4,x
.4a34	18		clc			clc                     ; addr2 := addr2 + u
.4a35	b5 04		lda $04,x		lda pstack+4,x
.4a37	75 02		adc $02,x		adc pstack+2,x
.4a39	95 04		sta $04,x		sta pstack+4,x
.4a3b	b5 05		lda $05,x		lda pstack+5,x
.4a3d	75 03		adc $03,x		adc pstack+3,x
.4a3f	95 05		sta $05,x		sta pstack+5,x
.4a41	b5 06		lda $06,x		lda pstack+6,x          ; Decrement addr1
.4a43	d0 02		bne $4a47		bne l3
.4a45	d6 07		dec $07,x		dec pstack+7,x
.4a47						l3:
.4a47	d6 06		dec $06,x		dec pstack+6,x
.4a49	18		clc			clc                     ; addr1 := addr1 + u
.4a4a	b5 06		lda $06,x		lda pstack+6,x
.4a4c	75 02		adc $02,x		adc pstack+2,x
.4a4e	95 06		sta $06,x		sta pstack+6,x
.4a50	b5 07		lda $07,x		lda pstack+7,x
.4a52	75 03		adc $03,x		adc pstack+3,x
.4a54	95 07		sta $07,x		sta pstack+7,x
.4a56						loop2:
.4a56	b5 02		lda $02,x		lda pstack+2,x          ; Is u = 0?
.4a58	d0 04		bne $4a5e		bne docopy1
.4a5a	b5 03		lda $03,x		lda pstack+3,x
.4a5c	f0 26		beq $4a84		beq done                ; Yes: we're done;
.4a5e						docopy1:
.4a5e	a1 06		lda ($06,x)		lda (pstack+6,x)        ; Get the source byte
.4a60	81 04		sta ($04,x)		sta (pstack+4,x)        ; Write it to the destination
.4a62	b5 06		lda $06,x		lda pstack+6,x          ; Decrement addr1
.4a64	d0 02		bne $4a68		bne l4
.4a66	d6 07		dec $07,x		dec pstack+7,x
.4a68						l4:
.4a68	d6 06		dec $06,x		dec pstack+6,x
.4a6a	b5 04		lda $04,x		lda pstack+4,x          ; Decrement addr2
.4a6c	d0 02		bne $4a70		bne l5
.4a6e	d6 05		dec $05,x		dec pstack+5,x
.4a70						l5:
.4a70	d6 04		dec $04,x		dec pstack+4,x
.4a72	b5 02		lda $02,x		lda pstack+2,x          ; Decrement counter
.4a74	d0 02		bne $4a78		bne l6
.4a76	d6 03		dec $03,x		dec pstack+3,x
.4a78						l6:
.4a78	d6 02		dec $02,x		dec pstack+2,x
.4a7a	80 da		bra $4a56		bra loop2
.4a7c						chklo:
.4a7c	a5 2a		lda $2a			lda tmp                 ; High bytes are equal: check the low byte
.4a7e	30 ac		bmi $4a2c		bmi a1less
.4a80	f0 02		beq $4a84		beq done                ; If equal, we don't need to move the data
.4a82	80 86		bra $4a0a		bra a1greater
.4a84						done:
.4a84	8a		txa			txa
.4a85	18		clc			clc
.4a86	69 06		adc #$06		adc #6
.4a88	aa		tax			tax
.4a89	60		rts			rts
.4a8a					w_x2b:
>4a8a	01					.byte $01
>4a8b	2b					.text '+'
>4a8c	00 00 00 00 00 00 00 00			.fill 15,0
>4a94	00 00 00 00 00 00 00
>4a9b	e6 49					.word w_move
.4a9d					xt_x2b:
.4a9d	18		clc			clc
.4a9e	b5 04		lda $04,x		lda pstack+4,x
.4aa0	75 02		adc $02,x		adc pstack+2,x
.4aa2	95 04		sta $04,x		sta pstack+4,x
.4aa4	b5 05		lda $05,x		lda pstack+5,x
.4aa6	75 03		adc $03,x		adc pstack+3,x
.4aa8	95 05		sta $05,x		sta pstack+5,x
.4aaa	e8		inx			inx
.4aab	e8		inx			inx
.4aac	4c c1 42	jmp $42c1		jmp xt_next
.4aaf					w_dx2b:
>4aaf	02					.byte $02
>4ab0	64 2b					.text 'd+'
>4ab2	00 00 00 00 00 00 00 00			.fill 14,0
>4aba	00 00 00 00 00 00
>4ac0	8a 4a					.word w_x2b
.4ac2					xt_dx2b:
.4ac2	18		clc			clc
.4ac3	b5 06		lda $06,x		lda pstack+6,x
.4ac5	75 02		adc $02,x		adc pstack+2,x
.4ac7	95 06		sta $06,x		sta pstack+6,x
.4ac9	b5 07		lda $07,x		lda pstack+7,x
.4acb	75 03		adc $03,x		adc pstack+3,x
.4acd	95 07		sta $07,x		sta pstack+7,x
.4acf	b5 08		lda $08,x		lda pstack+8,x
.4ad1	75 04		adc $04,x		adc pstack+4,x
.4ad3	95 08		sta $08,x		sta pstack+8,x
.4ad5	b5 09		lda $09,x		lda pstack+9,x
.4ad7	75 05		adc $05,x		adc pstack+5,x
.4ad9	95 09		sta $09,x		sta pstack+9,x
.4adb	e8		inx			inx
.4adc	e8		inx			inx
.4add	e8		inx			inx
.4ade	e8		inx			inx
.4adf	4c c1 42	jmp $42c1		jmp xt_next
.4ae2					w_dx2d:
>4ae2	02					.byte $02
>4ae3	64 2d					.text 'd-'
>4ae5	00 00 00 00 00 00 00 00			.fill 14,0
>4aed	00 00 00 00 00 00
>4af3	af 4a					.word w_dx2b
.4af5					xt_dx2d:
.4af5	38		sec			sec
.4af6	b5 06		lda $06,x		lda pstack+6,x
.4af8	f5 02		sbc $02,x		sbc pstack+2,x
.4afa	95 06		sta $06,x		sta pstack+6,x
.4afc	b5 07		lda $07,x		lda pstack+7,x
.4afe	f5 03		sbc $03,x		sbc pstack+3,x
.4b00	95 07		sta $07,x		sta pstack+7,x
.4b02	b5 08		lda $08,x		lda pstack+8,x
.4b04	f5 04		sbc $04,x		sbc pstack+4,x
.4b06	95 08		sta $08,x		sta pstack+8,x
.4b08	b5 09		lda $09,x		lda pstack+9,x
.4b0a	f5 05		sbc $05,x		sbc pstack+5,x
.4b0c	95 09		sta $09,x		sta pstack+9,x
.4b0e	e8		inx			inx
.4b0f	e8		inx			inx
.4b10	e8		inx			inx
.4b11	e8		inx			inx
.4b12	4c c1 42	jmp $42c1		jmp xt_next
.4b15					w_x2d:
>4b15	01					.byte $01
>4b16	2d					.text '-'
>4b17	00 00 00 00 00 00 00 00			.fill 15,0
>4b1f	00 00 00 00 00 00 00
>4b26	e2 4a					.word w_dx2d
.4b28					xt_x2d:
.4b28	38		sec			sec
.4b29	b5 04		lda $04,x		lda pstack+4,x
.4b2b	f5 02		sbc $02,x		sbc pstack+2,x
.4b2d	95 04		sta $04,x		sta pstack+4,x
.4b2f	b5 05		lda $05,x		lda pstack+5,x
.4b31	f5 03		sbc $03,x		sbc pstack+3,x
.4b33	95 05		sta $05,x		sta pstack+5,x
.4b35	e8		inx			inx
.4b36	e8		inx			inx
.4b37	4c c1 42	jmp $42c1		jmp xt_next
.4b3a					w_ux2a:
>4b3a	02					.byte $02
>4b3b	75 2a					.text 'u*'
>4b3d	00 00 00 00 00 00 00 00			.fill 14,0
>4b45	00 00 00 00 00 00
>4b4b	15 4b					.word w_x2d
.4b4d					xt_ux2a:
.4b4d	64 01		stz $01			stz MMU_IO_CTRL ; Go to I/O page #0
.4b4f	b5 05		lda $05,x		lda pstack+5,x  ; Set coprocessor unsigned A argument
.4b51	8d 01 de	sta $de01		sta $de01
.4b54	b5 04		lda $04,x		lda pstack+4,x
.4b56	8d 00 de	sta $de00		sta $de00
.4b59	b5 03		lda $03,x		lda pstack+3,x  ; Set coprocessor unsigned B argument
.4b5b	8d 03 de	sta $de03		sta $de03
.4b5e	b5 02		lda $02,x		lda pstack+2,x
.4b60	8d 02 de	sta $de02		sta $de02
.4b63	e8		inx			inx
.4b64	e8		inx			inx
.4b65	ad 05 de	lda $de05		lda $de05       ; Read the coprocessor unsigned multiplication result
.4b68	95 03		sta $03,x		sta pstack+3,x
.4b6a	ad 04 de	lda $de04		lda $de04
.4b6d	95 02		sta $02,x		sta pstack+2,x
.4b6f	4c c1 42	jmp $42c1		jmp xt_next
.4b72					w_x2a:
>4b72	01					.byte $01
>4b73	2a					.text '*'
>4b74	00 00 00 00 00 00 00 00			.fill 15,0
>4b7c	00 00 00 00 00 00 00
>4b83	3a 4b					.word w_ux2a
.4b85					xt_x2a:
.4b85	64 01		stz $01			stz MMU_IO_CTRL ; Go to I/O page #0
.4b87	b5 05		lda $05,x		lda pstack+5,x  ; Set coprocessor unsigned A argument
.4b89	8d 05 de	sta $de05		sta $de05
.4b8c	b5 04		lda $04,x		lda pstack+4,x
.4b8e	8d 04 de	sta $de04		sta $de04
.4b91	b5 03		lda $03,x		lda pstack+3,x  ; Set coprocessor unsigned B argument
.4b93	8d 07 de	sta $de07		sta $de07
.4b96	b5 02		lda $02,x		lda pstack+2,x
.4b98	8d 06 de	sta $de06		sta $de06
.4b9b	e8		inx			inx
.4b9c	e8		inx			inx
.4b9d	ad 0d de	lda $de0d		lda $de0d       ; Read the coprocessor unsigned multiplication result
.4ba0	95 03		sta $03,x		sta pstack+3,x
.4ba2	ad 0c de	lda $de0c		lda $de0c
.4ba5	95 02		sta $02,x		sta pstack+2,x
.4ba7	4c c1 42	jmp $42c1		jmp xt_next
.4baa					w_ux2ax2dsoft:
>4baa	07					.byte $07
>4bab	75 2a 2d 73 6f 66 74			.text 'u*-soft'
>4bb2	00 00 00 00 00 00 00 00			.fill 9,0
>4bba	00
>4bbb	72 4b					.word w_x2a
.4bbd					xt_ux2ax2dsoft:
.4bbd	a9 00		lda #$00		lda #0          ; Initialize RESULT to 0
.4bbf	85 2c		sta $2c			sta tmp+2
.4bc1	a2 10		ldx #$10		ldx #16         ; There are 16 bits in n2
.4bc3						l1:
.4bc3	56 03		lsr $03,x		lsr pstack+3,x  ; Get low bit of n2
.4bc5	76 02		ror $02,x		ror pstack+2,x
.4bc7	90 0b		bcc $4bd4		bcc l2          ; 0 or 1?
.4bc9	a8		tay			tay             ; If 1, add n1 (hi byte of tmp is in A)
.4bca	18		clc			clc
.4bcb	b5 04		lda $04,x		lda pstack+4,x
.4bcd	65 2c		adc $2c			adc tmp+2
.4bcf	85 2c		sta $2c			sta tmp+2
.4bd1	98		tya			tya
.4bd2	75 05		adc $05,x		adc pstack+5,x
.4bd4						l2:
.4bd4	6a		ror a			ror A
.4bd5	66 2c		ror $2c			ror tmp+2
.4bd7	66 2b		ror $2b			ror tmp+1
.4bd9	66 2a		ror $2a			ror tmp
.4bdb	3a		dec a			dec a
.4bdc	d0 e5		bne $4bc3		bne l1
.4bde	85 2d		sta $2d			sta tmp+3
.4be0	a5 2a		lda $2a			lda tmp         ; Save result to parameter stack
.4be2	95 04		sta $04,x		sta pstack+4,x
.4be4	a5 2b		lda $2b			lda tmp+1
.4be6	95 05		sta $05,x		sta pstack+5,x
.4be8	e8		inx			inx             ; Clean up parameter stack
.4be9	e8		inx			inx
.4bea	4c c1 42	jmp $42c1		jmp xt_next
.4bed					w_x2ax2dsoft:
>4bed	06					.byte $06
>4bee	2a 2d 73 6f 66 74			.text '*-soft'
>4bf4	00 00 00 00 00 00 00 00			.fill 10,0
>4bfc	00 00
>4bfe	aa 4b					.word w_ux2ax2dsoft
.4c00					xt_x2ax2dsoft:
.4c00	64 30		stz $30			stz sign
.4c02	b5 05		lda $05,x		lda pstack+5,x  ; Check to see if n1 is negative
.4c04	10 11		bpl $4c17		bpl chk_n2
.4c06	a9 80		lda #$80		lda #$80        ; Yes: record the sign
.4c08	85 30		sta $30			sta sign
.4c0a	38		sec			sec             ; Negate n1
.4c0b	a9 00		lda #$00		lda #0
.4c0d	f5 04		sbc $04,x		sbc pstack+4,x
.4c0f	95 04		sta $04,x		sta pstack+4,x
.4c11	a9 00		lda #$00		lda #0
.4c13	f5 05		sbc $05,x		sbc pstack+5,x
.4c15	95 05		sta $05,x		sta pstack+5,x
.4c17						chk_n2:
.4c17	b5 03		lda $03,x		lda pstack+3,x  ; Check to see if n2 is negative
.4c19	10 13		bpl $4c2e		bpl init_tmp
.4c1b	a5 30		lda $30			lda sign        ; Flip the sign bit, if so
.4c1d	49 80		eor #$80		eor #$80        ; And set the bit for the remainder
.4c1f	85 30		sta $30			sta sign
.4c21	38		sec			sec             ; Negate n2
.4c22	a9 00		lda #$00		lda #0
.4c24	f5 02		sbc $02,x		sbc pstack+2,x
.4c26	95 02		sta $02,x		sta pstack+2,x
.4c28	a9 00		lda #$00		lda #0
.4c2a	f5 03		sbc $03,x		sbc pstack+3,x
.4c2c	95 03		sta $03,x		sta pstack+3,x
.4c2e						init_tmp:
.4c2e	a9 00		lda #$00		lda #0          ; Initialize RESULT to 0
.4c30	85 2c		sta $2c			sta tmp+2
.4c32	a2 10		ldx #$10		ldx #16         ; There are 16 bits in n2
.4c34						l1:
.4c34	56 03		lsr $03,x		lsr pstack+3,x  ; Get low bit of n2
.4c36	76 02		ror $02,x		ror pstack+2,x
.4c38	90 0b		bcc $4c45		bcc l2          ; 0 or 1?
.4c3a	a8		tay			tay             ; If 1, add n1 (hi byte of tmp is in A)
.4c3b	18		clc			clc
.4c3c	b5 04		lda $04,x		lda pstack+4,x
.4c3e	65 2c		adc $2c			adc tmp+2
.4c40	85 2c		sta $2c			sta tmp+2
.4c42	98		tya			tya
.4c43	75 05		adc $05,x		adc pstack+5,x
.4c45						l2:
.4c45	6a		ror a			ror A
.4c46	66 2c		ror $2c			ror tmp+2
.4c48	66 2b		ror $2b			ror tmp+1
.4c4a	66 2a		ror $2a			ror tmp
.4c4c	3a		dec a			dec a
.4c4d	d0 e5		bne $4c34		bne l1
.4c4f	85 2d		sta $2d			sta tmp+3
.4c51	a5 2a		lda $2a			lda tmp         ; Save result to parameter stack
.4c53	95 04		sta $04,x		sta pstack+4,x
.4c55	a5 2b		lda $2b			lda tmp+1
.4c57	95 05		sta $05,x		sta pstack+5,x
.4c59	e8		inx			inx             ; Clean up parameter stack
.4c5a	e8		inx			inx
.4c5b	a5 30		lda $30			lda sign        ; Check the sign
.4c5d	10 0d		bpl $4c6c		bpl done
.4c5f	38		sec			sec             ; If negative, negate result
.4c60	a9 00		lda #$00		lda #0
.4c62	f5 02		sbc $02,x		sbc pstack+2,x
.4c64	95 02		sta $02,x		sta pstack+2,x
.4c66	a9 00		lda #$00		lda #0
.4c68	f5 03		sbc $03,x		sbc pstack+3,x
.4c6a	95 03		sta $03,x		sta pstack+3,x
.4c6c						done:
.4c6c	4c c1 42	jmp $42c1		jmp xt_next
.4c6f					w_umx2fmod:
>4c6f	06					.byte $06
>4c70	75 6d 2f 6d 6f 64			.text 'um/mod'
>4c76	00 00 00 00 00 00 00 00			.fill 10,0
>4c7e	00 00
>4c80	ed 4b					.word w_x2ax2dsoft
.4c82					xt_umx2fmod:
.4c82	38		sec			sec
.4c83	b5 06		lda $06,x		lda     pstack+6,x          ; Subtract hi cell of dividend by
.4c85	f5 02		sbc $02,x		sbc     pstack+2,x          ; divisor to see if there's an overflow condition.
.4c87	b5 07		lda $07,x		lda     pstack+7,x
.4c89	f5 03		sbc $03,x		sbc     pstack+3,x
.4c8b	b0 2e		bcs $4cbb		bcs     overflow            ; Branch if /0 or overflow.
.4c8d	a9 11		lda #$11		lda     #$11                ; Loop 17x.
.4c8f	85 2a		sta $2a			sta     tmp                 ; Use tmp for loop counter.
.4c91						loop:
.4c91	36 04		rol $04,x		rol     pstack+4,x          ; Rotate dividend lo cell left one bit.
.4c93	36 05		rol $05,x		rol     pstack+5,x
.4c95	c6 2a		dec $2a			dec     tmp                 ; Decrement loop counter.
.4c97	f0 2c		beq $4cc5		beq     done                ; If we're done, then branch to end.
.4c99	36 06		rol $06,x		rol     pstack+6,x          ; Otherwise rotate dividend hi cell left one bit.
.4c9b	36 07		rol $07,x		rol     pstack+7,x
.4c9d	64 2b		stz $2b			stz     tmp+1
.4c9f	26 2b		rol $2b			rol     tmp+1               ; Rotate the bit carried out of above into tmp+1.
.4ca1	38		sec			sec
.4ca2	b5 06		lda $06,x		lda     pstack+6,x          ; Subtract dividend hi cell minus divisor.
.4ca4	f5 02		sbc $02,x		sbc     pstack+2,x
.4ca6	85 2c		sta $2c			sta     tmp+2               ; Put result temporarily in tmp+2 (lo byte)
.4ca8	b5 07		lda $07,x		lda     pstack+7,x
.4caa	f5 03		sbc $03,x		sbc     pstack+3,x
.4cac	a8		tay			tay                         ; and Y (hi byte).
.4cad	a5 2b		lda $2b			lda     tmp+1               ; Remember now to bring in the bit carried out above.
.4caf	e9 00		sbc #$00		sbc     #0
.4cb1	90 de		bcc $4c91		bcc     loop
.4cb3	a5 2c		lda $2c			lda     tmp+2               ; If that didn't cause a borrow,
.4cb5	95 06		sta $06,x		sta     pstack+6,x          ; make the result from above to
.4cb7	94 07		sty $07,x		sty     pstack+7,x          ; be the new dividend hi cell
.4cb9	80 d6		bra $4c91		bra     loop                ; and then brach up.  (NMOS 6502 can use BCS here.)
.4cbb						overflow:
.4cbb	a9 ff		lda #$ff		lda     #$ff                ; If overflow or /0 condition found,
.4cbd	95 06		sta $06,x		sta     pstack+6,x          ; just put FFFF in both the remainder
.4cbf	95 07		sta $07,x		sta     pstack+7,x
.4cc1	95 04		sta $04,x		sta     pstack+4,x          ; and the quotient.
.4cc3	95 05		sta $05,x		sta     pstack+5,x
.4cc5						done:
.4cc5	e8		inx			inx
.4cc6	e8		inx			inx
.4cc7	4c c1 42	jmp $42c1		jmp xt_next
.4cca					w_sx3ed:
>4cca	03					.byte $03
>4ccb	73 3e 64				.text 's>d'
>4cce	00 00 00 00 00 00 00 00			.fill 13,0
>4cd6	00 00 00 00 00
>4cdb	6f 4c					.word w_umx2fmod
.4cdd					xt_sx3ed:
.4cdd	ca		dex			dex
.4cde	ca		dex			dex
.4cdf	b5 04		lda $04,x		lda pstack+4,x
.4ce1	95 02		sta $02,x		sta pstack+2,x
.4ce3	b5 05		lda $05,x		lda pstack+5,x
.4ce5	95 03		sta $03,x		sta pstack+3,x
.4ce7	30 07		bmi $4cf0		bmi is_neg
.4ce9	74 04		stz $04,x		stz pstack+4,x
.4ceb	74 05		stz $05,x		stz pstack+5,x
.4ced	4c c1 42	jmp $42c1		jmp xt_next
.4cf0						is_neg:
.4cf0	a9 ff		lda #$ff		lda #$ff
.4cf2	95 04		sta $04,x		sta pstack+4,x
.4cf4	95 05		sta $05,x		sta pstack+5,x
.4cf6	4c c1 42	jmp $42c1		jmp xt_next
.4cf9					w_1x2b:
>4cf9	02					.byte $02
>4cfa	31 2b					.text '1+'
>4cfc	00 00 00 00 00 00 00 00			.fill 14,0
>4d04	00 00 00 00 00 00
>4d0a	ca 4c					.word w_sx3ed
.4d0c					xt_1x2b:
.4d0c	f6 02		inc $02,x		inc pstack+2,x
.4d0e	d0 02		bne $4d12		bne skip
.4d10	f6 03		inc $03,x		inc pstack+3,x
.4d12						skip:
.4d12	4c c1 42	jmp $42c1		jmp xt_next
.4d15					w_2x2b:
>4d15	02					.byte $02
>4d16	32 2b					.text '2+'
>4d18	00 00 00 00 00 00 00 00			.fill 14,0
>4d20	00 00 00 00 00 00
>4d26	f9 4c					.word w_1x2b
.4d28					xt_2x2b:
.4d28	18		clc			clc
.4d29	b5 02		lda $02,x		lda pstack+2,x
.4d2b	69 02		adc #$02		adc #2
.4d2d	95 02		sta $02,x		sta pstack+2,x
.4d2f	b5 03		lda $03,x		lda pstack+3,x
.4d31	69 00		adc #$00		adc #0
.4d33	95 03		sta $03,x		sta pstack+3,x
.4d35	4c c1 42	jmp $42c1		jmp xt_next
.4d38					w_1x2d:
>4d38	02					.byte $02
>4d39	31 2d					.text '1-'
>4d3b	00 00 00 00 00 00 00 00			.fill 14,0
>4d43	00 00 00 00 00 00
>4d49	15 4d					.word w_2x2b
.4d4b					xt_1x2d:
.4d4b	b5 02		lda $02,x		lda pstack+2,x
.4d4d	d0 02		bne $4d51		bne l1
.4d4f	d6 03		dec $03,x		dec pstack+3,x
.4d51						l1:
.4d51	d6 02		dec $02,x		dec pstack+2,x
.4d53	4c c1 42	jmp $42c1		jmp xt_next
.4d56					w_2x2d:
>4d56	02					.byte $02
>4d57	32 2d					.text '2-'
>4d59	00 00 00 00 00 00 00 00			.fill 14,0
>4d61	00 00 00 00 00 00
>4d67	38 4d					.word w_1x2d
.4d69					xt_2x2d:
.4d69	38		sec			sec
.4d6a	b5 02		lda $02,x		lda pstack+2,x
.4d6c	e9 02		sbc #$02		sbc #2
.4d6e	95 02		sta $02,x		sta pstack+2,x
.4d70	b5 03		lda $03,x		lda pstack+3,x
.4d72	e9 00		sbc #$00		sbc #0
.4d74	95 03		sta $03,x		sta pstack+3,x
.4d76	4c c1 42	jmp $42c1		jmp xt_next
.4d79					w_and:
>4d79	03					.byte $03
>4d7a	61 6e 64				.text 'and'
>4d7d	00 00 00 00 00 00 00 00			.fill 13,0
>4d85	00 00 00 00 00
>4d8a	56 4d					.word w_2x2d
.4d8c					xt_and:
.4d8c	b5 02		lda $02,x		lda pstack+2,x
.4d8e	35 04		and $04,x		and pstack+4,x
.4d90	95 04		sta $04,x		sta pstack+4,x
.4d92	b5 03		lda $03,x		lda pstack+3,x
.4d94	35 05		and $05,x		and pstack+5,x
.4d96	95 05		sta $05,x		sta pstack+5,x
.4d98	e8		inx			inx
.4d99	e8		inx			inx
.4d9a	4c c1 42	jmp $42c1		jmp xt_next
.4d9d					w_or:
>4d9d	02					.byte $02
>4d9e	6f 72					.text 'or'
>4da0	00 00 00 00 00 00 00 00			.fill 14,0
>4da8	00 00 00 00 00 00
>4dae	79 4d					.word w_and
.4db0					xt_or:
.4db0	b5 02		lda $02,x		lda pstack+2,x
.4db2	15 04		ora $04,x		ora pstack+4,x
.4db4	95 04		sta $04,x		sta pstack+4,x
.4db6	b5 03		lda $03,x		lda pstack+3,x
.4db8	15 05		ora $05,x		ora pstack+5,x
.4dba	95 05		sta $05,x		sta pstack+5,x
.4dbc	e8		inx			inx
.4dbd	e8		inx			inx
.4dbe	4c c1 42	jmp $42c1		jmp xt_next
.4dc1					w_xor:
>4dc1	03					.byte $03
>4dc2	78 6f 72				.text 'xor'
>4dc5	00 00 00 00 00 00 00 00			.fill 13,0
>4dcd	00 00 00 00 00
>4dd2	9d 4d					.word w_or
.4dd4					xt_xor:
.4dd4	b5 02		lda $02,x		lda pstack+2,x
.4dd6	55 04		eor $04,x		eor pstack+4,x
.4dd8	95 04		sta $04,x		sta pstack+4,x
.4dda	b5 03		lda $03,x		lda pstack+3,x
.4ddc	55 05		eor $05,x		eor pstack+5,x
.4dde	95 05		sta $05,x		sta pstack+5,x
.4de0	e8		inx			inx
.4de1	e8		inx			inx
.4de2	4c c1 42	jmp $42c1		jmp xt_next
.4de5					w_not:
>4de5	03					.byte $03
>4de6	6e 6f 74				.text 'not'
>4de9	00 00 00 00 00 00 00 00			.fill 13,0
>4df1	00 00 00 00 00
>4df6	c1 4d					.word w_xor
.4df8					xt_not:
.4df8	b5 02		lda $02,x		lda pstack+2,x
.4dfa	49 ff		eor #$ff		eor #$ff
.4dfc	95 02		sta $02,x		sta pstack+2,x
.4dfe	b5 03		lda $03,x		lda pstack+3,x
.4e00	49 ff		eor #$ff		eor #$ff
.4e02	95 03		sta $03,x		sta pstack+3,x
.4e04	4c c1 42	jmp $42c1		jmp xt_next
.4e07					w_0x3c:
>4e07	02					.byte $02
>4e08	30 3c					.text '0<'
>4e0a	00 00 00 00 00 00 00 00			.fill 14,0
>4e12	00 00 00 00 00 00
>4e18	e5 4d					.word w_not
.4e1a					xt_0x3c:
.4e1a	b5 03		lda $03,x		lda pstack+3,x
.4e1c	30 07		bmi $4e25		bmi istrue
.4e1e	74 02		stz $02,x		stz pstack+2,x
.4e20	74 03		stz $03,x		stz pstack+3,x
.4e22	4c c1 42	jmp $42c1		jmp xt_next
.4e25						istrue:
.4e25	a9 ff		lda #$ff		lda #$ff
.4e27	95 02		sta $02,x		sta pstack+2,x
.4e29	95 03		sta $03,x		sta pstack+3,x
.4e2b	4c c1 42	jmp $42c1		jmp xt_next
.4e2e					w_0x3d:
>4e2e	02					.byte $02
>4e2f	30 3d					.text '0='
>4e31	00 00 00 00 00 00 00 00			.fill 14,0
>4e39	00 00 00 00 00 00
>4e3f	07 4e					.word w_0x3c
.4e41					xt_0x3d:
.4e41	b5 02		lda $02,x		lda pstack+2,x
.4e43	d0 0d		bne $4e52		bne isfalse
.4e45	b5 03		lda $03,x		lda pstack+3,x
.4e47	d0 09		bne $4e52		bne isfalse
.4e49	a9 ff		lda #$ff		lda #$ff
.4e4b	95 02		sta $02,x		sta pstack+2,x
.4e4d	95 03		sta $03,x		sta pstack+3,x
.4e4f	4c c1 42	jmp $42c1		jmp xt_next
.4e52						isfalse:
.4e52	74 02		stz $02,x		stz pstack+2,x
.4e54	74 03		stz $03,x		stz pstack+3,x
.4e56	4c c1 42	jmp $42c1		jmp xt_next
.4e59					w_0x3e:
>4e59	02					.byte $02
>4e5a	30 3e					.text '0>'
>4e5c	00 00 00 00 00 00 00 00			.fill 14,0
>4e64	00 00 00 00 00 00
>4e6a	2e 4e					.word w_0x3d
.4e6c					xt_0x3e:
.4e6c	b5 03		lda $03,x		lda pstack+3,x
.4e6e	30 0f		bmi $4e7f		bmi isfalse
.4e70	d0 04		bne $4e76		bne istrue
.4e72	b5 02		lda $02,x		lda pstack+2,x
.4e74	f0 09		beq $4e7f		beq isfalse
.4e76						istrue:
.4e76	a9 ff		lda #$ff		lda #$ff
.4e78	95 02		sta $02,x		sta pstack+2,x
.4e7a	95 03		sta $03,x		sta pstack+3,x
.4e7c	4c c1 42	jmp $42c1		jmp xt_next
.4e7f						isfalse:
.4e7f	74 02		stz $02,x		stz pstack+2,x
.4e81	74 03		stz $03,x		stz pstack+3,x
.4e83	4c c1 42	jmp $42c1		jmp xt_next
.4e86					w_x28variablex29:
>4e86	0a					.byte $0A
>4e87	28 76 61 72 69 61 62 6c			.text '(variable)'
>4e8f	65 29
>4e91	00 00 00 00 00 00			.fill 6,0
>4e97	59 4e					.word w_0x3e
.4e99					xt_x28variablex29:
.4e99	18		clc			clc                     ; push(wp + 3)
.4e9a	a5 22		lda $22			lda wp
.4e9c	69 03		adc #$03		adc #3
.4e9e	95 00		sta $00,x		sta pstack,x
.4ea0	a5 23		lda $23			lda wp+1
.4ea2	69 00		adc #$00		adc #0
.4ea4	95 01		sta $01,x		sta pstack+1,x
.4ea6	ca		dex			dex
.4ea7	ca		dex			dex
.4ea8	4c c1 42	jmp $42c1		jmp xt_next
.4eab					w_x28constantx29:
>4eab	0a					.byte $0A
>4eac	28 63 6f 6e 73 74 61 6e			.text '(constant)'
>4eb4	74 29
>4eb6	00 00 00 00 00 00			.fill 6,0
>4ebc	86 4e					.word w_x28variablex29
.4ebe					xt_x28constantx29:
.4ebe	a0 03		ldy #$03		ldy #3                  ; push(memory(wp + 3))
.4ec0	b1 22		lda ($22),y		lda (wp),y
.4ec2	95 00		sta $00,x		sta pstack,x
.4ec4	c8		iny			iny
.4ec5	b1 22		lda ($22),y		lda (wp),y
.4ec7	95 01		sta $01,x		sta pstack+1,x
.4ec9	ca		dex			dex
.4eca	ca		dex			dex
.4ecb	4c c1 42	jmp $42c1		jmp xt_next
.4ece					w_cells:
>4ece	05					.byte $05
>4ecf	63 65 6c 6c 73				.text 'cells'
>4ed4	00 00 00 00 00 00 00 00			.fill 11,0
>4edc	00 00 00
>4edf	ab 4e					.word w_x28constantx29
.4ee1					xt_cells:
.4ee1	4c be 4e	jmp $4ebe		jmp xt_x28constantx29
>4ee4	02 00					.word 2
.4ee6					w_x28userx29:
>4ee6	06					.byte $06
>4ee7	28 75 73 65 72 29			.text '(user)'
>4eed	00 00 00 00 00 00 00 00			.fill 10,0
>4ef5	00 00
>4ef7	ce 4e					.word w_cells
.4ef9					xt_x28userx29:
.4ef9	18		clc			clc                     ; push(up + memory(wp + 3))
.4efa	a0 03		ldy #$03		ldy #3
.4efc	a5 24		lda $24			lda up
.4efe	71 22		adc ($22),y		adc (wp),y
.4f00	95 00		sta $00,x		sta pstack,x
.4f02	c8		iny			iny
.4f03	a5 25		lda $25			lda up+1
.4f05	71 22		adc ($22),y		adc (wp),y
.4f07	95 01		sta $01,x		sta pstack+1,x
.4f09	ca		dex			dex
.4f0a	ca		dex			dex
.4f0b	4c c1 42	jmp $42c1		jmp xt_next
.4f0e					w_x28branchx29:
>4f0e	08					.byte $08
>4f0f	28 62 72 61 6e 63 68 29			.text '(branch)'
>4f17	00 00 00 00 00 00 00 00			.fill 8,0
>4f1f	e6 4e					.word w_x28userx29
.4f21					xt_x28branchx29:
.4f21	a0 01		ldy #$01		ldy #1              ; ip := branch address
.4f23	b2 20		lda ($20)		lda (ip)
.4f25	85 2a		sta $2a			sta tmp
.4f27	b1 20		lda ($20),y		lda (ip),y
.4f29	85 21		sta $21			sta ip+1
.4f2b	a5 2a		lda $2a			lda tmp
.4f2d	85 20		sta $20			sta ip
.4f2f	4c c1 42	jmp $42c1		jmp xt_next
.4f32					w_x28branch0x29:
>4f32	09					.byte $09
>4f33	28 62 72 61 6e 63 68 30			.text '(branch0)'
>4f3b	29
>4f3c	00 00 00 00 00 00 00			.fill 7,0
>4f43	0e 4f					.word w_x28branchx29
.4f45					xt_x28branch0x29:
.4f45	b5 02		lda $02,x		lda pstack+2,x      ; Check to see if TOS is 0
.4f47	d0 04		bne $4f4d		bne nobranch        ; No: skip over the branch address
.4f49	b5 03		lda $03,x		lda pstack+3,x
.4f4b	f0 0f		beq $4f5c		beq dobranch        ; Yes: take the branch
.4f4d						nobranch:
.4f4d	18		clc			clc                 ; No: skip over the branch address
.4f4e	a5 20		lda $20			lda ip
.4f50	69 02		adc #$02		adc #2
.4f52	85 20		sta $20			sta ip
.4f54	a5 21		lda $21			lda ip+1
.4f56	69 00		adc #$00		adc #0
.4f58	85 21		sta $21			sta ip+1
.4f5a	80 0e		bra $4f6a		bra done
.4f5c						dobranch:
.4f5c	a0 01		ldy #$01		ldy #1              ; ip := branch address
.4f5e	b2 20		lda ($20)		lda (ip)
.4f60	85 2a		sta $2a			sta tmp
.4f62	b1 20		lda ($20),y		lda (ip),y
.4f64	85 21		sta $21			sta ip+1
.4f66	a5 2a		lda $2a			lda tmp
.4f68	85 20		sta $20			sta ip
.4f6a						done:
.4f6a	e8		inx			inx                 ; clean up the parameter stack
.4f6b	e8		inx			inx
.4f6c	4c c1 42	jmp $42c1		jmp xt_next
.4f6f					w_x28dox29:
>4f6f	04					.byte $04
>4f70	28 64 6f 29				.text '(do)'
>4f74	00 00 00 00 00 00 00 00			.fill 12,0
>4f7c	00 00 00 00
>4f80	32 4f					.word w_x28branch0x29
.4f82					xt_x28dox29:
.4f82	b5 03		lda $03,x		lda pstack+3,x
.4f84	48		pha			pha
.4f85	b5 02		lda $02,x		lda pstack+2,x
.4f87	48		pha			pha
.4f88	b5 05		lda $05,x		lda pstack+5,x
.4f8a	48		pha			pha
.4f8b	b5 04		lda $04,x		lda pstack+4,x
.4f8d	48		pha			pha
.4f8e	18		clc			clc
.4f8f	8a		txa			txa
.4f90	69 04		adc #$04		adc #4
.4f92	aa		tax			tax
.4f93	4c c1 42	jmp $42c1		jmp xt_next
.4f96					w_x3ei:
>4f96	02					.byte $02
>4f97	3e 69					.text '>i'
>4f99	00 00 00 00 00 00 00 00			.fill 14,0
>4fa1	00 00 00 00 00 00
>4fa7	6f 4f					.word w_x28dox29
.4fa9					xt_x3ei:
>0101						limit       .word ?
>0103						current     .word ?
.4fa9	b5 03		lda $03,x		lda pstack+3,x      ; tmp := n
.4fab	85 2b		sta $2b			sta tmp+1
.4fad	b5 02		lda $02,x		lda pstack+2,x
.4faf	85 2a		sta $2a			sta tmp
.4fb1	e8		inx			inx
.4fb2	e8		inx			inx
.4fb3	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.4fb5	ba		tsx			tsx
.4fb6	a5 2b		lda $2b			lda tmp+1           ; current := tmp = n
.4fb8	9d 04 01	sta $0104,x		sta current+1
.4fbb	a5 2a		lda $2a			lda tmp
.4fbd	9d 03 01	sta $0103,x		sta current
.4fc0	a6 2e		ldx $2e			ldx savex
.4fc2	4c c1 42	jmp $42c1		jmp xt_next
.4fc5					w_leave:
>4fc5	05					.byte $05
>4fc6	6c 65 61 76 65				.text 'leave'
>4fcb	00 00 00 00 00 00 00 00			.fill 11,0
>4fd3	00 00 00
>4fd6	96 4f					.word w_x3ei
.4fd8					xt_leave:
>0101						limit       .word ?
>0103						current     .word ?
.4fd8	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.4fda	ba		tsx			tsx
.4fdb	bd 04 01	lda $0104,x		lda current+1       ; limit := current
.4fde	9d 02 01	sta $0102,x		sta limit+1
.4fe1	bd 03 01	lda $0103,x		lda current
.4fe4	9d 01 01	sta $0101,x		sta limit
.4fe7	a6 2e		ldx $2e			ldx savex
.4fe9	4c c1 42	jmp $42c1		jmp xt_next
.4fec					w_x28loopx29:
>4fec	06					.byte $06
>4fed	28 6c 6f 6f 70 29			.text '(loop)'
>4ff3	00 00 00 00 00 00 00 00			.fill 10,0
>4ffb	00 00
>4ffd	c5 4f					.word w_leave
.4fff					xt_x28loopx29:
>0101						limit       .word ?
>0103						current     .word ?
.4fff	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.5001	ba		tsx			tsx
.5002	fe 03 01	inc $0103,x		inc current         ; Increment current
.5005	d0 03		bne $500a		bne chk_current
.5007	fe 04 01	inc $0104,x		inc current+1
.500a						chk_current:
.500a	38		sec			sec
.500b	bd 04 01	lda $0104,x		lda current+1       ; compare high bytes
.500e	fd 02 01	sbc $0102,x		sbc limit+1
.5011	50 02		bvc $5015		bvc label1          ; the equality comparison is in the Z flag here
.5013	49 80		eor #$80		eor #$80            ; the Z flag is affected here
.5015						label1:
.5015	30 23		bmi $503a		bmi dobranch        ; if current+1 < limit+1 then NUM1 < limit
.5017	50 02		bvc $501b		bvc label2          ; the Z flag was affected only if V is 1
.5019	49 80		eor #$80		eor #$80            ; restore the Z flag to the value it had after sbc NUM2H
.501b						label2:
.501b	d0 08		bne $5025		bne nobranch        ; if current+1 <> limit+1 then current > limit (so current >= limit)
.501d	bd 03 01	lda $0103,x		lda current         ; compare low bytes
.5020	fd 01 01	sbc $0101,x		sbc limit
.5023	90 15		bcc $503a		bcc dobranch        ; if current < limit then current < limit
.5025						nobranch:
.5025	8a		txa			txa                 ; Yes: Remove the context from the return stack
.5026	18		clc			clc
.5027	69 04		adc #$04		adc #4
.5029	aa		tax			tax
.502a	9a		txs			txs
.502b	18		clc			clc                 ; And skip over the branch address
.502c	a5 20		lda $20			lda ip
.502e	69 02		adc #$02		adc #2
.5030	85 20		sta $20			sta ip
.5032	a5 21		lda $21			lda ip+1
.5034	69 00		adc #$00		adc #0
.5036	85 21		sta $21			sta ip+1
.5038	80 0e		bra $5048		bra done
.503a						dobranch:
.503a	a0 01		ldy #$01		ldy #1              ; No: ip := branch address
.503c	b2 20		lda ($20)		lda (ip)
.503e	85 2a		sta $2a			sta tmp
.5040	b1 20		lda ($20),y		lda (ip),y
.5042	85 21		sta $21			sta ip+1
.5044	a5 2a		lda $2a			lda tmp
.5046	85 20		sta $20			sta ip
.5048						done:
.5048	a6 2e		ldx $2e			ldx savex           ; Restore the parameter stack pointer
.504a	4c c1 42	jmp $42c1		jmp xt_next
.504d					w_x28x2bloopx29:
>504d	07					.byte $07
>504e	28 2b 6c 6f 6f 70 29			.text '(+loop)'
>5055	00 00 00 00 00 00 00 00			.fill 9,0
>505d	00
>505e	ec 4f					.word w_x28loopx29
.5060					xt_x28x2bloopx29:
>0101						limit       .word ?
>0103						current     .word ?
.5060	b5 03		lda $03,x		lda pstack+3,x      ; Pop n from the stack
.5062	85 2b		sta $2b			sta tmp+1
.5064	b5 02		lda $02,x		lda pstack+2,x
.5066	85 2a		sta $2a			sta tmp
.5068	e8		inx			inx
.5069	e8		inx			inx
.506a	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.506c	ba		tsx			tsx
.506d	18		clc			clc                 ; Increment current by n
.506e	bd 03 01	lda $0103,x		lda current
.5071	65 2a		adc $2a			adc tmp
.5073	9d 03 01	sta $0103,x		sta current
.5076	bd 04 01	lda $0104,x		lda current+1
.5079	65 2b		adc $2b			adc tmp+1
.507b	9d 04 01	sta $0104,x		sta current+1
.507e						chk_current:
.507e	38		sec			sec
.507f	bd 04 01	lda $0104,x		lda current+1       ; compare high bytes
.5082	fd 02 01	sbc $0102,x		sbc limit+1
.5085	50 02		bvc $5089		bvc label1          ; the equality comparison is in the Z flag here
.5087	49 80		eor #$80		eor #$80            ; the Z flag is affected here
.5089						label1:
.5089	30 23		bmi $50ae		bmi dobranch        ; if current+1 < limit+1 then current < limit
.508b	50 02		bvc $508f		bvc label2          ; the Z flag was affected only if V is 1
.508d	49 80		eor #$80		eor #$80            ; restore the Z flag to the value it had after sbc current+1
.508f						label2:
.508f	d0 08		bne $5099		bne nobranch        ; if current+1 <> limit+1 then current > limit (so current >= limit)
.5091	bd 03 01	lda $0103,x		lda current         ; compare low bytes
.5094	fd 01 01	sbc $0101,x		sbc limit
.5097	90 15		bcc $50ae		bcc dobranch        ; if current < limit then current < limit
.5099						nobranch:
.5099	8a		txa			txa                 ; Yes: Remove the context from the return stack
.509a	18		clc			clc
.509b	69 04		adc #$04		adc #4
.509d	aa		tax			tax
.509e	9a		txs			txs
.509f	18		clc			clc                 ; And skip over the branch address
.50a0	a5 20		lda $20			lda ip
.50a2	69 02		adc #$02		adc #2
.50a4	85 20		sta $20			sta ip
.50a6	a5 21		lda $21			lda ip+1
.50a8	69 00		adc #$00		adc #0
.50aa	85 21		sta $21			sta ip+1
.50ac	80 0e		bra $50bc		bra done
.50ae						dobranch:
.50ae	a0 01		ldy #$01		ldy #1              ; No: ip := branch address
.50b0	b2 20		lda ($20)		lda (ip)
.50b2	85 2a		sta $2a			sta tmp
.50b4	b1 20		lda ($20),y		lda (ip),y
.50b6	85 21		sta $21			sta ip+1
.50b8	a5 2a		lda $2a			lda tmp
.50ba	85 20		sta $20			sta ip
.50bc						done:
.50bc	a6 2e		ldx $2e			ldx savex           ; Restore the parameter stack pointer
.50be	4c c1 42	jmp $42c1		jmp xt_next
.50c1					w_i:
>50c1	01					.byte $01
>50c2	69					.text 'i'
>50c3	00 00 00 00 00 00 00 00			.fill 15,0
>50cb	00 00 00 00 00 00 00
>50d2	4d 50					.word w_x28x2bloopx29
.50d4					xt_i:
>0101						limit       .word ?
>0103						current     .word ?
.50d4	86 2e		stx $2e			stx savex           ; Point X to the return stack temporarily
.50d6	ba		tsx			tsx
.50d7	bc 04 01	ldy $0104,x		ldy current+1       ; Get the value of current
.50da	bd 03 01	lda $0103,x		lda current
.50dd	a6 2e		ldx $2e			ldx savex           ; Restore the PSP
.50df	94 01		sty $01,x		sty pstack+1,x      ; Save the value of current to the stack
.50e1	95 00		sta $00,x		sta pstack,x
.50e3	ca		dex			dex
.50e4	ca		dex			dex
.50e5	4c c1 42	jmp $42c1		jmp xt_next
.50e8					w_x28ofx29:
>50e8	04					.byte $04
>50e9	28 6f 66 29				.text '(of)'
>50ed	00 00 00 00 00 00 00 00			.fill 12,0
>50f5	00 00 00 00
>50f9	c1 50					.word w_i
.50fb					xt_x28ofx29:
.50fb	b5 02		lda $02,x		lda pstack+2,x      ; Does n1 == n2?
.50fd	d5 04		cmp $04,x		cmp pstack+4,x
.50ff	d0 1a		bne $511b		bne not_eq
.5101	b5 03		lda $03,x		lda pstack+3,x
.5103	d5 05		cmp $05,x		cmp pstack+5,x
.5105	d0 14		bne $511b		bne not_eq
.5107	e8		inx			inx
.5108	e8		inx			inx
.5109	e8		inx			inx
.510a	e8		inx			inx
.510b	18		clc			clc                 ; Skip over the branch target
.510c	a5 20		lda $20			lda ip
.510e	69 02		adc #$02		adc #2
.5110	85 20		sta $20			sta ip
.5112	a5 21		lda $21			lda ip+1
.5114	69 00		adc #$00		adc #0
.5116	85 21		sta $21			sta ip+1
.5118	4c c1 42	jmp $42c1		jmp xt_next
.511b						not_eq:
.511b	e8		inx			inx                 ; Remove n2 from stack
.511c	e8		inx			inx
.511d	a0 01		ldy #$01		ldy #1              ; Take the branch target
.511f	b2 20		lda ($20)		lda (ip)
.5121	85 2a		sta $2a			sta tmp
.5123	b1 20		lda ($20),y		lda (ip),y
.5125	85 21		sta $21			sta ip+1
.5127	a5 2a		lda $2a			lda tmp
.5129	85 20		sta $20			sta ip
.512b	4c c1 42	jmp $42c1		jmp xt_next
.512e					w_execute:
>512e	07					.byte $07
>512f	65 78 65 63 75 74 65			.text 'execute'
>5136	00 00 00 00 00 00 00 00			.fill 9,0
>513e	00
>513f	e8 50					.word w_x28ofx29
.5141					xt_execute:
.5141	b5 02		lda $02,x		lda pstack+2,x      ; wp := xt
.5143	85 22		sta $22			sta wp
.5145	b5 03		lda $03,x		lda pstack+3,x
.5147	85 23		sta $23			sta wp+1
.5149	e8		inx			inx                 ; Clean up stack
.514a	e8		inx			inx
.514b	6c 22 00	jmp ($0022)		jmp (wp)            ; jmp xt
.514e					w_x28vocabularyx29:
>514e	0c					.byte $0C
>514f	28 76 6f 63 61 62 75 6c			.text '(vocabulary)'
>5157	61 72 79 29
>515b	00 00 00 00				.fill 4,0
>515f	2e 51					.word w_execute
.5161					xt_x28vocabularyx29:
.5161	18		clc			clc                 ; tmp := up + user_context
.5162	a5 24		lda $24			lda up
.5164	69 08		adc #$08		adc #user_context
.5166	85 2a		sta $2a			sta tmp
.5168	a5 25		lda $25			lda up+1
.516a	69 00		adc #$00		adc #0
.516c	85 2b		sta $2b			sta tmp+1
.516e	a0 01		ldy #$01		ldy #1              ; (tmp) := wp + 3
.5170	18		clc			clc
.5171	a5 22		lda $22			lda wp
.5173	69 03		adc #$03		adc #3
.5175	92 2a		sta ($2a)		sta (tmp)
.5177	a5 23		lda $23			lda wp+1
.5179	69 00		adc #$00		adc #0
.517b	91 2a		sta ($2a),y		sta (tmp),y
.517d	4c c1 42	jmp $42c1		jmp xt_next
.5180					w_forth:
>5180	05					.byte $05
>5181	66 6f 72 74 68				.text 'forth'
>5186	00 00 00 00 00 00 00 00			.fill 11,0
>518e	00 00 00
>5191	4e 51					.word w_x28vocabularyx29
.5193					xt_forth:
.5193	4c 61 51	jmp $5161		jmp xt_x28vocabularyx29
>5196	58 64					.word <>w_cold
.5198					w_x28findx29:
>5198	06					.byte $06
>5199	28 66 69 6e 64 29			.text '(find)'
>519f	00 00 00 00 00 00 00 00			.fill 10,0
>51a7	00 00
>51a9	80 51					.word w_forth
.51ab					xt_x28findx29:
.51ab	b5 03		lda $03,x		lda pstack+3,x          ; src_ptr = dictionary name
.51ad	85 34		sta $34			sta src_ptr+1
.51af	b5 02		lda $02,x		lda pstack+2,x
.51b1	85 33		sta $33			sta src_ptr
.51b3	b5 05		lda $05,x		lda pstack+5,x          ; dst_ptr = word to find
.51b5	85 36		sta $36			sta dst_ptr+1
.51b7	b5 04		lda $04,x		lda pstack+4,x
.51b9	85 35		sta $35			sta dst_ptr
.51bb						loop:
.51bb	a5 33		lda $33			lda src_ptr             ; Check to see if src_ptr = NULL
.51bd	d0 0d		bne $51cc		bne not_eod
.51bf	a5 34		lda $34			lda src_ptr+1
.51c1	d0 09		bne $51cc		bne not_eod
.51c3	e8		inx			inx                     ; Clean up the stack
.51c4	e8		inx			inx
.51c5	74 03		stz $03,x		stz pstack+3,x          ; And return 0
.51c7	74 02		stz $02,x		stz pstack+2,x
.51c9	4c c1 42	jmp $42c1		jmp xt_next
.51cc						not_eod:
.51cc	b2 33		lda ($33)		lda (src_ptr)           ; Get the size of the word in the dictionary
.51ce	29 3f		and #$3f		and #$3f                ; Filter out the flags
.51d0	d2 35		cmp ($35)		cmp (dst_ptr)           ; Check it against the word to search
.51d2	f0 1b		beq $51ef		beq chk_chars           ; If they match, check the characters
.51d4						next_word:
.51d4	18		clc			clc                     ; Move src_ptr to the link field
.51d5	a5 33		lda $33			lda src_ptr
.51d7	69 11		adc #$11		adc #17
.51d9	85 33		sta $33			sta src_ptr
.51db	a5 34		lda $34			lda src_ptr+1
.51dd	69 00		adc #$00		adc #0
.51df	85 34		sta $34			sta src_ptr+1
.51e1	a0 01		ldy #$01		ldy #1                  ; Follow the link to the next word in the dictionary
.51e3	b2 33		lda ($33)		lda (src_ptr)
.51e5	48		pha			pha
.51e6	b1 33		lda ($33),y		lda (src_ptr),y
.51e8	85 34		sta $34			sta src_ptr+1
.51ea	68		pla			pla
.51eb	85 33		sta $33			sta src_ptr
.51ed	80 cc		bra $51bb		bra loop                ; And check that word
.51ef						chk_chars:
.51ef	a8		tay			tay                     ; y := index to character to check
.51f0						char_loop:
.51f0	b1 33		lda ($33),y		lda (src_ptr),y         ; Check the yth character
.51f2	d1 35		cmp ($35),y		cmp (dst_ptr),y
.51f4	d0 de		bne $51d4		bne next_word           ; If they are not equal, go to the next word in the dictionary
.51f6	88		dey			dey                     ; Move to the previous character in the words
.51f7	d0 f7		bne $51f0		bne char_loop           ; Are we back at the size? No: keep checking
.51f9	ca		dex			dex                     ; Make room for all the return values
.51fa	ca		dex			dex
.51fb	a9 01		lda #$01		lda #1                  ; 1 at top of stack
.51fd	74 03		stz $03,x		stz pstack+3,x
.51ff	95 02		sta $02,x		sta pstack+2,x
.5201	b2 33		lda ($33)		lda (src_ptr)           ; Then the length of the word
.5203	74 05		stz $05,x		stz pstack+5,x
.5205	95 04		sta $04,x		sta pstack+4,x
.5207	18		clc			clc                     ; Then the pfa pointer
.5208	a5 33		lda $33			lda src_ptr
.520a	69 16		adc #$16		adc #17+5               ; Skip size, name, link, and code cfa
.520c	95 06		sta $06,x		sta pstack+6,x
.520e	a5 34		lda $34			lda src_ptr+1
.5210	69 00		adc #$00		adc #0
.5212	95 07		sta $07,x		sta pstack+7,x
.5214	4c c1 42	jmp $42c1		jmp xt_next
.5217					w_digit:
>5217	05					.byte $05
>5218	64 69 67 69 74				.text 'digit'
>521d	00 00 00 00 00 00 00 00			.fill 11,0
>5225	00 00 00
>5228	98 51					.word w_x28findx29
.522a					xt_digit:
.522a	b5 04		lda $04,x		lda pstack+4,x          ; Get the character in A
.522c	c9 61		cmp #$61		cmp #'a'
.522e	90 06		bcc $5236		blt get_base
.5230	c9 7b		cmp #$7b		cmp #'z'+1
.5232	b0 02		bcs $5236		bge get_base
.5234	29 df		and #$df		and #$df               ; Turn off the case bit
.5236						get_base:
.5236	b4 02		ldy $02,x		ldy pstack+2,x          ; Get the base into Y
.5238	88		dey			dey
.5239						loop:
.5239	d9 59 52	cmp $5259,y		cmp digits,y            ; Check to see if we have a match
.523c	f0 0e		beq $524c		beq found               ; If so: return the number
.523e	88		dey			dey                     ; Move to the previous digit
.523f	c0 ff		cpy #$ff		cpy #$ff                ; Have we checked the first digit?
.5241	d0 f6		bne $5239		bne loop                ; No: check against this digit
.5243						not_found:
.5243	e8		inx			inx                     ; Clean up the stack
.5244	e8		inx			inx
.5245	74 03		stz $03,x		stz pstack+3,x          ; Return false
.5247	74 02		stz $02,x		stz pstack+2,x
.5249	4c c1 42	jmp $42c1		jmp xt_next
.524c						found:
.524c	74 05		stz $05,x		stz pstack+5,x          ; Return the value of the digit
.524e	94 04		sty $04,x		sty pstack+4,x
.5250	a9 ff		lda #$ff		lda #$ff                ; And the true flag
.5252	95 03		sta $03,x		sta pstack+3,x
.5254	95 02		sta $02,x		sta pstack+2,x
.5256	4c c1 42	jmp $42c1		jmp xt_next
.5259						digits:
>5259	30 31 32 33 34 35 36 37			.text "0123456789ABCDEF"
>5261	38 39 41 42 43 44 45 46
.5269					w_jumpx2dinstruction:
>5269	10					.byte $10
>526a	6a 75 6d 70 2d 69 6e 73			.text 'jump-instruction'
>5272	74 72 75 63 74 69 6f 6e
>527a						.fill 0,0
>527a	17 52					.word w_digit
.527c					xt_jumpx2dinstruction:
.527c	4c 0a 43	jmp $430a		jmp xt_enter
>527f	56 46					.word xt_x28literalx29
>5281	4c 00					.word 76
>5283	ee 42					.word xt_exit
.5285					w_callx2dinstruction:
>5285	10					.byte $10
>5286	63 61 6c 6c 2d 69 6e 73			.text 'call-instruction'
>528e	74 72 75 63 74 69 6f 6e
>5296						.fill 0,0
>5296	69 52					.word w_jumpx2dinstruction
.5298					xt_callx2dinstruction:
.5298	4c 0a 43	jmp $430a		jmp xt_enter
>529b	56 46					.word xt_x28literalx29
>529d	20 00					.word 32
>529f	ee 42					.word xt_exit
.52a1					w_bs:
>52a1	02					.byte $02
>52a2	62 73					.text 'bs'
>52a4	00 00 00 00 00 00 00 00			.fill 14,0
>52ac	00 00 00 00 00 00
>52b2	85 52					.word w_callx2dinstruction
.52b4					xt_bs:
.52b4	4c be 4e	jmp $4ebe		jmp xt_x28constantx29
>52b7	08 00					.word 8
.52b9					w_nl:
>52b9	02					.byte $02
>52ba	6e 6c					.text 'nl'
>52bc	00 00 00 00 00 00 00 00			.fill 14,0
>52c4	00 00 00 00 00 00
>52ca	a1 52					.word w_bs
.52cc					xt_nl:
.52cc	4c be 4e	jmp $4ebe		jmp xt_x28constantx29
>52cf	0d 00					.word 13
.52d1					w_bl:
>52d1	02					.byte $02
>52d2	62 6c					.text 'bl'
>52d4	00 00 00 00 00 00 00 00			.fill 14,0
>52dc	00 00 00 00 00 00
>52e2	b9 52					.word w_nl
.52e4					xt_bl:
.52e4	4c be 4e	jmp $4ebe		jmp xt_x28constantx29
>52e7	20 00					.word 32
.52e9					w_s0:
>52e9	02					.byte $02
>52ea	73 30					.text 's0'
>52ec	00 00 00 00 00 00 00 00			.fill 14,0
>52f4	00 00 00 00 00 00
>52fa	d1 52					.word w_bl
.52fc					xt_s0:
.52fc	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>52ff	00 00					.word 0
.5301					w_r0:
>5301	02					.byte $02
>5302	72 30					.text 'r0'
>5304	00 00 00 00 00 00 00 00			.fill 14,0
>530c	00 00 00 00 00 00
>5312	e9 52					.word w_s0
.5314					xt_r0:
.5314	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>5317	02 00					.word 2
.5319					w_base:
>5319	04					.byte $04
>531a	62 61 73 65				.text 'base'
>531e	00 00 00 00 00 00 00 00			.fill 12,0
>5326	00 00 00 00
>532a	01 53					.word w_r0
.532c					xt_base:
.532c	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>532f	04 00					.word 4
.5331					w_state:
>5331	05					.byte $05
>5332	73 74 61 74 65				.text 'state'
>5337	00 00 00 00 00 00 00 00			.fill 11,0
>533f	00 00 00
>5342	19 53					.word w_base
.5344					xt_state:
.5344	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>5347	06 00					.word 6
.5349					w_context:
>5349	07					.byte $07
>534a	63 6f 6e 74 65 78 74			.text 'context'
>5351	00 00 00 00 00 00 00 00			.fill 9,0
>5359	00
>535a	31 53					.word w_state
.535c					xt_context:
.535c	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>535f	08 00					.word 8
.5361					w_current:
>5361	07					.byte $07
>5362	63 75 72 72 65 6e 74			.text 'current'
>5369	00 00 00 00 00 00 00 00			.fill 9,0
>5371	00
>5372	49 53					.word w_context
.5374					xt_current:
.5374	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>5377	0a 00					.word 10
.5379					w_dp:
>5379	02					.byte $02
>537a	64 70					.text 'dp'
>537c	00 00 00 00 00 00 00 00			.fill 14,0
>5384	00 00 00 00 00 00
>538a	61 53					.word w_current
.538c					xt_dp:
.538c	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>538f	0c 00					.word 12
.5391					w_x3ein:
>5391	03					.byte $03
>5392	3e 69 6e				.text '>in'
>5395	00 00 00 00 00 00 00 00			.fill 13,0
>539d	00 00 00 00 00
>53a2	79 53					.word w_dp
.53a4					xt_x3ein:
.53a4	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>53a7	0e 00					.word 14
.53a9					w_tib:
>53a9	03					.byte $03
>53aa	74 69 62				.text 'tib'
>53ad	00 00 00 00 00 00 00 00			.fill 13,0
>53b5	00 00 00 00 00
>53ba	91 53					.word w_x3ein
.53bc					xt_tib:
.53bc	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>53bf	10 00					.word 16
.53c1					w_sourcex2did:
>53c1	09					.byte $09
>53c2	73 6f 75 72 63 65 2d 69			.text 'source-id'
>53ca	64
>53cb	00 00 00 00 00 00 00			.fill 7,0
>53d2	a9 53					.word w_tib
.53d4					xt_sourcex2did:
.53d4	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>53d7	12 00					.word 18
.53d9					w_blk:
>53d9	03					.byte $03
>53da	62 6c 6b				.text 'blk'
>53dd	00 00 00 00 00 00 00 00			.fill 13,0
>53e5	00 00 00 00 00
>53ea	c1 53					.word w_sourcex2did
.53ec					xt_blk:
.53ec	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>53ef	14 00					.word 20
.53f1					w_dpl:
>53f1	03					.byte $03
>53f2	64 70 6c				.text 'dpl'
>53f5	00 00 00 00 00 00 00 00			.fill 13,0
>53fd	00 00 00 00 00
>5402	d9 53					.word w_blk
.5404					xt_dpl:
.5404	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>5407	16 00					.word 22
.5409					w_hld:
>5409	03					.byte $03
>540a	68 6c 64				.text 'hld'
>540d	00 00 00 00 00 00 00 00			.fill 13,0
>5415	00 00 00 00 00
>541a	f1 53					.word w_dpl
.541c					xt_hld:
.541c	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>541f	18 00					.word 24
.5421					w_handler:
>5421	07					.byte $07
>5422	68 61 6e 64 6c 65 72			.text 'handler'
>5429	00 00 00 00 00 00 00 00			.fill 9,0
>5431	00
>5432	09 54					.word w_hld
.5434					xt_handler:
.5434	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>5437	1a 00					.word 26
.5439					w_csp:
>5439	03					.byte $03
>543a	63 73 70				.text 'csp'
>543d	00 00 00 00 00 00 00 00			.fill 13,0
>5445	00 00 00 00 00
>544a	21 54					.word w_handler
.544c					xt_csp:
.544c	4c f9 4e	jmp $4ef9		jmp xt_x28userx29
>544f	1c 00					.word 28
.5451					w_pad:
>5451	03					.byte $03
>5452	70 61 64				.text 'pad'
>5455	00 00 00 00 00 00 00 00			.fill 13,0
>545d	00 00 00 00 00
>5462	39 54					.word w_csp
.5464					xt_pad:
.5464	4c 0a 43	jmp $430a		jmp xt_enter
>5467	8c 53					.word xt_dp
>5469	65 48					.word xt_x40
>546b	56 46					.word xt_x28literalx29
>546d	00 01					.word 256
>546f	9d 4a					.word xt_x2b
>5471	ee 42					.word xt_exit
.5473					w_x5b:
>5473	c1					.byte $C1
>5474	5b					.text '['
>5475	00 00 00 00 00 00 00 00			.fill 15,0
>547d	00 00 00 00 00 00 00
>5484	51 54					.word w_pad
.5486					xt_x5b:
.5486	4c 0a 43	jmp $430a		jmp xt_enter
>5489	c2 45					.word xt_0
>548b	44 53					.word xt_state
>548d	39 48					.word xt_x21
>548f	ee 42					.word xt_exit
.5491					w_x5d:
>5491	c1					.byte $C1
>5492	5d					.text ']'
>5493	00 00 00 00 00 00 00 00			.fill 15,0
>549b	00 00 00 00 00 00 00
>54a2	73 54					.word w_x5b
.54a4					xt_x5d:
.54a4	4c 0a 43	jmp $430a		jmp xt_enter
>54a7	56 46					.word xt_x28literalx29
>54a9	c0 00					.word 192
>54ab	44 53					.word xt_state
>54ad	39 48					.word xt_x21
>54af	ee 42					.word xt_exit
.54b1					w_x3fdup:
>54b1	04					.byte $04
>54b2	3f 64 75 70				.text '?dup'
>54b6	00 00 00 00 00 00 00 00			.fill 12,0
>54be	00 00 00 00
>54c2	91 54					.word w_x5d
.54c4					xt_x3fdup:
.54c4	4c 0a 43	jmp $430a		jmp xt_enter
>54c7	f8 46					.word xt_dup
>54c9	45 4f					.word xt_x28branch0x29
>54cb	cf 54					.word l_1
>54cd	f8 46					.word xt_dup
.54cf					l_1:
>54cf	ee 42					.word xt_exit
.54d1					w_rot:
>54d1	03					.byte $03
>54d2	72 6f 74				.text 'rot'
>54d5	00 00 00 00 00 00 00 00			.fill 13,0
>54dd	00 00 00 00 00
>54e2	b1 54					.word w_x3fdup
.54e4					xt_rot:
.54e4	4c 0a 43	jmp $430a		jmp xt_enter
>54e7	c6 47					.word xt_x3er
>54e9	18 47					.word xt_swap
>54eb	e4 47					.word xt_rx3e
>54ed	18 47					.word xt_swap
>54ef	ee 42					.word xt_exit
.54f1					w_2dup:
>54f1	04					.byte $04
>54f2	32 64 75 70				.text '2dup'
>54f6	00 00 00 00 00 00 00 00			.fill 12,0
>54fe	00 00 00 00
>5502	d1 54					.word w_rot
.5504					xt_2dup:
.5504	4c 0a 43	jmp $430a		jmp xt_enter
>5507	7c 47					.word xt_over
>5509	7c 47					.word xt_over
>550b	ee 42					.word xt_exit
.550d					w_2drop:
>550d	05					.byte $05
>550e	32 64 72 6f 70				.text '2drop'
>5513	00 00 00 00 00 00 00 00			.fill 11,0
>551b	00 00 00
>551e	f1 54					.word w_2dup
.5520					xt_2drop:
.5520	4c 0a 43	jmp $430a		jmp xt_enter
>5523	e0 46					.word xt_drop
>5525	e0 46					.word xt_drop
>5527	ee 42					.word xt_exit
.5529					w_x3c:
>5529	01					.byte $01
>552a	3c					.text '<'
>552b	00 00 00 00 00 00 00 00			.fill 15,0
>5533	00 00 00 00 00 00 00
>553a	0d 55					.word w_2drop
.553c					xt_x3c:
.553c	4c 0a 43	jmp $430a		jmp xt_enter
>553f	28 4b					.word xt_x2d
>5541	1a 4e					.word xt_0x3c
>5543	ee 42					.word xt_exit
.5545					w_x3e:
>5545	01					.byte $01
>5546	3e					.text '>'
>5547	00 00 00 00 00 00 00 00			.fill 15,0
>554f	00 00 00 00 00 00 00
>5556	29 55					.word w_x3c
.5558					xt_x3e:
.5558	4c 0a 43	jmp $430a		jmp xt_enter
>555b	28 4b					.word xt_x2d
>555d	6c 4e					.word xt_0x3e
>555f	ee 42					.word xt_exit
.5561					w_x3d:
>5561	01					.byte $01
>5562	3d					.text '='
>5563	00 00 00 00 00 00 00 00			.fill 15,0
>556b	00 00 00 00 00 00 00
>5572	45 55					.word w_x3e
.5574					xt_x3d:
.5574	4c 0a 43	jmp $430a		jmp xt_enter
>5577	28 4b					.word xt_x2d
>5579	41 4e					.word xt_0x3d
>557b	ee 42					.word xt_exit
.557d					w_dx3c:
>557d	02					.byte $02
>557e	64 3c					.text 'd<'
>5580	00 00 00 00 00 00 00 00			.fill 14,0
>5588	00 00 00 00 00 00
>558e	61 55					.word w_x3d
.5590					xt_dx3c:
.5590	4c 0a 43	jmp $430a		jmp xt_enter
>5593	f5 4a					.word xt_dx2d
>5595	e0 46					.word xt_drop
>5597	1a 4e					.word xt_0x3c
>5599	ee 42					.word xt_exit
.559b					w_abs:
>559b	03					.byte $03
>559c	61 62 73				.text 'abs'
>559f	00 00 00 00 00 00 00 00			.fill 13,0
>55a7	00 00 00 00 00
>55ac	7d 55					.word w_dx3c
.55ae					xt_abs:
.55ae	4c 0a 43	jmp $430a		jmp xt_enter
>55b1	f8 46					.word xt_dup
>55b3	1a 4e					.word xt_0x3c
>55b5	45 4f					.word xt_x28branch0x29
>55b7	bf 55					.word l_2
>55b9	c2 45					.word xt_0
>55bb	18 47					.word xt_swap
>55bd	28 4b					.word xt_x2d
.55bf					l_2:
>55bf	ee 42					.word xt_exit
.55c1					w_dabs:
>55c1	04					.byte $04
>55c2	64 61 62 73				.text 'dabs'
>55c6	00 00 00 00 00 00 00 00			.fill 12,0
>55ce	00 00 00 00
>55d2	9b 55					.word w_abs
.55d4					xt_dabs:
.55d4	4c 0a 43	jmp $430a		jmp xt_enter
>55d7	7c 47					.word xt_over
>55d9	1a 4e					.word xt_0x3c
>55db	45 4f					.word xt_x28branch0x29
>55dd	e7 55					.word l_3
>55df	c2 45					.word xt_0
>55e1	c2 45					.word xt_0
>55e3	3e 47					.word xt_2swap
>55e5	f5 4a					.word xt_dx2d
.55e7					l_3:
>55e7	ee 42					.word xt_exit
.55e9					w_x2fmod:
>55e9	04					.byte $04
>55ea	2f 6d 6f 64				.text '/mod'
>55ee	00 00 00 00 00 00 00 00			.fill 12,0
>55f6	00 00 00 00
>55fa	c1 55					.word w_dabs
.55fc					xt_x2fmod:
.55fc	4c 0a 43	jmp $430a		jmp xt_enter
>55ff	ee 42					.word xt_exit
.5601					w_x2f:
>5601	01					.byte $01
>5602	2f					.text '/'
>5603	00 00 00 00 00 00 00 00			.fill 15,0
>560b	00 00 00 00 00 00 00
>5612	e9 55					.word w_x2fmod
.5614					xt_x2f:
.5614	4c 0a 43	jmp $430a		jmp xt_enter
>5617	fc 55					.word xt_x2fmod
>5619	18 47					.word xt_swap
>561b	e0 46					.word xt_drop
>561d	ee 42					.word xt_exit
.561f					w_mod:
>561f	03					.byte $03
>5620	6d 6f 64				.text 'mod'
>5623	00 00 00 00 00 00 00 00			.fill 13,0
>562b	00 00 00 00 00
>5630	01 56					.word w_x2f
.5632					xt_mod:
.5632	4c 0a 43	jmp $430a		jmp xt_enter
>5635	fc 55					.word xt_x2fmod
>5637	e0 46					.word xt_drop
>5639	ee 42					.word xt_exit
.563b					w_max:
>563b	03					.byte $03
>563c	6d 61 78				.text 'max'
>563f	00 00 00 00 00 00 00 00			.fill 13,0
>5647	00 00 00 00 00
>564c	1f 56					.word w_mod
.564e					xt_max:
.564e	4c 0a 43	jmp $430a		jmp xt_enter
>5651	04 55					.word xt_2dup
>5653	3c 55					.word xt_x3c
>5655	45 4f					.word xt_x28branch0x29
>5657	61 56					.word l_4
>5659	7c 47					.word xt_over
>565b	e0 46					.word xt_drop
>565d	21 4f					.word xt_x28branchx29
>565f	63 56					.word l_5
.5661					l_4:
>5661	e0 46					.word xt_drop
.5663					l_5:
>5663	ee 42					.word xt_exit
.5665					w_min:
>5665	03					.byte $03
>5666	6d 69 6e				.text 'min'
>5669	00 00 00 00 00 00 00 00			.fill 13,0
>5671	00 00 00 00 00
>5676	3b 56					.word w_max
.5678					xt_min:
.5678	4c 0a 43	jmp $430a		jmp xt_enter
>567b	04 55					.word xt_2dup
>567d	58 55					.word xt_x3e
>567f	45 4f					.word xt_x28branch0x29
>5681	8b 56					.word l_6
>5683	7c 47					.word xt_over
>5685	e0 46					.word xt_drop
>5687	21 4f					.word xt_x28branchx29
>5689	8d 56					.word l_7
.568b					l_6:
>568b	e0 46					.word xt_drop
.568d					l_7:
>568d	ee 42					.word xt_exit
.568f					w_lfa:
>568f	03					.byte $03
>5690	6c 66 61				.text 'lfa'
>5693	00 00 00 00 00 00 00 00			.fill 13,0
>569b	00 00 00 00 00
>56a0	65 56					.word w_min
.56a2					xt_lfa:
.56a2	4c 0a 43	jmp $430a		jmp xt_enter
>56a5	56 46					.word xt_x28literalx29
>56a7	05 00					.word 5
>56a9	28 4b					.word xt_x2d
>56ab	ee 42					.word xt_exit
.56ad					w_cfa:
>56ad	03					.byte $03
>56ae	63 66 61				.text 'cfa'
>56b1	00 00 00 00 00 00 00 00			.fill 13,0
>56b9	00 00 00 00 00
>56be	8f 56					.word w_lfa
.56c0					xt_cfa:
.56c0	4c 0a 43	jmp $430a		jmp xt_enter
>56c3	56 46					.word xt_x28literalx29
>56c5	03 00					.word 3
>56c7	28 4b					.word xt_x2d
>56c9	ee 42					.word xt_exit
.56cb					w_nfa:
>56cb	03					.byte $03
>56cc	6e 66 61				.text 'nfa'
>56cf	00 00 00 00 00 00 00 00			.fill 13,0
>56d7	00 00 00 00 00
>56dc	ad 56					.word w_cfa
.56de					xt_nfa:
.56de	4c 0a 43	jmp $430a		jmp xt_enter
>56e1	56 46					.word xt_x28literalx29
>56e3	17 00					.word 23
>56e5	28 4b					.word xt_x2d
>56e7	ee 42					.word xt_exit
.56e9					w_pfa:
>56e9	03					.byte $03
>56ea	70 66 61				.text 'pfa'
>56ed	00 00 00 00 00 00 00 00			.fill 13,0
>56f5	00 00 00 00 00
>56fa	cb 56					.word w_nfa
.56fc					xt_pfa:
.56fc	4c 0a 43	jmp $430a		jmp xt_enter
>56ff	56 46					.word xt_x28literalx29
>5701	17 00					.word 23
>5703	9d 4a					.word xt_x2b
>5705	ee 42					.word xt_exit
.5707					w_nfax3ecfa:
>5707	07					.byte $07
>5708	6e 66 61 3e 63 66 61			.text 'nfa>cfa'
>570f	00 00 00 00 00 00 00 00			.fill 9,0
>5717	00
>5718	e9 56					.word w_pfa
.571a					xt_nfax3ecfa:
.571a	4c 0a 43	jmp $430a		jmp xt_enter
>571d	56 46					.word xt_x28literalx29
>571f	13 00					.word 19
>5721	9d 4a					.word xt_x2b
>5723	ee 42					.word xt_exit
.5725					w_here:
>5725	04					.byte $04
>5726	68 65 72 65				.text 'here'
>572a	00 00 00 00 00 00 00 00			.fill 12,0
>5732	00 00 00 00
>5736	07 57					.word w_nfax3ecfa
.5738					xt_here:
.5738	4c 0a 43	jmp $430a		jmp xt_enter
>573b	8c 53					.word xt_dp
>573d	65 48					.word xt_x40
>573f	ee 42					.word xt_exit
.5741					w_allot:
>5741	05					.byte $05
>5742	61 6c 6c 6f 74				.text 'allot'
>5747	00 00 00 00 00 00 00 00			.fill 11,0
>574f	00 00 00
>5752	25 57					.word w_here
.5754					xt_allot:
.5754	4c 0a 43	jmp $430a		jmp xt_enter
>5757	8c 53					.word xt_dp
>5759	02 49					.word xt_x2bx21
>575b	ee 42					.word xt_exit
.575d					w_x2c:
>575d	01					.byte $01
>575e	2c					.text ','
>575f	00 00 00 00 00 00 00 00			.fill 15,0
>5767	00 00 00 00 00 00 00
>576e	41 57					.word w_allot
.5770					xt_x2c:
.5770	4c 0a 43	jmp $430a		jmp xt_enter
>5773	38 57					.word xt_here
>5775	39 48					.word xt_x21
>5777	fc 45					.word xt_2
>5779	54 57					.word xt_allot
>577b	ee 42					.word xt_exit
.577d					w_cx2c:
>577d	02					.byte $02
>577e	63 2c					.text 'c,'
>5780	00 00 00 00 00 00 00 00			.fill 14,0
>5788	00 00 00 00 00 00
>578e	5d 57					.word w_x2c
.5790					xt_cx2c:
.5790	4c 0a 43	jmp $430a		jmp xt_enter
>5793	38 57					.word xt_here
>5795	8d 48					.word xt_cx21
>5797	de 45					.word xt_1
>5799	54 57					.word xt_allot
>579b	ee 42					.word xt_exit
.579d					w_definitions:
>579d	0b					.byte $0B
>579e	64 65 66 69 6e 69 74 69			.text 'definitions'
>57a6	6f 6e 73
>57a9	00 00 00 00 00				.fill 5,0
>57ae	7d 57					.word w_cx2c
.57b0					xt_definitions:
.57b0	4c 0a 43	jmp $430a		jmp xt_enter
>57b3	5c 53					.word xt_context
>57b5	65 48					.word xt_x40
>57b7	74 53					.word xt_current
>57b9	39 48					.word xt_x21
>57bb	ee 42					.word xt_exit
.57bd					w_latest:
>57bd	06					.byte $06
>57be	6c 61 74 65 73 74			.text 'latest'
>57c4	00 00 00 00 00 00 00 00			.fill 10,0
>57cc	00 00
>57ce	9d 57					.word w_definitions
.57d0					xt_latest:
.57d0	4c 0a 43	jmp $430a		jmp xt_enter
>57d3	74 53					.word xt_current
>57d5	65 48					.word xt_x40
>57d7	65 48					.word xt_x40
>57d9	ee 42					.word xt_exit
.57db					w_count:
>57db	05					.byte $05
>57dc	63 6f 75 6e 74				.text 'count'
>57e1	00 00 00 00 00 00 00 00			.fill 11,0
>57e9	00 00 00
>57ec	bd 57					.word w_latest
.57ee					xt_count:
.57ee	4c 0a 43	jmp $430a		jmp xt_enter
>57f1	f8 46					.word xt_dup
>57f3	0c 4d					.word xt_1x2b
>57f5	18 47					.word xt_swap
>57f7	ab 48					.word xt_cx40
>57f9	ee 42					.word xt_exit
.57fb					w_type:
>57fb	04					.byte $04
>57fc	74 79 70 65				.text 'type'
>5800	00 00 00 00 00 00 00 00			.fill 12,0
>5808	00 00 00 00
>580c	db 57					.word w_count
.580e					xt_type:
.580e	4c 0a 43	jmp $430a		jmp xt_enter
>5811	c4 54					.word xt_x3fdup
>5813	45 4f					.word xt_x28branch0x29
>5815	39 58					.word l_8
>5817	7c 47					.word xt_over
>5819	9d 4a					.word xt_x2b
>581b	18 47					.word xt_swap
>581d	82 4f					.word xt_x28dox29
.581f					l_9:
>581f	d4 50					.word xt_i
>5821	ab 48					.word xt_cx40
>5823	c4 54					.word xt_x3fdup
>5825	45 4f					.word xt_x28branch0x29
>5827	2f 58					.word l_11
>5829	36 45					.word xt_emit
>582b	21 4f					.word xt_x28branchx29
>582d	31 58					.word l_12
.582f					l_11:
>582f	d8 4f					.word xt_leave
.5831					l_12:
>5831	ff 4f					.word xt_x28loopx29
>5833	1f 58					.word l_9
.5835					l_10:
>5835	21 4f					.word xt_x28branchx29
>5837	3b 58					.word l_13
.5839					l_8:
>5839	e0 46					.word xt_drop
.583b					l_13:
>583b	ee 42					.word xt_exit
.583d					w_x28x2ex22x29:
>583d	04					.byte $04
>583e	28 2e 22 29				.text '(.")'
>5842	00 00 00 00 00 00 00 00			.fill 12,0
>584a	00 00 00 00
>584e	fb 57					.word w_type
.5850					xt_x28x2ex22x29:
.5850	4c 0a 43	jmp $430a		jmp xt_enter
>5853	02 48					.word xt_r
>5855	ee 57					.word xt_count
>5857	f8 46					.word xt_dup
>5859	0c 4d					.word xt_1x2b
>585b	e4 47					.word xt_rx3e
>585d	9d 4a					.word xt_x2b
>585f	c6 47					.word xt_x3er
>5861	0e 58					.word xt_type
>5863	ee 42					.word xt_exit
.5865					w_space:
>5865	05					.byte $05
>5866	73 70 61 63 65				.text 'space'
>586b	00 00 00 00 00 00 00 00			.fill 11,0
>5873	00 00 00
>5876	3d 58					.word w_x28x2ex22x29
.5878					xt_space:
.5878	4c 0a 43	jmp $430a		jmp xt_enter
>587b	56 46					.word xt_x28literalx29
>587d	20 00					.word 32
>587f	36 45					.word xt_emit
>5881	ee 42					.word xt_exit
.5883					w_spaces:
>5883	06					.byte $06
>5884	73 70 61 63 65 73			.text 'spaces'
>588a	00 00 00 00 00 00 00 00			.fill 10,0
>5892	00 00
>5894	65 58					.word w_space
.5896					xt_spaces:
.5896	4c 0a 43	jmp $430a		jmp xt_enter
>5899	f8 46					.word xt_dup
>589b	6c 4e					.word xt_0x3e
>589d	45 4f					.word xt_x28branch0x29
>589f	af 58					.word l_14
>58a1	c2 45					.word xt_0
>58a3	82 4f					.word xt_x28dox29
.58a5					l_15:
>58a5	78 58					.word xt_space
>58a7	ff 4f					.word xt_x28loopx29
>58a9	a5 58					.word l_15
.58ab					l_16:
>58ab	21 4f					.word xt_x28branchx29
>58ad	b1 58					.word l_17
.58af					l_14:
>58af	e0 46					.word xt_drop
.58b1					l_17:
>58b1	ee 42					.word xt_exit
.58b3					w_expect:
>58b3	06					.byte $06
>58b4	65 78 70 65 63 74			.text 'expect'
>58ba	00 00 00 00 00 00 00 00			.fill 10,0
>58c2	00 00
>58c4	83 58					.word w_spaces
.58c6					xt_expect:
.58c6	4c 0a 43	jmp $430a		jmp xt_enter
>58c9	7c 47					.word xt_over
>58cb	9d 4a					.word xt_x2b
>58cd	7c 47					.word xt_over
>58cf	82 4f					.word xt_x28dox29
.58d1					l_18:
>58d1	80 45					.word xt_key
>58d3	b4 52					.word xt_bs
>58d5	fb 50					.word xt_x28ofx29
>58d7	03 59					.word l_21
>58d9	f8 46					.word xt_dup
>58db	d4 50					.word xt_i
>58dd	74 55					.word xt_x3d
>58df	f8 4d					.word xt_not
>58e1	45 4f					.word xt_x28branch0x29
>58e3	ff 58					.word l_22
>58e5	b4 52					.word xt_bs
>58e7	36 45					.word xt_emit
>58e9	e4 52					.word xt_bl
>58eb	36 45					.word xt_emit
>58ed	b4 52					.word xt_bs
>58ef	36 45					.word xt_emit
>58f1	c2 45					.word xt_0
>58f3	d4 50					.word xt_i
>58f5	4b 4d					.word xt_1x2d
>58f7	8d 48					.word xt_cx21
>58f9	d4 50					.word xt_i
>58fb	69 4d					.word xt_2x2d
>58fd	a9 4f					.word xt_x3ei
.58ff					l_22:
>58ff	21 4f					.word xt_x28branchx29
>5901	29 59					.word l_20
.5903					l_21:
>5903	cc 52					.word xt_nl
>5905	fb 50					.word xt_x28ofx29
>5907	15 59					.word l_23
>5909	c2 45					.word xt_0
>590b	d4 50					.word xt_i
>590d	8d 48					.word xt_cx21
>590f	d8 4f					.word xt_leave
>5911	21 4f					.word xt_x28branchx29
>5913	29 59					.word l_20
.5915					l_23:
>5915	f8 46					.word xt_dup
>5917	f8 46					.word xt_dup
>5919	d4 50					.word xt_i
>591b	8d 48					.word xt_cx21
>591d	c2 45					.word xt_0
>591f	d4 50					.word xt_i
>5921	0c 4d					.word xt_1x2b
>5923	8d 48					.word xt_cx21
>5925	36 45					.word xt_emit
>5927	e0 46					.word xt_drop
.5929					l_20:
>5929	ff 4f					.word xt_x28loopx29
>592b	d1 58					.word l_18
.592d					l_19:
>592d	e0 46					.word xt_drop
>592f	ee 42					.word xt_exit
.5931					w_query:
>5931	05					.byte $05
>5932	71 75 65 72 79				.text 'query'
>5937	00 00 00 00 00 00 00 00			.fill 11,0
>593f	00 00 00
>5942	b3 58					.word w_expect
.5944					xt_query:
.5944	4c 0a 43	jmp $430a		jmp xt_enter
>5947	bc 53					.word xt_tib
>5949	65 48					.word xt_x40
>594b	56 46					.word xt_x28literalx29
>594d	50 00					.word 80
>594f	c6 58					.word xt_expect
>5951	c2 45					.word xt_0
>5953	a4 53					.word xt_x3ein
>5955	39 48					.word xt_x21
>5957	ee 42					.word xt_exit
.5959					w_erase:
>5959	05					.byte $05
>595a	65 72 61 73 65				.text 'erase'
>595f	00 00 00 00 00 00 00 00			.fill 11,0
>5967	00 00 00
>596a	31 59					.word w_query
.596c					xt_erase:
.596c	4c 0a 43	jmp $430a		jmp xt_enter
>596f	c2 45					.word xt_0
>5971	c7 48					.word xt_fill
>5973	ee 42					.word xt_exit
.5975					w_blanks:
>5975	06					.byte $06
>5976	62 6c 61 6e 6b 73			.text 'blanks'
>597c	00 00 00 00 00 00 00 00			.fill 10,0
>5984	00 00
>5986	59 59					.word w_erase
.5988					xt_blanks:
.5988	4c 0a 43	jmp $430a		jmp xt_enter
>598b	e4 52					.word xt_bl
>598d	c7 48					.word xt_fill
>598f	ee 42					.word xt_exit
.5991					w_word:
>5991	04					.byte $04
>5992	77 6f 72 64				.text 'word'
>5996	00 00 00 00 00 00 00 00			.fill 12,0
>599e	00 00 00 00
>59a2	75 59					.word w_blanks
.59a4					xt_word:
.59a4	4c 0a 43	jmp $430a		jmp xt_enter
>59a7	bc 53					.word xt_tib
>59a9	65 48					.word xt_x40
>59ab	a4 53					.word xt_x3ein
>59ad	65 48					.word xt_x40
>59af	9d 4a					.word xt_x2b
>59b1	18 47					.word xt_swap
>59b3	33 49					.word xt_enclose
>59b5	c2 45					.word xt_0
>59b7	38 57					.word xt_here
>59b9	39 48					.word xt_x21
>59bb	a4 53					.word xt_x3ein
>59bd	02 49					.word xt_x2bx21
>59bf	7c 47					.word xt_over
>59c1	28 4b					.word xt_x2d
>59c3	c6 47					.word xt_x3er
>59c5	02 48					.word xt_r
>59c7	38 57					.word xt_here
>59c9	8d 48					.word xt_cx21
>59cb	9d 4a					.word xt_x2b
>59cd	38 57					.word xt_here
>59cf	0c 4d					.word xt_1x2b
>59d1	e4 47					.word xt_rx3e
>59d3	a9 49					.word xt_cmove
>59d5	e4 52					.word xt_bl
>59d7	38 57					.word xt_here
>59d9	ee 57					.word xt_count
>59db	9d 4a					.word xt_x2b
>59dd	8d 48					.word xt_cx21
>59df	ee 42					.word xt_exit
.59e1					w_x2dfind:
>59e1	05					.byte $05
>59e2	2d 66 69 6e 64				.text '-find'
>59e7	00 00 00 00 00 00 00 00			.fill 11,0
>59ef	00 00 00
>59f2	91 59					.word w_word
.59f4					xt_x2dfind:
.59f4	4c 0a 43	jmp $430a		jmp xt_enter
>59f7	e4 52					.word xt_bl
>59f9	a4 59					.word xt_word
>59fb	38 57					.word xt_here
>59fd	5c 53					.word xt_context
>59ff	65 48					.word xt_x40
>5a01	65 48					.word xt_x40
>5a03	ab 51					.word xt_x28findx29
>5a05	f8 46					.word xt_dup
>5a07	41 4e					.word xt_0x3d
>5a09	45 4f					.word xt_x28branch0x29
>5a0b	15 5a					.word l_24
>5a0d	e0 46					.word xt_drop
>5a0f	38 57					.word xt_here
>5a11	d0 57					.word xt_latest
>5a13	ab 51					.word xt_x28findx29
.5a15					l_24:
>5a15	ee 42					.word xt_exit
.5a17					w_decimal:
>5a17	07					.byte $07
>5a18	64 65 63 69 6d 61 6c			.text 'decimal'
>5a1f	00 00 00 00 00 00 00 00			.fill 9,0
>5a27	00
>5a28	e1 59					.word w_x2dfind
.5a2a					xt_decimal:
.5a2a	4c 0a 43	jmp $430a		jmp xt_enter
>5a2d	56 46					.word xt_x28literalx29
>5a2f	0a 00					.word 10
>5a31	2c 53					.word xt_base
>5a33	39 48					.word xt_x21
>5a35	ee 42					.word xt_exit
.5a37					w_hex:
>5a37	03					.byte $03
>5a38	68 65 78				.text 'hex'
>5a3b	00 00 00 00 00 00 00 00			.fill 13,0
>5a43	00 00 00 00 00
>5a48	17 5a					.word w_decimal
.5a4a					xt_hex:
.5a4a	4c 0a 43	jmp $430a		jmp xt_enter
>5a4d	56 46					.word xt_x28literalx29
>5a4f	10 00					.word 16
>5a51	2c 53					.word xt_base
>5a53	39 48					.word xt_x21
>5a55	ee 42					.word xt_exit
.5a57					w_octal:
>5a57	05					.byte $05
>5a58	6f 63 74 61 6c				.text 'octal'
>5a5d	00 00 00 00 00 00 00 00			.fill 11,0
>5a65	00 00 00
>5a68	37 5a					.word w_hex
.5a6a					xt_octal:
.5a6a	4c 0a 43	jmp $430a		jmp xt_enter
>5a6d	56 46					.word xt_x28literalx29
>5a6f	08 00					.word 8
>5a71	2c 53					.word xt_base
>5a73	39 48					.word xt_x21
>5a75	ee 42					.word xt_exit
.5a77					w_x2e:
>5a77	01					.byte $01
>5a78	2e					.text '.'
>5a79	00 00 00 00 00 00 00 00			.fill 15,0
>5a81	00 00 00 00 00 00 00
>5a88	57 5a					.word w_octal
.5a8a					xt_x2e:
.5a8a	4c 0a 43	jmp $430a		jmp xt_enter
>5a8d	dd 4c					.word xt_sx3ed
>5a8f	a6 5c					.word xt_dx2e
>5a91	ee 42					.word xt_exit
.5a93					w_x28numberx29:
>5a93	08					.byte $08
>5a94	28 6e 75 6d 62 65 72 29			.text '(number)'
>5a9c	00 00 00 00 00 00 00 00			.fill 8,0
>5aa4	77 5a					.word w_x2e
.5aa6					xt_x28numberx29:
.5aa6	4c 0a 43	jmp $430a		jmp xt_enter
.5aa9					l_25:
>5aa9	f8 46					.word xt_dup
>5aab	c6 47					.word xt_x3er
>5aad	ab 48					.word xt_cx40
>5aaf	2c 53					.word xt_base
>5ab1	65 48					.word xt_x40
>5ab3	2a 52					.word xt_digit
>5ab5	45 4f					.word xt_x28branch0x29
>5ab7	cf 5a					.word l_26
>5ab9	c6 47					.word xt_x3er
>5abb	2c 53					.word xt_base
>5abd	65 48					.word xt_x40
>5abf	4d 4b					.word xt_ux2a
>5ac1	e4 47					.word xt_rx3e
>5ac3	dd 4c					.word xt_sx3ed
>5ac5	c2 4a					.word xt_dx2b
>5ac7	e4 47					.word xt_rx3e
>5ac9	0c 4d					.word xt_1x2b
>5acb	21 4f					.word xt_x28branchx29
>5acd	a9 5a					.word l_25
.5acf					l_26:
>5acf	e4 47					.word xt_rx3e
>5ad1	ee 42					.word xt_exit
.5ad3					w_x3ferror:
>5ad3	06					.byte $06
>5ad4	3f 65 72 72 6f 72			.text '?error'
>5ada	00 00 00 00 00 00 00 00			.fill 10,0
>5ae2	00 00
>5ae4	93 5a					.word w_x28numberx29
.5ae6					xt_x3ferror:
.5ae6	4c 0a 43	jmp $430a		jmp xt_enter
>5ae9	18 47					.word xt_swap
>5aeb	45 4f					.word xt_x28branch0x29
>5aed	f5 5a					.word l_62
>5aef	e2 5f					.word xt_error
>5af1	21 4f					.word xt_x28branchx29
>5af3	f7 5a					.word l_63
.5af5					l_62:
>5af5	e0 46					.word xt_drop
.5af7					l_63:
>5af7	ee 42					.word xt_exit
.5af9					w_number:
>5af9	06					.byte $06
>5afa	6e 75 6d 62 65 72			.text 'number'
>5b00	00 00 00 00 00 00 00 00			.fill 10,0
>5b08	00 00
>5b0a	d3 5a					.word w_x3ferror
.5b0c					xt_number:
.5b0c	4c 0a 43	jmp $430a		jmp xt_enter
>5b0f	c2 45					.word xt_0
>5b11	c2 45					.word xt_0
>5b13	e4 54					.word xt_rot
>5b15	f8 46					.word xt_dup
>5b17	ab 48					.word xt_cx40
>5b19	56 46					.word xt_x28literalx29
>5b1b	2d 00					.word 45
>5b1d	74 55					.word xt_x3d
>5b1f	45 4f					.word xt_x28branch0x29
>5b21	2b 5b					.word l_27
>5b23	de 45					.word xt_1
>5b25	c6 47					.word xt_x3er
>5b27	21 4f					.word xt_x28branchx29
>5b29	33 5b					.word l_28
.5b2b					l_27:
>5b2b	c2 45					.word xt_0
>5b2d	c6 47					.word xt_x3er
>5b2f	de 45					.word xt_1
>5b31	9d 4a					.word xt_x2b
.5b33					l_28:
>5b33	1a 46					.word xt_x2d1
.5b35					l_29:
>5b35	04 54					.word xt_dpl
>5b37	39 48					.word xt_x21
>5b39	a6 5a					.word xt_x28numberx29
>5b3b	f8 46					.word xt_dup
>5b3d	ab 48					.word xt_cx40
>5b3f	e4 52					.word xt_bl
>5b41	28 4b					.word xt_x2d
>5b43	45 4f					.word xt_x28branch0x29
>5b45	61 5b					.word l_30
>5b47	f8 46					.word xt_dup
>5b49	ab 48					.word xt_cx40
>5b4b	56 46					.word xt_x28literalx29
>5b4d	2e 00					.word 46
>5b4f	28 4b					.word xt_x2d
>5b51	45 4f					.word xt_x28branch0x29
>5b53	5b 5b					.word l_31
>5b55	56 46					.word xt_x28literalx29
>5b57	f3 ff					.word 65523
>5b59	e6 5a					.word xt_x3ferror
.5b5b					l_31:
>5b5b	c2 45					.word xt_0
>5b5d	21 4f					.word xt_x28branchx29
>5b5f	35 5b					.word l_29
.5b61					l_30:
>5b61	e0 46					.word xt_drop
>5b63	e4 47					.word xt_rx3e
>5b65	45 4f					.word xt_x28branch0x29
>5b67	71 5b					.word l_32
>5b69	c2 45					.word xt_0
>5b6b	c2 45					.word xt_0
>5b6d	3e 47					.word xt_2swap
>5b6f	f5 4a					.word xt_dx2d
.5b71					l_32:
>5b71	ee 42					.word xt_exit
.5b73					w_x3cx23:
>5b73	02					.byte $02
>5b74	3c 23					.text '<#'
>5b76	00 00 00 00 00 00 00 00			.fill 14,0
>5b7e	00 00 00 00 00 00
>5b84	f9 5a					.word w_number
.5b86					xt_x3cx23:
.5b86	4c 0a 43	jmp $430a		jmp xt_enter
>5b89	64 54					.word xt_pad
>5b8b	1c 54					.word xt_hld
>5b8d	39 48					.word xt_x21
>5b8f	ee 42					.word xt_exit
.5b91					w_hold:
>5b91	04					.byte $04
>5b92	68 6f 6c 64				.text 'hold'
>5b96	00 00 00 00 00 00 00 00			.fill 12,0
>5b9e	00 00 00 00
>5ba2	73 5b					.word w_x3cx23
.5ba4					xt_hold:
.5ba4	4c 0a 43	jmp $430a		jmp xt_enter
>5ba7	1a 46					.word xt_x2d1
>5ba9	1c 54					.word xt_hld
>5bab	02 49					.word xt_x2bx21
>5bad	1c 54					.word xt_hld
>5baf	65 48					.word xt_x40
>5bb1	8d 48					.word xt_cx21
>5bb3	ee 42					.word xt_exit
.5bb5					w_x23:
>5bb5	01					.byte $01
>5bb6	23					.text '#'
>5bb7	00 00 00 00 00 00 00 00			.fill 15,0
>5bbf	00 00 00 00 00 00 00
>5bc6	91 5b					.word w_hold
.5bc8					xt_x23:
.5bc8	4c 0a 43	jmp $430a		jmp xt_enter
>5bcb	2c 53					.word xt_base
>5bcd	65 48					.word xt_x40
>5bcf	82 4c					.word xt_umx2fmod
>5bd1	dd 4c					.word xt_sx3ed
>5bd3	e4 54					.word xt_rot
>5bd5	56 46					.word xt_x28literalx29
>5bd7	09 00					.word 9
>5bd9	7c 47					.word xt_over
>5bdb	3c 55					.word xt_x3c
>5bdd	45 4f					.word xt_x28branch0x29
>5bdf	e7 5b					.word l_33
>5be1	56 46					.word xt_x28literalx29
>5be3	07 00					.word 7
>5be5	9d 4a					.word xt_x2b
.5be7					l_33:
>5be7	56 46					.word xt_x28literalx29
>5be9	30 00					.word 48
>5beb	9d 4a					.word xt_x2b
>5bed	a4 5b					.word xt_hold
>5bef	ee 42					.word xt_exit
.5bf1					w_x23s:
>5bf1	02					.byte $02
>5bf2	23 73					.text '#s'
>5bf4	00 00 00 00 00 00 00 00			.fill 14,0
>5bfc	00 00 00 00 00 00
>5c02	b5 5b					.word w_x23
.5c04					xt_x23s:
.5c04	4c 0a 43	jmp $430a		jmp xt_enter
.5c07					l_34:
>5c07	c8 5b					.word xt_x23
>5c09	7c 47					.word xt_over
>5c0b	7c 47					.word xt_over
>5c0d	b0 4d					.word xt_or
>5c0f	41 4e					.word xt_0x3d
>5c11	45 4f					.word xt_x28branch0x29
>5c13	07 5c					.word l_34
.5c15					l_35:
>5c15	ee 42					.word xt_exit
.5c17					w_sign:
>5c17	04					.byte $04
>5c18	73 69 67 6e				.text 'sign'
>5c1c	00 00 00 00 00 00 00 00			.fill 12,0
>5c24	00 00 00 00
>5c28	f1 5b					.word w_x23s
.5c2a					xt_sign:
.5c2a	4c 0a 43	jmp $430a		jmp xt_enter
>5c2d	e4 54					.word xt_rot
>5c2f	1a 4e					.word xt_0x3c
>5c31	45 4f					.word xt_x28branch0x29
>5c33	3b 5c					.word l_36
>5c35	56 46					.word xt_x28literalx29
>5c37	2d 00					.word 45
>5c39	a4 5b					.word xt_hold
.5c3b					l_36:
>5c3b	ee 42					.word xt_exit
.5c3d					w_x23x3e:
>5c3d	02					.byte $02
>5c3e	23 3e					.text '#>'
>5c40	00 00 00 00 00 00 00 00			.fill 14,0
>5c48	00 00 00 00 00 00
>5c4e	17 5c					.word w_sign
.5c50					xt_x23x3e:
.5c50	4c 0a 43	jmp $430a		jmp xt_enter
>5c53	20 55					.word xt_2drop
>5c55	1c 54					.word xt_hld
>5c57	65 48					.word xt_x40
>5c59	64 54					.word xt_pad
>5c5b	7c 47					.word xt_over
>5c5d	28 4b					.word xt_x2d
>5c5f	ee 42					.word xt_exit
.5c61					w_dx2er:
>5c61	03					.byte $03
>5c62	64 2e 72				.text 'd.r'
>5c65	00 00 00 00 00 00 00 00			.fill 13,0
>5c6d	00 00 00 00 00
>5c72	3d 5c					.word w_x23x3e
.5c74					xt_dx2er:
.5c74	4c 0a 43	jmp $430a		jmp xt_enter
>5c77	c6 47					.word xt_x3er
>5c79	7c 47					.word xt_over
>5c7b	18 47					.word xt_swap
>5c7d	d4 55					.word xt_dabs
>5c7f	86 5b					.word xt_x3cx23
>5c81	04 5c					.word xt_x23s
>5c83	2a 5c					.word xt_sign
>5c85	50 5c					.word xt_x23x3e
>5c87	e4 47					.word xt_rx3e
>5c89	7c 47					.word xt_over
>5c8b	28 4b					.word xt_x2d
>5c8d	96 58					.word xt_spaces
>5c8f	0e 58					.word xt_type
>5c91	ee 42					.word xt_exit
.5c93					w_dx2e:
>5c93	02					.byte $02
>5c94	64 2e					.text 'd.'
>5c96	00 00 00 00 00 00 00 00			.fill 14,0
>5c9e	00 00 00 00 00 00
>5ca4	61 5c					.word w_dx2er
.5ca6					xt_dx2e:
.5ca6	4c 0a 43	jmp $430a		jmp xt_enter
>5ca9	c2 45					.word xt_0
>5cab	74 5c					.word xt_dx2er
>5cad	ee 42					.word xt_exit
.5caf					w_x2er:
>5caf	02					.byte $02
>5cb0	2e 72					.text '.r'
>5cb2	00 00 00 00 00 00 00 00			.fill 14,0
>5cba	00 00 00 00 00 00
>5cc0	93 5c					.word w_dx2e
.5cc2					xt_x2er:
.5cc2	4c 0a 43	jmp $430a		jmp xt_enter
>5cc5	c6 47					.word xt_x3er
>5cc7	dd 4c					.word xt_sx3ed
>5cc9	e4 47					.word xt_rx3e
>5ccb	74 5c					.word xt_dx2er
>5ccd	ee 42					.word xt_exit
.5ccf					w_x3f:
>5ccf	01					.byte $01
>5cd0	3f					.text '?'
>5cd1	00 00 00 00 00 00 00 00			.fill 15,0
>5cd9	00 00 00 00 00 00 00
>5ce0	af 5c					.word w_x2er
.5ce2					xt_x3f:
.5ce2	4c 0a 43	jmp $430a		jmp xt_enter
>5ce5	65 48					.word xt_x40
>5ce7	8a 5a					.word xt_x2e
>5ce9	ee 42					.word xt_exit
.5ceb					w_dump:
>5ceb	04					.byte $04
>5cec	64 75 6d 70				.text 'dump'
>5cf0	00 00 00 00 00 00 00 00			.fill 12,0
>5cf8	00 00 00 00
>5cfc	cf 5c					.word w_x3f
.5cfe					xt_dump:
.5cfe	4c 0a 43	jmp $430a		jmp xt_enter
>5d01	c2 45					.word xt_0
>5d03	82 4f					.word xt_x28dox29
.5d05					l_37:
>5d05	a5 45					.word xt_cr
>5d07	f8 46					.word xt_dup
>5d09	c2 45					.word xt_0
>5d0b	18 47					.word xt_swap
>5d0d	56 46					.word xt_x28literalx29
>5d0f	05 00					.word 5
>5d11	74 5c					.word xt_dx2er
>5d13	56 46					.word xt_x28literalx29
>5d15	3a 00					.word 58
>5d17	36 45					.word xt_emit
>5d19	56 46					.word xt_x28literalx29
>5d1b	08 00					.word 8
>5d1d	c2 45					.word xt_0
>5d1f	82 4f					.word xt_x28dox29
.5d21					l_39:
>5d21	f8 46					.word xt_dup
>5d23	65 48					.word xt_x40
>5d25	c2 45					.word xt_0
>5d27	18 47					.word xt_swap
>5d29	56 46					.word xt_x28literalx29
>5d2b	05 00					.word 5
>5d2d	74 5c					.word xt_dx2er
>5d2f	28 4d					.word xt_2x2b
>5d31	ff 4f					.word xt_x28loopx29
>5d33	21 5d					.word l_39
.5d35					l_40:
>5d35	56 46					.word xt_x28literalx29
>5d37	08 00					.word 8
>5d39	60 50					.word xt_x28x2bloopx29
>5d3b	05 5d					.word l_37
.5d3d					l_38:
>5d3d	e0 46					.word xt_drop
>5d3f	ee 42					.word xt_exit
.5d41					w_between:
>5d41	07					.byte $07
>5d42	62 65 74 77 65 65 6e			.text 'between'
>5d49	00 00 00 00 00 00 00 00			.fill 9,0
>5d51	00
>5d52	eb 5c					.word w_dump
.5d54					xt_between:
.5d54	4c 0a 43	jmp $430a		jmp xt_enter
>5d57	c6 47					.word xt_x3er
>5d59	7c 47					.word xt_over
>5d5b	c6 47					.word xt_x3er
>5d5d	3c 55					.word xt_x3c
>5d5f	45 4f					.word xt_x28branch0x29
>5d61	71 5d					.word l_41
>5d63	e4 47					.word xt_rx3e
>5d65	e0 46					.word xt_drop
>5d67	e4 47					.word xt_rx3e
>5d69	e0 46					.word xt_drop
>5d6b	c2 45					.word xt_0
>5d6d	21 4f					.word xt_x28branchx29
>5d6f	79 5d					.word l_42
.5d71					l_41:
>5d71	e4 47					.word xt_rx3e
>5d73	e4 47					.word xt_rx3e
>5d75	58 55					.word xt_x3e
>5d77	f8 4d					.word xt_not
.5d79					l_42:
>5d79	ee 42					.word xt_exit
.5d7b					w_isprint:
>5d7b	07					.byte $07
>5d7c	69 73 70 72 69 6e 74			.text 'isprint'
>5d83	00 00 00 00 00 00 00 00			.fill 9,0
>5d8b	00
>5d8c	41 5d					.word w_between
.5d8e					xt_isprint:
.5d8e	4c 0a 43	jmp $430a		jmp xt_enter
>5d91	f8 46					.word xt_dup
>5d93	56 46					.word xt_x28literalx29
>5d95	20 00					.word 32
>5d97	56 46					.word xt_x28literalx29
>5d99	7e 00					.word 126
>5d9b	54 5d					.word xt_between
>5d9d	45 4f					.word xt_x28branch0x29
>5d9f	ab 5d					.word l_43
>5da1	e0 46					.word xt_drop
>5da3	56 46					.word xt_x28literalx29
>5da5	ff ff					.word 65535
>5da7	21 4f					.word xt_x28branchx29
>5da9	b5 5d					.word l_44
.5dab					l_43:
>5dab	56 46					.word xt_x28literalx29
>5dad	a0 00					.word 160
>5daf	56 46					.word xt_x28literalx29
>5db1	ff 00					.word 255
>5db3	54 5d					.word xt_between
.5db5					l_44:
>5db5	ee 42					.word xt_exit
.5db7					w_cprint:
>5db7	06					.byte $06
>5db8	63 70 72 69 6e 74			.text 'cprint'
>5dbe	00 00 00 00 00 00 00 00			.fill 10,0
>5dc6	00 00
>5dc8	7b 5d					.word w_isprint
.5dca					xt_cprint:
.5dca	4c 0a 43	jmp $430a		jmp xt_enter
>5dcd	f8 46					.word xt_dup
>5dcf	8e 5d					.word xt_isprint
>5dd1	45 4f					.word xt_x28branch0x29
>5dd3	db 5d					.word l_45
>5dd5	36 45					.word xt_emit
>5dd7	21 4f					.word xt_x28branchx29
>5dd9	e3 5d					.word l_46
.5ddb					l_45:
>5ddb	e0 46					.word xt_drop
>5ddd	56 46					.word xt_x28literalx29
>5ddf	2e 00					.word 46
>5de1	36 45					.word xt_emit
.5de3					l_46:
>5de3	ee 42					.word xt_exit
.5de5					w_cdump:
>5de5	05					.byte $05
>5de6	63 64 75 6d 70				.text 'cdump'
>5deb	00 00 00 00 00 00 00 00			.fill 11,0
>5df3	00 00 00
>5df6	b7 5d					.word w_cprint
.5df8					xt_cdump:
.5df8	4c 0a 43	jmp $430a		jmp xt_enter
>5dfb	7c 47					.word xt_over
>5dfd	9d 4a					.word xt_x2b
>5dff	7c 47					.word xt_over
>5e01	82 4f					.word xt_x28dox29
.5e03					l_47:
>5e03	a5 45					.word xt_cr
>5e05	d4 50					.word xt_i
>5e07	dd 4c					.word xt_sx3ed
>5e09	56 46					.word xt_x28literalx29
>5e0b	05 00					.word 5
>5e0d	74 5c					.word xt_dx2er
>5e0f	56 46					.word xt_x28literalx29
>5e11	3a 00					.word 58
>5e13	36 45					.word xt_emit
>5e15	78 58					.word xt_space
>5e17	d4 50					.word xt_i
>5e19	56 46					.word xt_x28literalx29
>5e1b	08 00					.word 8
>5e1d	c2 45					.word xt_0
>5e1f	82 4f					.word xt_x28dox29
.5e21					l_49:
>5e21	f8 46					.word xt_dup
>5e23	d4 50					.word xt_i
>5e25	9d 4a					.word xt_x2b
>5e27	ab 48					.word xt_cx40
>5e29	dd 4c					.word xt_sx3ed
>5e2b	fc 45					.word xt_2
>5e2d	74 5c					.word xt_dx2er
>5e2f	56 46					.word xt_x28literalx29
>5e31	20 00					.word 32
>5e33	36 45					.word xt_emit
>5e35	ff 4f					.word xt_x28loopx29
>5e37	21 5e					.word l_49
.5e39					l_50:
>5e39	fc 45					.word xt_2
>5e3b	96 58					.word xt_spaces
>5e3d	d4 50					.word xt_i
>5e3f	56 46					.word xt_x28literalx29
>5e41	08 00					.word 8
>5e43	c2 45					.word xt_0
>5e45	82 4f					.word xt_x28dox29
.5e47					l_51:
>5e47	f8 46					.word xt_dup
>5e49	d4 50					.word xt_i
>5e4b	9d 4a					.word xt_x2b
>5e4d	ab 48					.word xt_cx40
>5e4f	ca 5d					.word xt_cprint
>5e51	ff 4f					.word xt_x28loopx29
>5e53	47 5e					.word l_51
.5e55					l_52:
>5e55	56 46					.word xt_x28literalx29
>5e57	08 00					.word 8
>5e59	60 50					.word xt_x28x2bloopx29
>5e5b	03 5e					.word l_47
.5e5d					l_48:
>5e5d	e0 46					.word xt_drop
>5e5f	ee 42					.word xt_exit
.5e61					w_x2ex22:
>5e61	c2					.byte $C2
>5e62	2e 22					.text '."'
>5e64	00 00 00 00 00 00 00 00			.fill 14,0
>5e6c	00 00 00 00 00 00
>5e72	e5 5d					.word w_cdump
.5e74					xt_x2ex22:
.5e74	4c 0a 43	jmp $430a		jmp xt_enter
>5e77	56 46					.word xt_x28literalx29
>5e79	22 00					.word 34
>5e7b	44 53					.word xt_state
>5e7d	65 48					.word xt_x40
>5e7f	45 4f					.word xt_x28branch0x29
>5e81	97 5e					.word l_53
>5e83	56 46					.word xt_x28literalx29
>5e85	50 58					.word xt_x28x2ex22x29
>5e87	70 57					.word xt_x2c
>5e89	a4 59					.word xt_word
>5e8b	38 57					.word xt_here
>5e8d	ab 48					.word xt_cx40
>5e8f	0c 4d					.word xt_1x2b
>5e91	54 57					.word xt_allot
>5e93	21 4f					.word xt_x28branchx29
>5e95	9b 5e					.word l_54
.5e97					l_53:
>5e97	a4 59					.word xt_word
>5e99	38 57					.word xt_here
.5e9b					l_54:
>5e9b	ee 42					.word xt_exit
.5e9d					w_x28:
>5e9d	c1					.byte $C1
>5e9e	28					.text '('
>5e9f	00 00 00 00 00 00 00 00			.fill 15,0
>5ea7	00 00 00 00 00 00 00
>5eae	61 5e					.word w_x2ex22
.5eb0					xt_x28:
.5eb0	4c 0a 43	jmp $430a		jmp xt_enter
>5eb3	56 46					.word xt_x28literalx29
>5eb5	29 00					.word 41
>5eb7	a4 59					.word xt_word
>5eb9	ee 42					.word xt_exit
.5ebb					w_interpret:
>5ebb	09					.byte $09
>5ebc	69 6e 74 65 72 70 72 65			.text 'interpret'
>5ec4	74
>5ec5	00 00 00 00 00 00 00			.fill 7,0
>5ecc	9d 5e					.word w_x28
.5ece					xt_interpret:
.5ece	4c 0a 43	jmp $430a		jmp xt_enter
.5ed1					l_65:
>5ed1	bc 53					.word xt_tib
>5ed3	65 48					.word xt_x40
>5ed5	a4 53					.word xt_x3ein
>5ed7	65 48					.word xt_x40
>5ed9	9d 4a					.word xt_x2b
>5edb	ab 48					.word xt_cx40
>5edd	45 4f					.word xt_x28branch0x29
>5edf	1d 5f					.word l_66
>5ee1	f4 59					.word xt_x2dfind
>5ee3	45 4f					.word xt_x28branch0x29
>5ee5	01 5f					.word l_67
>5ee7	44 53					.word xt_state
>5ee9	65 48					.word xt_x40
>5eeb	3c 55					.word xt_x3c
>5eed	45 4f					.word xt_x28branch0x29
>5eef	f9 5e					.word l_68
>5ef1	c0 56					.word xt_cfa
>5ef3	70 57					.word xt_x2c
>5ef5	21 4f					.word xt_x28branchx29
>5ef7	fd 5e					.word l_69
.5ef9					l_68:
>5ef9	c0 56					.word xt_cfa
>5efb	41 51					.word xt_execute
.5efd					l_69:
>5efd	21 4f					.word xt_x28branchx29
>5eff	19 5f					.word l_70
.5f01					l_67:
>5f01	38 57					.word xt_here
>5f03	0c 5b					.word xt_number
>5f05	18 47					.word xt_swap
>5f07	e0 46					.word xt_drop
>5f09	44 53					.word xt_state
>5f0b	65 48					.word xt_x40
>5f0d	45 4f					.word xt_x28branch0x29
>5f0f	19 5f					.word l_71
>5f11	56 46					.word xt_x28literalx29
>5f13	56 46					.word xt_x28literalx29
>5f15	70 57					.word xt_x2c
>5f17	70 57					.word xt_x2c
.5f19					l_71:
.5f19					l_70:
>5f19	21 4f					.word xt_x28branchx29
>5f1b	d1 5e					.word l_65
.5f1d					l_66:
>5f1d	ee 42					.word xt_exit
.5f1f					w_catch:
>5f1f	05					.byte $05
>5f20	63 61 74 63 68				.text 'catch'
>5f25	00 00 00 00 00 00 00 00			.fill 11,0
>5f2d	00 00 00
>5f30	bb 5e					.word w_interpret
.5f32					xt_catch:
.5f32	4c 0a 43	jmp $430a		jmp xt_enter
>5f35	fe 44					.word xt_spx40
>5f37	c6 47					.word xt_x3er
>5f39	34 54					.word xt_handler
>5f3b	65 48					.word xt_x40
>5f3d	c6 47					.word xt_x3er
>5f3f	b7 44					.word xt_rpx40
>5f41	34 54					.word xt_handler
>5f43	39 48					.word xt_x21
>5f45	41 51					.word xt_execute
>5f47	e4 47					.word xt_rx3e
>5f49	34 54					.word xt_handler
>5f4b	39 48					.word xt_x21
>5f4d	e4 47					.word xt_rx3e
>5f4f	e0 46					.word xt_drop
>5f51	c2 45					.word xt_0
>5f53	ee 42					.word xt_exit
.5f55					w_throw:
>5f55	05					.byte $05
>5f56	74 68 72 6f 77				.text 'throw'
>5f5b	00 00 00 00 00 00 00 00			.fill 11,0
>5f63	00 00 00
>5f66	1f 5f					.word w_catch
.5f68					xt_throw:
.5f68	4c 0a 43	jmp $430a		jmp xt_enter
>5f6b	c4 54					.word xt_x3fdup
>5f6d	45 4f					.word xt_x28branch0x29
>5f6f	89 5f					.word l_55
>5f71	34 54					.word xt_handler
>5f73	65 48					.word xt_x40
>5f75	de 44					.word xt_rpx21
>5f77	e4 47					.word xt_rx3e
>5f79	34 54					.word xt_handler
>5f7b	39 48					.word xt_x21
>5f7d	e4 47					.word xt_rx3e
>5f7f	18 47					.word xt_swap
>5f81	c6 47					.word xt_x3er
>5f83	1d 45					.word xt_spx21
>5f85	e0 46					.word xt_drop
>5f87	e4 47					.word xt_rx3e
.5f89					l_55:
>5f89	ee 42					.word xt_exit
.5f8b					w_quit:
>5f8b	04					.byte $04
>5f8c	71 75 69 74				.text 'quit'
>5f90	00 00 00 00 00 00 00 00			.fill 12,0
>5f98	00 00 00 00
>5f9c	55 5f					.word w_throw
.5f9e					xt_quit:
.5f9e	4c 0a 43	jmp $430a		jmp xt_enter
>5fa1	93 51					.word xt_forth
>5fa3	b0 57					.word xt_definitions
>5fa5	c2 45					.word xt_0
>5fa7	44 53					.word xt_state
>5fa9	39 48					.word xt_x21
.5fab					l_56:
>5fab	a5 45					.word xt_cr
>5fad	44 53					.word xt_state
>5faf	65 48					.word xt_x40
>5fb1	41 4e					.word xt_0x3d
>5fb3	45 4f					.word xt_x28branch0x29
>5fb5	c3 5f					.word l_58
>5fb7	a5 45					.word xt_cr
>5fb9	56 46					.word xt_x28literalx29
>5fbb	3e 00					.word 62
>5fbd	36 45					.word xt_emit
>5fbf	e4 52					.word xt_bl
>5fc1	36 45					.word xt_emit
.5fc3					l_58:
>5fc3	44 59					.word xt_query
>5fc5	a5 45					.word xt_cr
>5fc7	ce 5e					.word xt_interpret
>5fc9	21 4f					.word xt_x28branchx29
>5fcb	ab 5f					.word l_56
.5fcd					l_57:
>5fcd	ee 42					.word xt_exit
.5fcf					w_error:
>5fcf	05					.byte $05
>5fd0	65 72 72 6f 72				.text 'error'
>5fd5	00 00 00 00 00 00 00 00			.fill 11,0
>5fdd	00 00 00
>5fe0	8b 5f					.word w_quit
.5fe2					xt_error:
.5fe2	4c 0a 43	jmp $430a		jmp xt_enter
>5fe5	f8 46					.word xt_dup
>5fe7	41 4e					.word xt_0x3d
>5fe9	f8 4d					.word xt_not
>5feb	45 4f					.word xt_x28branch0x29
>5fed	00 60					.word l_59
>5fef	38 57					.word xt_here
>5ff1	ee 57					.word xt_count
>5ff3	0e 58					.word xt_type
>5ff5	50 58					.word xt_x28x2ex22x29
>5ff7	06 3f 20 4d 53 47 23			.ptext "? MSG#"
>5ffe	8a 5a					.word xt_x2e
.6000					l_59:
>6000	9e 5f					.word xt_quit
>6002	ee 42					.word xt_exit
.6004					w_x3fcsp:
>6004	04					.byte $04
>6005	3f 63 73 70				.text '?csp'
>6009	00 00 00 00 00 00 00 00			.fill 12,0
>6011	00 00 00 00
>6015	cf 5f					.word w_error
.6017					xt_x3fcsp:
.6017	4c 0a 43	jmp $430a		jmp xt_enter
>601a	4c 54					.word xt_csp
>601c	65 48					.word xt_x40
>601e	fe 44					.word xt_spx40
>6020	28 4b					.word xt_x2d
>6022	45 4f					.word xt_x28branch0x29
>6024	30 60					.word l_64
>6026	c2 45					.word xt_0
>6028	56 46					.word xt_x28literalx29
>602a	19 00					.word 25
>602c	28 4b					.word xt_x2d
>602e	e2 5f					.word xt_error
.6030					l_64:
>6030	ee 42					.word xt_exit
.6032					w_x3fcontrol:
>6032	08					.byte $08
>6033	3f 63 6f 6e 74 72 6f 6c			.text '?control'
>603b	00 00 00 00 00 00 00 00			.fill 8,0
>6043	04 60					.word w_x3fcsp
.6045					xt_x3fcontrol:
.6045	4c 0a 43	jmp $430a		jmp xt_enter
>6048	28 4b					.word xt_x2d
>604a	c2 45					.word xt_0
>604c	56 46					.word xt_x28literalx29
>604e	16 00					.word 22
>6050	28 4b					.word xt_x2d
>6052	e6 5a					.word xt_x3ferror
>6054	ee 42					.word xt_exit
.6056					w_begin:
>6056	c5					.byte $C5
>6057	62 65 67 69 6e				.text 'begin'
>605c	00 00 00 00 00 00 00 00			.fill 11,0
>6064	00 00 00
>6067	32 60					.word w_x3fcontrol
.6069					xt_begin:
.6069	4c 0a 43	jmp $430a		jmp xt_enter
>606c	38 57					.word xt_here
>606e	de 45					.word xt_1
>6070	ee 42					.word xt_exit
.6072					w_again:
>6072	c5					.byte $C5
>6073	61 67 61 69 6e				.text 'again'
>6078	00 00 00 00 00 00 00 00			.fill 11,0
>6080	00 00 00
>6083	56 60					.word w_begin
.6085					xt_again:
.6085	4c 0a 43	jmp $430a		jmp xt_enter
>6088	de 45					.word xt_1
>608a	45 60					.word xt_x3fcontrol
>608c	56 46					.word xt_x28literalx29
>608e	21 4f					.word xt_x28branchx29
>6090	70 57					.word xt_x2c
>6092	70 57					.word xt_x2c
>6094	ee 42					.word xt_exit
.6096					w_until:
>6096	c5					.byte $C5
>6097	75 6e 74 69 6c				.text 'until'
>609c	00 00 00 00 00 00 00 00			.fill 11,0
>60a4	00 00 00
>60a7	72 60					.word w_again
.60a9					xt_until:
.60a9	4c 0a 43	jmp $430a		jmp xt_enter
>60ac	de 45					.word xt_1
>60ae	45 60					.word xt_x3fcontrol
>60b0	56 46					.word xt_x28literalx29
>60b2	45 4f					.word xt_x28branch0x29
>60b4	70 57					.word xt_x2c
>60b6	70 57					.word xt_x2c
>60b8	ee 42					.word xt_exit
.60ba					w_if:
>60ba	c2					.byte $C2
>60bb	69 66					.text 'if'
>60bd	00 00 00 00 00 00 00 00			.fill 14,0
>60c5	00 00 00 00 00 00
>60cb	96 60					.word w_until
.60cd					xt_if:
.60cd	4c 0a 43	jmp $430a		jmp xt_enter
>60d0	56 46					.word xt_x28literalx29
>60d2	45 4f					.word xt_x28branch0x29
>60d4	70 57					.word xt_x2c
>60d6	38 57					.word xt_here
>60d8	c2 45					.word xt_0
>60da	70 57					.word xt_x2c
>60dc	fc 45					.word xt_2
>60de	ee 42					.word xt_exit
.60e0					w_else:
>60e0	c4					.byte $C4
>60e1	65 6c 73 65				.text 'else'
>60e5	00 00 00 00 00 00 00 00			.fill 12,0
>60ed	00 00 00 00
>60f1	ba 60					.word w_if
.60f3					xt_else:
.60f3	4c 0a 43	jmp $430a		jmp xt_enter
>60f6	fc 45					.word xt_2
>60f8	45 60					.word xt_x3fcontrol
>60fa	56 46					.word xt_x28literalx29
>60fc	21 4f					.word xt_x28branchx29
>60fe	70 57					.word xt_x2c
>6100	38 57					.word xt_here
>6102	18 47					.word xt_swap
>6104	c2 45					.word xt_0
>6106	70 57					.word xt_x2c
>6108	38 57					.word xt_here
>610a	18 47					.word xt_swap
>610c	39 48					.word xt_x21
>610e	fc 45					.word xt_2
>6110	ee 42					.word xt_exit
.6112					w_then:
>6112	c4					.byte $C4
>6113	74 68 65 6e				.text 'then'
>6117	00 00 00 00 00 00 00 00			.fill 12,0
>611f	00 00 00 00
>6123	e0 60					.word w_else
.6125					xt_then:
.6125	4c 0a 43	jmp $430a		jmp xt_enter
>6128	fc 45					.word xt_2
>612a	45 60					.word xt_x3fcontrol
>612c	38 57					.word xt_here
>612e	18 47					.word xt_swap
>6130	39 48					.word xt_x21
>6132	ee 42					.word xt_exit
.6134					w_create:
>6134	06					.byte $06
>6135	63 72 65 61 74 65			.text 'create'
>613b	00 00 00 00 00 00 00 00			.fill 10,0
>6143	00 00
>6145	12 61					.word w_then
.6147					xt_create:
.6147	4c 0a 43	jmp $430a		jmp xt_enter
>614a	38 57					.word xt_here
>614c	e4 52					.word xt_bl
>614e	a4 59					.word xt_word
>6150	56 46					.word xt_x28literalx29
>6152	11 00					.word 17
>6154	54 57					.word xt_allot
>6156	d0 57					.word xt_latest
>6158	70 57					.word xt_x2c
>615a	74 53					.word xt_current
>615c	65 48					.word xt_x40
>615e	39 48					.word xt_x21
>6160	7c 52					.word xt_jumpx2dinstruction
>6162	90 57					.word xt_cx2c
>6164	56 46					.word xt_x28literalx29
>6166	0a 43					.word xt_enter
>6168	70 57					.word xt_x2c
>616a	ee 42					.word xt_exit
.616c					w_x3a:
>616c	01					.byte $01
>616d	3a					.text ':'
>616e	00 00 00 00 00 00 00 00			.fill 15,0
>6176	00 00 00 00 00 00 00
>617d	34 61					.word w_create
.617f					xt_x3a:
.617f	4c 0a 43	jmp $430a		jmp xt_enter
>6182	74 53					.word xt_current
>6184	65 48					.word xt_x40
>6186	5c 53					.word xt_context
>6188	39 48					.word xt_x21
>618a	47 61					.word xt_create
>618c	a4 54					.word xt_x5d
>618e	ee 42					.word xt_exit
.6190					w_x28x3bcodex29:
>6190	07					.byte $07
>6191	28 3b 63 6f 64 65 29			.text '(;code)'
>6198	00 00 00 00 00 00 00 00			.fill 9,0
>61a0	00
>61a1	6c 61					.word w_x3a
.61a3					xt_x28x3bcodex29:
.61a3	4c 0a 43	jmp $430a		jmp xt_enter
>61a6	d0 57					.word xt_latest
>61a8	1a 57					.word xt_nfax3ecfa
>61aa	f8 46					.word xt_dup
>61ac	7c 52					.word xt_jumpx2dinstruction
>61ae	18 47					.word xt_swap
>61b0	8d 48					.word xt_cx21
>61b2	0c 4d					.word xt_1x2b
>61b4	e4 47					.word xt_rx3e
>61b6	18 47					.word xt_swap
>61b8	39 48					.word xt_x21
>61ba	ee 42					.word xt_exit
.61bc					w_x3bcode:
>61bc	c5					.byte $C5
>61bd	3b 63 6f 64 65				.text ';code'
>61c2	00 00 00 00 00 00 00 00			.fill 11,0
>61ca	00 00 00
>61cd	90 61					.word w_x28x3bcodex29
.61cf					xt_x3bcode:
.61cf	4c 0a 43	jmp $430a		jmp xt_enter
>61d2	56 46					.word xt_x28literalx29
>61d4	a3 61					.word xt_x28x3bcodex29
>61d6	70 57					.word xt_x2c
>61d8	86 54					.word xt_x5b
>61da	ee 42					.word xt_exit
.61dc					w_doesx3e:
>61dc	c5					.byte $C5
>61dd	64 6f 65 73 3e				.text 'does>'
>61e2	00 00 00 00 00 00 00 00			.fill 11,0
>61ea	00 00 00
>61ed	bc 61					.word w_x3bcode
.61ef					xt_doesx3e:
.61ef	4c 0a 43	jmp $430a		jmp xt_enter
>61f2	56 46					.word xt_x28literalx29
>61f4	a3 61					.word xt_x28x3bcodex29
>61f6	70 57					.word xt_x2c
>61f8	98 52					.word xt_callx2dinstruction
>61fa	90 57					.word xt_cx2c
>61fc	56 46					.word xt_x28literalx29
>61fe	33 43					.word xt_dodoes
>6200	70 57					.word xt_x2c
>6202	ee 42					.word xt_exit
.6204					w_x3b:
>6204	c1					.byte $C1
>6205	3b					.text ';'
>6206	00 00 00 00 00 00 00 00			.fill 15,0
>620e	00 00 00 00 00 00 00
>6215	dc 61					.word w_doesx3e
.6217					xt_x3b:
.6217	4c 0a 43	jmp $430a		jmp xt_enter
>621a	56 46					.word xt_x28literalx29
>621c	ee 42					.word xt_exit
>621e	70 57					.word xt_x2c
>6220	86 54					.word xt_x5b
>6222	ee 42					.word xt_exit
.6224					w_endx2dcode:
>6224	08					.byte $08
>6225	65 6e 64 2d 63 6f 64 65			.text 'end-code'
>622d	00 00 00 00 00 00 00 00			.fill 8,0
>6235	04 62					.word w_x3b
.6237					xt_endx2dcode:
.6237	4c 0a 43	jmp $430a		jmp xt_enter
>623a	7c 52					.word xt_jumpx2dinstruction
>623c	90 57					.word xt_cx2c
>623e	56 46					.word xt_x28literalx29
>6240	c1 42					.word xt_next
>6242	70 57					.word xt_x2c
>6244	ee 42					.word xt_exit
.6246					w_initrandom:
>6246	0a					.byte $0A
>6247	69 6e 69 74 72 61 6e 64			.text 'initrandom'
>624f	6f 6d
>6251	00 00 00 00 00 00			.fill 6,0
>6257	24 62					.word w_endx2dcode
.6259					xt_initrandom:
.6259	4c 0a 43	jmp $430a		jmp xt_enter
>625c	de 45					.word xt_1
>625e	56 46					.word xt_x28literalx29
>6260	a6 d6					.word 54950
>6262	8d 48					.word xt_cx21
>6264	ee 42					.word xt_exit
.6266					w_random:
>6266	06					.byte $06
>6267	72 61 6e 64 6f 6d			.text 'random'
>626d	00 00 00 00 00 00 00 00			.fill 10,0
>6275	00 00
>6277	46 62					.word w_initrandom
.6279					xt_random:
.6279	4c 0a 43	jmp $430a		jmp xt_enter
>627c	56 46					.word xt_x28literalx29
>627e	a4 d6					.word 54948
>6280	65 48					.word xt_x40
>6282	ee 42					.word xt_exit
.6284					w_iox2dpage:
>6284	07					.byte $07
>6285	69 6f 2d 70 61 67 65			.text 'io-page'
>628c	00 00 00 00 00 00 00 00			.fill 9,0
>6294	00
>6295	66 62					.word w_random
.6297					xt_iox2dpage:
.6297	4c be 4e	jmp $4ebe		jmp xt_x28constantx29
>629a	01 00					.word 0001
.629c					w_setx2diox2dtext:
>629c	0b					.byte $0B
>629d	73 65 74 2d 69 6f 2d 74			.text 'set-io-text'
>62a5	65 78 74
>62a8	00 00 00 00 00				.fill 5,0
>62ad	84 62					.word w_iox2dpage
.62af					xt_setx2diox2dtext:
.62af	4c 0a 43	jmp $430a		jmp xt_enter
>62b2	fc 45					.word xt_2
>62b4	97 62					.word xt_iox2dpage
>62b6	8d 48					.word xt_cx21
>62b8	ee 42					.word xt_exit
.62ba					w_setx2diox2dcolor:
>62ba	0c					.byte $0C
>62bb	73 65 74 2d 69 6f 2d 63			.text 'set-io-color'
>62c3	6f 6c 6f 72
>62c7	00 00 00 00				.fill 4,0
>62cb	9c 62					.word w_setx2diox2dtext
.62cd					xt_setx2diox2dcolor:
.62cd	4c 0a 43	jmp $430a		jmp xt_enter
>62d0	56 46					.word xt_x28literalx29
>62d2	03 00					.word 3
>62d4	97 62					.word xt_iox2dpage
>62d6	8d 48					.word xt_cx21
>62d8	ee 42					.word xt_exit
.62da					w_defx2dtextx2dfgx2dcolor:
>62da	10					.byte $10
>62db	64 65 66 2d 74 65 78 74			.text 'def-text-fg-colo'
>62e3	2d 66 67 2d 63 6f 6c 6f
>62eb						.fill 0,0
>62eb	ba 62					.word w_setx2diox2dcolor
.62ed					xt_defx2dtextx2dfgx2dcolor:
.62ed	4c 0a 43	jmp $430a		jmp xt_enter
>62f0	56 46					.word xt_x28literalx29
>62f2	0f 00					.word 15
>62f4	8c 4d					.word xt_and
>62f6	97 62					.word xt_iox2dpage
>62f8	ab 48					.word xt_cx40
>62fa	c6 47					.word xt_x3er
>62fc	c2 45					.word xt_0
>62fe	97 62					.word xt_iox2dpage
>6300	8d 48					.word xt_cx21
>6302	56 46					.word xt_x28literalx29
>6304	04 00					.word 4
>6306	85 4b					.word xt_x2a
>6308	56 46					.word xt_x28literalx29
>630a	00 d8					.word 55296
>630c	9d 4a					.word xt_x2b
>630e	f8 46					.word xt_dup
>6310	56 46					.word xt_x28literalx29
>6312	03 00					.word 3
>6314	9d 4a					.word xt_x2b
>6316	18 47					.word xt_swap
>6318	82 4f					.word xt_x28dox29
.631a					l_72:
>631a	d4 50					.word xt_i
>631c	8d 48					.word xt_cx21
>631e	ff 4f					.word xt_x28loopx29
>6320	1a 63					.word l_72
.6322					l_73:
>6322	e4 47					.word xt_rx3e
>6324	97 62					.word xt_iox2dpage
>6326	8d 48					.word xt_cx21
>6328	ee 42					.word xt_exit
.632a					w_defx2dtextx2dbgx2dcolor:
>632a	10					.byte $10
>632b	64 65 66 2d 74 65 78 74			.text 'def-text-bg-colo'
>6333	2d 62 67 2d 63 6f 6c 6f
>633b						.fill 0,0
>633b	da 62					.word w_defx2dtextx2dfgx2dcolor
.633d					xt_defx2dtextx2dbgx2dcolor:
.633d	4c 0a 43	jmp $430a		jmp xt_enter
>6340	56 46					.word xt_x28literalx29
>6342	0f 00					.word 15
>6344	8c 4d					.word xt_and
>6346	97 62					.word xt_iox2dpage
>6348	ab 48					.word xt_cx40
>634a	c6 47					.word xt_x3er
>634c	c2 45					.word xt_0
>634e	97 62					.word xt_iox2dpage
>6350	8d 48					.word xt_cx21
>6352	56 46					.word xt_x28literalx29
>6354	04 00					.word 4
>6356	85 4b					.word xt_x2a
>6358	56 46					.word xt_x28literalx29
>635a	40 d8					.word 55360
>635c	9d 4a					.word xt_x2b
>635e	f8 46					.word xt_dup
>6360	56 46					.word xt_x28literalx29
>6362	03 00					.word 3
>6364	9d 4a					.word xt_x2b
>6366	18 47					.word xt_swap
>6368	82 4f					.word xt_x28dox29
.636a					l_74:
>636a	d4 50					.word xt_i
>636c	8d 48					.word xt_cx21
>636e	ff 4f					.word xt_x28loopx29
>6370	6a 63					.word l_74
.6372					l_75:
>6372	e4 47					.word xt_rx3e
>6374	97 62					.word xt_iox2dpage
>6376	8d 48					.word xt_cx21
>6378	ee 42					.word xt_exit
.637a					w_setx2dborderx2dcolor:
>637a	10					.byte $10
>637b	73 65 74 2d 62 6f 72 64			.text 'set-border-color'
>6383	65 72 2d 63 6f 6c 6f 72
>638b						.fill 0,0
>638b	2a 63					.word w_defx2dtextx2dbgx2dcolor
.638d					xt_setx2dborderx2dcolor:
.638d	4c 0a 43	jmp $430a		jmp xt_enter
>6390	97 62					.word xt_iox2dpage
>6392	ab 48					.word xt_cx40
>6394	c6 47					.word xt_x3er
>6396	c2 45					.word xt_0
>6398	97 62					.word xt_iox2dpage
>639a	8d 48					.word xt_cx21
>639c	56 46					.word xt_x28literalx29
>639e	05 d0					.word 53253
>63a0	8d 48					.word xt_cx21
>63a2	56 46					.word xt_x28literalx29
>63a4	06 d0					.word 53254
>63a6	8d 48					.word xt_cx21
>63a8	56 46					.word xt_x28literalx29
>63aa	07 d0					.word 53255
>63ac	8d 48					.word xt_cx21
>63ae	e4 47					.word xt_rx3e
>63b0	97 62					.word xt_iox2dpage
>63b2	8d 48					.word xt_cx21
>63b4	ee 42					.word xt_exit
.63b6					w_setx2dborderx2dsize:
>63b6	0f					.byte $0F
>63b7	73 65 74 2d 62 6f 72 64			.text 'set-border-size'
>63bf	65 72 2d 73 69 7a 65
>63c6	00					.fill 1,0
>63c7	7a 63					.word w_setx2dborderx2dcolor
.63c9					xt_setx2dborderx2dsize:
.63c9	4c 0a 43	jmp $430a		jmp xt_enter
>63cc	97 62					.word xt_iox2dpage
>63ce	ab 48					.word xt_cx40
>63d0	c6 47					.word xt_x3er
>63d2	c2 45					.word xt_0
>63d4	97 62					.word xt_iox2dpage
>63d6	8d 48					.word xt_cx21
>63d8	7c 47					.word xt_over
>63da	7c 47					.word xt_over
>63dc	b0 4d					.word xt_or
>63de	45 4f					.word xt_x28branch0x29
>63e0	10 64					.word l_76
>63e2	56 46					.word xt_x28literalx29
>63e4	1f 00					.word 31
>63e6	8c 4d					.word xt_and
>63e8	56 46					.word xt_x28literalx29
>63ea	09 d0					.word 53257
>63ec	8d 48					.word xt_cx21
>63ee	56 46					.word xt_x28literalx29
>63f0	1f 00					.word 31
>63f2	8c 4d					.word xt_and
>63f4	56 46					.word xt_x28literalx29
>63f6	08 d0					.word 53256
>63f8	8d 48					.word xt_cx21
>63fa	56 46					.word xt_x28literalx29
>63fc	04 d0					.word 53252
>63fe	ab 48					.word xt_cx40
>6400	56 46					.word xt_x28literalx29
>6402	01 00					.word 1
>6404	b0 4d					.word xt_or
>6406	56 46					.word xt_x28literalx29
>6408	04 d0					.word 53252
>640a	8d 48					.word xt_cx21
>640c	21 4f					.word xt_x28branchx29
>640e	24 64					.word l_77
.6410					l_76:
>6410	56 46					.word xt_x28literalx29
>6412	04 d0					.word 53252
>6414	ab 48					.word xt_cx40
>6416	56 46					.word xt_x28literalx29
>6418	fe 00					.word 254
>641a	8c 4d					.word xt_and
>641c	56 46					.word xt_x28literalx29
>641e	04 d0					.word 53252
>6420	8d 48					.word xt_cx21
>6422	20 55					.word xt_2drop
.6424					l_77:
>6424	e4 47					.word xt_rx3e
>6426	97 62					.word xt_iox2dpage
>6428	8d 48					.word xt_cx21
>642a	ee 42					.word xt_exit
.642c					w_maze:
>642c	04					.byte $04
>642d	6d 61 7a 65				.text 'maze'
>6431	00 00 00 00 00 00 00 00			.fill 12,0
>6439	00 00 00 00
>643d	b6 63					.word w_setx2dborderx2dsize
.643f					xt_maze:
.643f	4c 0a 43	jmp $430a		jmp xt_enter
>6442	59 62					.word xt_initrandom
.6444					l_78:
>6444	79 62					.word xt_random
>6446	de 45					.word xt_1
>6448	8c 4d					.word xt_and
>644a	56 46					.word xt_x28literalx29
>644c	ba 00					.word 186
>644e	9d 4a					.word xt_x2b
>6450	36 45					.word xt_emit
>6452	21 4f					.word xt_x28branchx29
>6454	44 64					.word l_78
.6456					l_79:
>6456	ee 42					.word xt_exit
.6458					w_cold:
>6458	04					.byte $04
>6459	63 6f 6c 64				.text 'cold'
>645d	00 00 00 00 00 00 00 00			.fill 12,0
>6465	00 00 00 00
>6469	2c 64					.word w_maze
.646b					xt_cold:
.646b	4c 0a 43	jmp $430a		jmp xt_enter
>646e	93 51					.word xt_forth
>6470	b0 57					.word xt_definitions
>6472	fc 52					.word xt_s0
>6474	65 48					.word xt_x40
>6476	1d 45					.word xt_spx21
>6478	14 53					.word xt_r0
>647a	65 48					.word xt_x40
>647c	de 44					.word xt_rpx21
>647e	c2 45					.word xt_0
>6480	ec 53					.word xt_blk
>6482	39 48					.word xt_x21
>6484	56 46					.word xt_x28literalx29
>6486	00 08					.word 2048
>6488	8c 53					.word xt_dp
>648a	39 48					.word xt_x21
>648c	2a 5a					.word xt_decimal
>648e	50 58					.word xt_x28x2ex22x29
>6490	1e 57 65 6c 63 6f 6d 65			.ptext "Welcome to MetaForth v00.00.00"
>6498	20 74 6f 20 4d 65 74 61 46 6f 72 74 68 20 76 30
>64a8	30 2e 30 30 2e 30 30
>64af	a5 45					.word xt_cr
>64b1	9e 5f					.word xt_quit
>64b3	ee 42					.word xt_exit

;******  Processing file: mf_post_65c02.asm

.64b5					endcode:

;******  Return to file: forth.asm


;******  End of listing
